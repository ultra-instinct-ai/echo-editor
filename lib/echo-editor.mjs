var ZE = Object.defineProperty;
var zv = (t) => {
  throw TypeError(t);
};
var QE = (t, e, n) => e in t ? ZE(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var fa = (t, e, n) => QE(t, typeof e != "symbol" ? e + "" : e, n), e_ = (t, e, n) => e.has(t) || zv("Cannot " + n);
var pa = (t, e, n) => (e_(t, e, "read from private field"), n ? n.call(t) : e.get(t)), Hv = (t, e, n) => e.has(t) ? zv("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n);
import * as Vv from "vue";
import { defineComponent as I, markRaw as bg, h as Ot, ref as R, getCurrentInstance as qn, watchEffect as Ve, nextTick as ze, unref as h, onBeforeUnmount as mo, onMounted as be, shallowRef as Oi, customRef as wg, provide as el, reactive as hn, render as Uv, computed as L, effectScope as xg, toRef as W2, readonly as Bs, getCurrentScope as Cg, onScopeDispose as Sg, watch as le, onUnmounted as Nt, shallowReadonly as Vi, Fragment as me, Comment as K2, mergeProps as j, cloneVNode as t_, createBlock as T, openBlock as E, withCtx as C, renderSlot as D, toValue as jt, isRef as No, toRefs as st, inject as kg, toHandlerKey as n_, camelize as G2, createCommentVNode as oe, Teleport as qd, normalizeStyle as pt, createVNode as _, createElementBlock as W, renderList as Oe, resolveDynamicComponent as An, withKeys as Sr, withModifiers as mt, watchPostEffect as q2, mergeDefaults as Y2, normalizeProps as _e, guardReactiveProps as Me, createElementVNode as N, createTextVNode as ue, toDisplayString as Y, toHandlers as o_, useSlots as r_, normalizeClass as He, withDirectives as Vn, createSlots as J2, vShow as no, vModelText as i_, isVNode as s_, useAttrs as a_ } from "vue";
function Et(t) {
  this.content = t;
}
Et.prototype = {
  constructor: Et,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var o = n && n != t ? this.remove(n) : this, r = o.find(t), i = o.content.slice();
    return r == -1 ? i.push(n || t, e) : (i[r + 1] = e, n && (i[r] = n)), new Et(i);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Et(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new Et([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Et(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var o = this.remove(e), r = o.content.slice(), i = o.find(t);
    return r.splice(i == -1 ? r.length : i, 0, e, n), new Et(r);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = Et.from(t), t.size ? new Et(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = Et.from(t), t.size ? new Et(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = Et.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Et.from = function(t) {
  if (t instanceof Et) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new Et(e);
};
function X2(t, e, n) {
  for (let o = 0; ; o++) {
    if (o == t.childCount || o == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let r = t.child(o), i = e.child(o);
    if (r == i) {
      n += r.nodeSize;
      continue;
    }
    if (!r.sameMarkup(i))
      return n;
    if (r.isText && r.text != i.text) {
      for (let s = 0; r.text[s] == i.text[s]; s++)
        n++;
      return n;
    }
    if (r.content.size || i.content.size) {
      let s = X2(r.content, i.content, n + 1);
      if (s != null)
        return s;
    }
    n += r.nodeSize;
  }
}
function Z2(t, e, n, o) {
  for (let r = t.childCount, i = e.childCount; ; ) {
    if (r == 0 || i == 0)
      return r == i ? null : { a: n, b: o };
    let s = t.child(--r), a = e.child(--i), l = s.nodeSize;
    if (s == a) {
      n -= l, o -= l;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: o };
    if (s.isText && s.text != a.text) {
      let c = 0, u = Math.min(s.text.length, a.text.length);
      for (; c < u && s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, o--;
      return { a: n, b: o };
    }
    if (s.content.size || a.content.size) {
      let c = Z2(s.content, a.content, n - 1, o - 1);
      if (c)
        return c;
    }
    n -= l, o -= l;
  }
}
class K {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let o = 0; o < e.length; o++)
        this.size += e[o].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, o, r = 0, i) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s], c = a + l.nodeSize;
      if (c > e && o(l, r + a, i || null, s) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), o, r + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, o, r) {
    let i = "", s = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? r ? typeof r == "function" ? r(a) : r : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && o && (s ? s = !1 : i += o), i += c;
    }, 0), i;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, o = e.firstChild, r = this.content.slice(), i = 0;
    for (n.isText && n.sameMarkup(o) && (r[r.length - 1] = n.withText(n.text + o.text), i = 1); i < e.content.length; i++)
      r.push(e.content[i]);
    return new K(r, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let o = [], r = 0;
    if (n > e)
      for (let i = 0, s = 0; s < n; i++) {
        let a = this.content[i], l = s + a.nodeSize;
        l > e && ((s < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, n - s - 1))), o.push(a), r += a.nodeSize), s = l;
      }
    return new K(o, r);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? K.empty : e == 0 && n == this.content.length ? this : new K(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let o = this.content[e];
    if (o == n)
      return this;
    let r = this.content.slice(), i = this.size + n.nodeSize - o.nodeSize;
    return r[e] = n, new K(r, i);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new K([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new K(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, o = 0; n < this.content.length; n++) {
      let r = this.content[n];
      e(r, o, n), o += r.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return X2(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, o = e.size) {
    return Z2(this, e, n, o);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return gc(0, e);
    if (e == this.size)
      return gc(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let o = 0, r = 0; ; o++) {
      let i = this.child(o), s = r + i.nodeSize;
      if (s >= e)
        return s == e || n > 0 ? gc(o + 1, s) : gc(o, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return K.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new K(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return K.empty;
    let n, o = 0;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      o += i.nodeSize, r && i.isText && e[r - 1].sameMarkup(i) ? (n || (n = e.slice(0, r)), n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)) : n && n.push(i);
    }
    return new K(n || e, o);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return K.empty;
    if (e instanceof K)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new K([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
K.empty = new K([], 0);
const ip = { index: 0, offset: 0 };
function gc(t, e) {
  return ip.index = t, ip.offset = e, ip;
}
function Iu(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let o = 0; o < t.length; o++)
      if (!Iu(t[o], e[o]))
        return !1;
  } else {
    for (let o in t)
      if (!(o in e) || !Iu(t[o], e[o]))
        return !1;
    for (let o in e)
      if (!(o in t))
        return !1;
  }
  return !0;
}
let Je = class Oh {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, o = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.eq(i))
        return e;
      if (this.type.excludes(i.type))
        n || (n = e.slice(0, r));
      else {
        if (i.type.excludes(this.type))
          return e;
        !o && i.type.rank > this.type.rank && (n || (n = e.slice(0, r)), n.push(this), o = !0), n && n.push(i);
      }
    }
    return n || (n = e.slice()), o || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Iu(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let o = e.marks[n.type];
    if (!o)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let r = o.create(n.attrs);
    return o.checkAttrs(r.attrs), r;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let o = 0; o < e.length; o++)
      if (!e[o].eq(n[o]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Oh.none;
    if (e instanceof Oh)
      return [e];
    let n = e.slice();
    return n.sort((o, r) => o.type.rank - r.type.rank), n;
  }
};
Je.none = [];
class Ru extends Error {
}
class te {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, o) {
    this.content = e, this.openStart = n, this.openEnd = o;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let o = ex(this.content, e + this.openStart, n);
    return o && new te(o, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new te(Q2(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return te.empty;
    let o = n.openStart || 0, r = n.openEnd || 0;
    if (typeof o != "number" || typeof r != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new te(K.fromJSON(e, n.content), o, r);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let o = 0, r = 0;
    for (let i = e.firstChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.firstChild)
      o++;
    for (let i = e.lastChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.lastChild)
      r++;
    return new te(e, o, r);
  }
}
te.empty = new te(K.empty, 0, 0);
function Q2(t, e, n) {
  let { index: o, offset: r } = t.findIndex(e), i = t.maybeChild(o), { index: s, offset: a } = t.findIndex(n);
  if (r == e || i.isText) {
    if (a != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (o != s)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(o, i.copy(Q2(i.content, e - r - 1, n - r - 1)));
}
function ex(t, e, n, o) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r);
  if (i == e || s.isText)
    return t.cut(0, e).append(n).append(t.cut(e));
  let a = ex(s.content, e - i - 1, n);
  return a && t.replaceChild(r, s.copy(a));
}
function l_(t, e, n) {
  if (n.openStart > t.depth)
    throw new Ru("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new Ru("Inconsistent open depths");
  return tx(t, e, n, 0);
}
function tx(t, e, n, o) {
  let r = t.index(o), i = t.node(o);
  if (r == e.index(o) && o < t.depth - n.openStart) {
    let s = tx(t, e, n, o + 1);
    return i.copy(i.content.replaceChild(r, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == o && e.depth == o) {
      let s = t.parent, a = s.content;
      return pi(s, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: s, end: a } = c_(n, t);
      return pi(i, ox(t, s, a, e, o));
    }
  else return pi(i, $u(t, e, o));
}
function nx(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new Ru("Cannot join " + e.type.name + " onto " + t.type.name);
}
function Mh(t, e, n) {
  let o = t.node(n);
  return nx(o, e.node(n)), o;
}
function fi(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function La(t, e, n, o) {
  let r = (e || t).node(n), i = 0, s = e ? e.index(n) : r.childCount;
  t && (i = t.index(n), t.depth > n ? i++ : t.textOffset && (fi(t.nodeAfter, o), i++));
  for (let a = i; a < s; a++)
    fi(r.child(a), o);
  e && e.depth == n && e.textOffset && fi(e.nodeBefore, o);
}
function pi(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function ox(t, e, n, o, r) {
  let i = t.depth > r && Mh(t, e, r + 1), s = o.depth > r && Mh(n, o, r + 1), a = [];
  return La(null, t, r, a), i && s && e.index(r) == n.index(r) ? (nx(i, s), fi(pi(i, ox(t, e, n, o, r + 1)), a)) : (i && fi(pi(i, $u(t, e, r + 1)), a), La(e, n, r, a), s && fi(pi(s, $u(n, o, r + 1)), a)), La(o, null, r, a), new K(a);
}
function $u(t, e, n) {
  let o = [];
  if (La(null, t, n, o), t.depth > n) {
    let r = Mh(t, e, n + 1);
    fi(pi(r, $u(t, e, n + 1)), o);
  }
  return La(e, null, n, o), new K(o);
}
function c_(t, e) {
  let n = e.depth - t.openStart, r = e.node(n).copy(t.content);
  for (let i = n - 1; i >= 0; i--)
    r = e.node(i).copy(K.from(r));
  return {
    start: r.resolveNoCache(t.openStart + n),
    end: r.resolveNoCache(r.content.size - t.openEnd - n)
  };
}
class tl {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.pos = e, this.path = n, this.parentOffset = o, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let o = this.pos - this.path[this.path.length - 1], r = e.child(n);
    return o ? e.child(n).cut(o) : r;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let o = this.path[n * 3], r = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let i = 0; i < e; i++)
      r += o.child(i).nodeSize;
    return r;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Je.none;
    if (this.textOffset)
      return e.child(n).marks;
    let o = e.maybeChild(n - 1), r = e.maybeChild(n);
    if (!o) {
      let a = o;
      o = r, r = a;
    }
    let i = o.marks;
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 && (!r || !i[s].isInSet(r.marks)) && (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let o = n.marks, r = e.parent.maybeChild(e.index());
    for (var i = 0; i < o.length; i++)
      o[i].type.spec.inclusive === !1 && (!r || !o[i].isInSet(r.marks)) && (o = o[i--].removeFromSet(o));
    return o;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let o = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); o >= 0; o--)
      if (e.pos <= this.end(o) && (!n || n(this.node(o))))
        return new nl(this, e, o);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let o = [], r = 0, i = n;
    for (let s = e; ; ) {
      let { index: a, offset: l } = s.content.findIndex(i), c = i - l;
      if (o.push(s, a, r + l), !c || (s = s.child(a), s.isText))
        break;
      i = c - 1, r += l + 1;
    }
    return new tl(n, o, i);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let o = jv.get(e);
    if (o)
      for (let i = 0; i < o.elts.length; i++) {
        let s = o.elts[i];
        if (s.pos == n)
          return s;
      }
    else
      jv.set(e, o = new u_());
    let r = o.elts[o.i] = tl.resolve(e, n);
    return o.i = (o.i + 1) % d_, r;
  }
}
class u_ {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const d_ = 12, jv = /* @__PURE__ */ new WeakMap();
class nl {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, o) {
    this.$from = e, this.$to = n, this.depth = o;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const f_ = /* @__PURE__ */ Object.create(null);
let yr = class Ih {
  /**
  @internal
  */
  constructor(e, n, o, r = Je.none) {
    this.type = e, this.attrs = n, this.marks = r, this.content = o || K.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, o, r = 0) {
    this.content.nodesBetween(e, n, o, r, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, o, r) {
    return this.content.textBetween(e, n, o, r);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, o) {
    return this.type == e && Iu(this.attrs, n || e.defaultAttrs || f_) && Je.sameSet(this.marks, o || Je.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Ih(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Ih(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, o = !1) {
    if (e == n)
      return te.empty;
    let r = this.resolve(e), i = this.resolve(n), s = o ? 0 : r.sharedDepth(n), a = r.start(s), c = r.node(s).content.cut(r.pos - a, i.pos - a);
    return new te(c, r.depth - s, i.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, o) {
    return l_(this.resolve(e), this.resolve(n), o);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: o, offset: r } = n.content.findIndex(e);
      if (n = n.maybeChild(o), !n)
        return null;
      if (r == e || n.isText)
        return n;
      e -= r + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: o } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: o };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: o } = this.content.findIndex(e);
    if (o < e)
      return { node: this.content.child(n), index: n, offset: o };
    let r = this.content.child(n - 1);
    return { node: r, index: n - 1, offset: o - r.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return tl.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return tl.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, o) {
    let r = !1;
    return n > e && this.nodesBetween(e, n, (i) => (o.isInSet(i.marks) && (r = !0), !r)), r;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), rx(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, o = K.empty, r = 0, i = o.childCount) {
    let s = this.contentMatchAt(e).matchFragment(o, r, i), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = r; l < i; l++)
      if (!this.type.allowsMarks(o.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, o, r) {
    if (r && !this.type.allowsMarks(r))
      return !1;
    let i = this.contentMatchAt(e).matchType(o), s = i && i.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Je.none;
    for (let n = 0; n < this.marks.length; n++) {
      let o = this.marks[n];
      o.type.checkAttrs(o.attrs), e = o.addToSet(e);
    }
    if (!Je.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let o;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      o = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, o);
    }
    let r = K.fromJSON(e, n.content), i = e.nodeType(n.type).create(n.attrs, r, o);
    return i.type.checkAttrs(i.attrs), i;
  }
};
yr.prototype.text = void 0;
class Pu extends yr {
  /**
  @internal
  */
  constructor(e, n, o, r) {
    if (super(e, n, null, r), !o)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = o;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : rx(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Pu(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Pu(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function rx(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class bi {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let o = new p_(e, n);
    if (o.next == null)
      return bi.empty;
    let r = ix(o);
    o.next && o.err("Unexpected trailing text");
    let i = w_(b_(r));
    return x_(i, o), i;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, o = e.childCount) {
    let r = this;
    for (let i = n; r && i < o; i++)
      r = r.matchType(e.child(i).type);
    return r;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let o = 0; o < e.next.length; o++)
        if (this.next[n].type == e.next[o].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, o = 0) {
    let r = [this];
    function i(s, a) {
      let l = s.matchFragment(e, o);
      if (l && (!n || l.validEnd))
        return K.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < s.next.length; c++) {
        let { type: u, next: d } = s.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && r.indexOf(d) == -1) {
          r.push(d);
          let f = i(d, a.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return i(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let o = 0; o < this.wrapCache.length; o += 2)
      if (this.wrapCache[o] == e)
        return this.wrapCache[o + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), o = [{ match: this, type: null, via: null }];
    for (; o.length; ) {
      let r = o.shift(), i = r.match;
      if (i.matchType(e)) {
        let s = [];
        for (let a = r; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < i.next.length; s++) {
        let { type: a, next: l } = i.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!r.type || l.validEnd) && (o.push({ match: a.contentMatch, type: a, via: r }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(o) {
      e.push(o);
      for (let r = 0; r < o.next.length; r++)
        e.indexOf(o.next[r].next) == -1 && n(o.next[r].next);
    }
    return n(this), e.map((o, r) => {
      let i = r + (o.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < o.next.length; s++)
        i += (s ? ", " : "") + o.next[s].type.name + "->" + e.indexOf(o.next[s].next);
      return i;
    }).join(`
`);
  }
}
bi.empty = new bi(!0);
class p_ {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function ix(t) {
  let e = [];
  do
    e.push(h_(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function h_(t) {
  let e = [];
  do
    e.push(m_(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function m_(t) {
  let e = y_(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = g_(t, e);
    else
      break;
  return e;
}
function Wv(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function g_(t, e) {
  let n = Wv(t), o = n;
  return t.eat(",") && (t.next != "}" ? o = Wv(t) : o = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: o, expr: e };
}
function v_(t, e) {
  let n = t.nodeTypes, o = n[e];
  if (o)
    return [o];
  let r = [];
  for (let i in n) {
    let s = n[i];
    s.isInGroup(e) && r.push(s);
  }
  return r.length == 0 && t.err("No node type or group '" + e + "' found"), r;
}
function y_(t) {
  if (t.eat("(")) {
    let e = ix(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = v_(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function b_(t) {
  let e = [[]];
  return r(i(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function o(s, a, l) {
    let c = { term: l, to: a };
    return e[s].push(c), c;
  }
  function r(s, a) {
    s.forEach((l) => l.to = a);
  }
  function i(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, c) => l.concat(i(c, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let c = i(s.exprs[l], a);
        if (l == s.exprs.length - 1)
          return c;
        r(c, a = n());
      }
    else if (s.type == "star") {
      let l = n();
      return o(a, l), r(i(s.expr, l), l), [o(l)];
    } else if (s.type == "plus") {
      let l = n();
      return r(i(s.expr, a), l), r(i(s.expr, l), l), [o(l)];
    } else {
      if (s.type == "opt")
        return [o(a)].concat(i(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let c = 0; c < s.min; c++) {
          let u = n();
          r(i(s.expr, l), u), l = u;
        }
        if (s.max == -1)
          r(i(s.expr, l), l);
        else
          for (let c = s.min; c < s.max; c++) {
            let u = n();
            o(l, u), r(i(s.expr, l), u), l = u;
          }
        return [o(l)];
      } else {
        if (s.type == "name")
          return [o(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function sx(t, e) {
  return e - t;
}
function Kv(t, e) {
  let n = [];
  return o(e), n.sort(sx);
  function o(r) {
    let i = t[r];
    if (i.length == 1 && !i[0].term)
      return o(i[0].to);
    n.push(r);
    for (let s = 0; s < i.length; s++) {
      let { term: a, to: l } = i[s];
      !a && n.indexOf(l) == -1 && o(l);
    }
  }
}
function w_(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(Kv(t, 0));
  function n(o) {
    let r = [];
    o.forEach((s) => {
      t[s].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < r.length; u++)
          r[u][0] == a && (c = r[u][1]);
        Kv(t, l).forEach((u) => {
          c || r.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let i = e[o.join(",")] = new bi(o.indexOf(t.length - 1) > -1);
    for (let s = 0; s < r.length; s++) {
      let a = r[s][1].sort(sx);
      i.next.push({ type: r[s][0], next: e[a.join(",")] || n(a) });
    }
    return i;
  }
}
function x_(t, e) {
  for (let n = 0, o = [t]; n < o.length; n++) {
    let r = o[n], i = !r.validEnd, s = [];
    for (let a = 0; a < r.next.length; a++) {
      let { type: l, next: c } = r.next[a];
      s.push(l.name), i && !(l.isText || l.hasRequiredAttrs()) && (i = !1), o.indexOf(c) == -1 && o.push(c);
    }
    i && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function ax(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let o = t[n];
    if (!o.hasDefault)
      return null;
    e[n] = o.default;
  }
  return e;
}
function lx(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let o in t) {
    let r = e && e[o];
    if (r === void 0) {
      let i = t[o];
      if (i.hasDefault)
        r = i.default;
      else
        throw new RangeError("No value supplied for attribute " + o);
    }
    n[o] = r;
  }
  return n;
}
function cx(t, e, n, o) {
  for (let r in e)
    if (!(r in t))
      throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`);
  for (let r in t) {
    let i = t[r];
    i.validate && i.validate(e[r]);
  }
}
function ux(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let o in e)
      n[o] = new S_(t, o, e[o]);
  return n;
}
let Gv = class dx {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.name = e, this.schema = n, this.spec = o, this.markSet = null, this.groups = o.group ? o.group.split(" ") : [], this.attrs = ux(e, o.attrs), this.defaultAttrs = ax(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(o.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == bi.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : lx(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, o) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new yr(this, this.computeAttrs(e), K.from(n), Je.setFrom(o));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, o) {
    return n = K.from(n), this.checkContent(n), new yr(this, this.computeAttrs(e), n, Je.setFrom(o));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, o) {
    if (e = this.computeAttrs(e), n = K.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let r = this.contentMatch.matchFragment(n), i = r && r.fillBefore(K.empty, !0);
    return i ? new yr(this, e, n.append(i), Je.setFrom(o)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let o = 0; o < e.childCount; o++)
      if (!this.allowsMarks(e.child(o).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    cx(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let o = 0; o < e.length; o++)
      this.allowsMarkType(e[o].type) ? n && n.push(e[o]) : n || (n = e.slice(0, o));
    return n ? n.length ? n : Je.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let o = /* @__PURE__ */ Object.create(null);
    e.forEach((i, s) => o[i] = new dx(i, n, s));
    let r = n.spec.topNode || "doc";
    if (!o[r])
      throw new RangeError("Schema is missing its top node type ('" + r + "')");
    if (!o.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let i in o.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return o;
  }
};
function C_(t, e, n) {
  let o = n.split("|");
  return (r) => {
    let i = r === null ? "null" : typeof r;
    if (o.indexOf(i) < 0)
      throw new RangeError(`Expected value of type ${o} for attribute ${e} on type ${t}, got ${i}`);
  };
}
class S_ {
  constructor(e, n, o) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(o, "default"), this.default = o.default, this.validate = typeof o.validate == "string" ? C_(e, n, o.validate) : o.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Yd {
  /**
  @internal
  */
  constructor(e, n, o, r) {
    this.name = e, this.rank = n, this.schema = o, this.spec = r, this.attrs = ux(e, r.attrs), this.excluded = null;
    let i = ax(this.attrs);
    this.instance = i ? new Je(this, i) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Je(this, lx(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let o = /* @__PURE__ */ Object.create(null), r = 0;
    return e.forEach((i, s) => o[i] = new Yd(i, r++, n, s)), o;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    cx(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class fx {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let r in e)
      n[r] = e[r];
    n.nodes = Et.from(e.nodes), n.marks = Et.from(e.marks || {}), this.nodes = Gv.compile(this.spec.nodes, this), this.marks = Yd.compile(this.spec.marks, this);
    let o = /* @__PURE__ */ Object.create(null);
    for (let r in this.nodes) {
      if (r in this.marks)
        throw new RangeError(r + " can not be both a node and a mark");
      let i = this.nodes[r], s = i.spec.content || "", a = i.spec.marks;
      if (i.contentMatch = o[s] || (o[s] = bi.parse(s, this.nodes)), i.inlineContent = i.contentMatch.inlineContent, i.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!i.isInline || !i.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = i;
      }
      i.markSet = a == "_" ? null : a ? qv(this, a.split(" ")) : a == "" || !i.inlineContent ? [] : null;
    }
    for (let r in this.marks) {
      let i = this.marks[r], s = i.spec.excludes;
      i.excluded = s == null ? [i] : s == "" ? [] : qv(this, s.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, o, r) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Gv) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, o, r);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let o = this.nodes.text;
    return new Pu(o, o.defaultAttrs, e, Je.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return yr.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Je.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function qv(t, e) {
  let n = [];
  for (let o = 0; o < e.length; o++) {
    let r = e[o], i = t.marks[r], s = i;
    if (i)
      n.push(i);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (r == "_" || l.spec.group && l.spec.group.split(" ").indexOf(r) > -1) && n.push(s = l);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + e[o] + "'");
  }
  return n;
}
function k_(t) {
  return t.tag != null;
}
function E_(t) {
  return t.style != null;
}
let Da = class Rh {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let o = this.matchedStyles = [];
    n.forEach((r) => {
      if (k_(r))
        this.tags.push(r);
      else if (E_(r)) {
        let i = /[^=]*/.exec(r.style)[0];
        o.indexOf(i) < 0 && o.push(i), this.styles.push(r);
      }
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let o = new Jv(this, n, !1);
    return o.addAll(e, Je.none, n.from, n.to), o.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let o = new Jv(this, n, !0);
    return o.addAll(e, Je.none, n.from, n.to), te.maxOpen(o.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, o) {
    for (let r = o ? this.tags.indexOf(o) + 1 : 0; r < this.tags.length; r++) {
      let i = this.tags[r];
      if (T_(e, i.tag) && (i.namespace === void 0 || e.namespaceURI == i.namespace) && (!i.context || n.matchesContext(i.context))) {
        if (i.getAttrs) {
          let s = i.getAttrs(e);
          if (s === !1)
            continue;
          i.attrs = s || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, o, r) {
    for (let i = r ? this.styles.indexOf(r) + 1 : 0; i < this.styles.length; i++) {
      let s = this.styles[i], a = s.style;
      if (!(a.indexOf(e) != 0 || s.context && !o.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1)
            continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function o(r) {
      let i = r.priority == null ? 50 : r.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < i)
          break;
      }
      n.splice(s, 0, r);
    }
    for (let r in e.marks) {
      let i = e.marks[r].spec.parseDOM;
      i && i.forEach((s) => {
        o(s = Xv(s)), s.mark || s.ignore || s.clearMark || (s.mark = r);
      });
    }
    for (let r in e.nodes) {
      let i = e.nodes[r].spec.parseDOM;
      i && i.forEach((s) => {
        o(s = Xv(s)), s.node || s.ignore || s.mark || (s.node = r);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Rh(e, Rh.schemaRules(e)));
  }
};
const px = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, __ = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, hx = { ol: !0, ul: !0 }, ol = 1, $h = 2, au = 4;
function Yv(t, e, n) {
  return e != null ? (e ? ol : 0) | (e === "full" ? $h : 0) : t && t.whitespace == "pre" ? ol | $h : n & -5;
}
class vc {
  constructor(e, n, o, r, i, s) {
    this.type = e, this.attrs = n, this.marks = o, this.solid = r, this.options = s, this.content = [], this.activeMarks = Je.none, this.match = i || (s & au ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(K.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let o = this.type.contentMatch, r;
        return (r = o.findWrapping(e.type)) ? (this.match = o, r) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & ol)) {
      let o = this.content[this.content.length - 1], r;
      if (o && o.isText && (r = /[ \t\r\n\u000c]+$/.exec(o.text))) {
        let i = o;
        o.text.length == r[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - r[0].length));
      }
    }
    let n = K.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(K.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !px.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Jv {
  constructor(e, n, o) {
    this.parser = e, this.options = n, this.isOpen = o, this.open = 0, this.localPreserveWS = !1;
    let r = n.topNode, i, s = Yv(null, n.preserveWhitespace, 0) | (o ? au : 0);
    r ? i = new vc(r.type, r.attrs, Je.none, !0, n.topMatch || r.type.contentMatch, s) : o ? i = new vc(null, null, Je.none, !0, null, s) : i = new vc(e.schema.topNodeType, null, Je.none, !0, null, s), this.nodes = [i], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let o = e.nodeValue, r = this.top, i = r.options & $h ? "full" : this.localPreserveWS || (r.options & ol) > 0;
    if (i === "full" || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(o)) {
      if (i)
        i !== "full" ? o = o.replace(/\r?\n|\r/g, " ") : o = o.replace(/\r\n?/g, `
`);
      else if (o = o.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(o) && this.open == this.nodes.length - 1) {
        let s = r.content[r.content.length - 1], a = e.previousSibling;
        (!s || a && a.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (o = o.slice(1));
      }
      o && this.insertNode(this.parser.schema.text(o), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, o) {
    let r = this.localPreserveWS, i = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = e.nodeName.toLowerCase(), a;
    hx.hasOwnProperty(s) && this.parser.normalizeLists && A_(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, o));
    e: if (l ? l.ignore : __.hasOwnProperty(s))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, u = this.needsBlock;
      if (px.hasOwnProperty(s))
        i.content.length && i.content[0].isInline && this.open && (this.open--, i = this.top), c = !0, i.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let d = l && l.skip ? n : this.readStyles(e, n);
      d && this.addAll(e, d), c && this.sync(i), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, n);
      c && this.addElementByRule(e, l, c, l.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = r;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let o = e.style;
    if (o && o.length)
      for (let r = 0; r < this.parser.matchedStyles.length; r++) {
        let i = this.parser.matchedStyles[r], s = o.getPropertyValue(i);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(i, s, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, o, r) {
    let i, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), o) || this.leafFallback(e, o);
      else {
        let l = this.enter(s, n.attrs || null, o, n.preserveWhitespace);
        l && (i = !0, o = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      o = o.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, o, r);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, o));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, o), this.findAround(e, l, !1);
    }
    i && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, o, r) {
    let i = o || 0;
    for (let s = o ? e.childNodes[o] : e.firstChild, a = r == null ? null : e.childNodes[r]; s != a; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s, n);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let o, r;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i], a = s.findWrapping(e);
      if (a && (!o || o.length > a.length) && (o = a, r = s, !a.length) || s.solid)
        break;
    }
    if (!o)
      return null;
    this.sync(r);
    for (let i = 0; i < o.length; i++)
      n = this.enterInner(o[i], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let r = this.textblockFromContext();
      r && (n = this.enterInner(r, null, n));
    }
    let o = this.findPlace(e, n);
    if (o) {
      this.closeExtra();
      let r = this.top;
      r.match && (r.match = r.match.matchType(e.type));
      let i = Je.none;
      for (let s of o.concat(e.marks))
        (r.type ? r.type.allowsMarkType(s.type) : Zv(s.type, e.type)) && (i = s.addToSet(i));
      return r.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, o, r) {
    let i = this.findPlace(e.create(n), o);
    return i && (i = this.enterInner(e, n, o, !0, r)), i;
  }
  // Open a node of the given type
  enterInner(e, n, o, r = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let a = Yv(e, i, s.options);
    s.options & au && s.content.length == 0 && (a |= au);
    let l = Je.none;
    return o = o.filter((c) => (s.type ? s.type.allowsMarkType(c.type) : Zv(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new vc(e, n, l, r, null, a)), this.open++, o;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= ol);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let o = this.nodes[n].content;
      for (let r = o.length - 1; r >= 0; r--)
        e += o[r].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].node == e && this.find[o].offset == n && (this.find[o].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, o) {
    if (e != n && this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && n.compareDocumentPosition(this.find[r].node) & (o ? 2 : 4) && (this.find[r].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), o = this.options.context, r = !this.isOpen && (!o || o.parent.type == this.nodes[0].type), i = -(o ? o.depth + 1 : 0) + (r ? 0 : 1), s = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= i; l--)
            if (s(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && r ? this.nodes[l].type : o && l >= i ? o.node(l - i).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let o = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (o && o.isTextblock && o.defaultAttrs)
          return o;
      }
    for (let n in this.parser.schema.nodes) {
      let o = this.parser.schema.nodes[n];
      if (o.isTextblock && o.defaultAttrs)
        return o;
    }
  }
}
function A_(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let o = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    o && hx.hasOwnProperty(o) && n ? (n.appendChild(e), e = n) : o == "li" ? n = e : o && (n = null);
  }
}
function T_(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function Xv(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function Zv(t, e) {
  let n = e.schema.nodes;
  for (let o in n) {
    let r = n[o];
    if (!r.allowsMarkType(t))
      continue;
    let i = [], s = (a) => {
      i.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || i.indexOf(u) < 0 && s(u))
          return !0;
      }
    };
    if (s(r.contentMatch))
      return !0;
  }
}
class Pr {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, o) {
    o || (o = sp(n).createDocumentFragment());
    let r = o, i = [];
    return e.forEach((s) => {
      if (i.length || s.marks.length) {
        let a = 0, l = 0;
        for (; a < i.length && l < s.marks.length; ) {
          let c = s.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(i[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < i.length; )
          r = i.pop()[1];
        for (; l < s.marks.length; ) {
          let c = s.marks[l++], u = this.serializeMark(c, s.isInline, n);
          u && (i.push([c, r]), r.appendChild(u.dom), r = u.contentDOM || u.dom);
        }
      }
      r.appendChild(this.serializeNodeInner(s, n));
    }), o;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: o, contentDOM: r } = lu(sp(n), this.nodes[e.type.name](e), null, e.attrs);
    if (r) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, r);
    }
    return o;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let o = this.serializeNodeInner(e, n);
    for (let r = e.marks.length - 1; r >= 0; r--) {
      let i = this.serializeMark(e.marks[r], e.isInline, n);
      i && ((i.contentDOM || i.dom).appendChild(o), o = i.dom);
    }
    return o;
  }
  /**
  @internal
  */
  serializeMark(e, n, o = {}) {
    let r = this.marks[e.type.name];
    return r && lu(sp(o), r(e, n), null, e.attrs);
  }
  static renderSpec(e, n, o = null, r) {
    return lu(e, n, o, r);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Pr(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Qv(e.nodes);
    return n.text || (n.text = (o) => o.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Qv(e.marks);
  }
}
function Qv(t) {
  let e = {};
  for (let n in t) {
    let o = t[n].spec.toDOM;
    o && (e[n] = o);
  }
  return e;
}
function sp(t) {
  return t.document || window.document;
}
const e0 = /* @__PURE__ */ new WeakMap();
function O_(t) {
  let e = e0.get(t);
  return e === void 0 && e0.set(t, e = M_(t)), e;
}
function M_(t) {
  let e = null;
  function n(o) {
    if (o && typeof o == "object")
      if (Array.isArray(o))
        if (typeof o[0] == "string")
          e || (e = []), e.push(o);
        else
          for (let r = 0; r < o.length; r++)
            n(o[r]);
      else
        for (let r in o)
          n(o[r]);
  }
  return n(t), e;
}
function lu(t, e, n, o) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let r = e[0], i;
  if (typeof r != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (o && (i = O_(o)) && i.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = r.indexOf(" ");
  s > 0 && (n = r.slice(0, s), r = r.slice(s + 1));
  let a, l = n ? t.createElementNS(n, r) : t.createElement(r), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: m } = lu(t, f, n, o);
      if (l.appendChild(p), m) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = m;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const mx = 65535, gx = Math.pow(2, 16);
function I_(t, e) {
  return t + e * gx;
}
function t0(t) {
  return t & mx;
}
function R_(t) {
  return (t - (t & mx)) / gx;
}
const vx = 1, yx = 2, cu = 4, bx = 8;
class Ph {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.pos = e, this.delInfo = n, this.recover = o;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & bx) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (vx | cu)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (yx | cu)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & cu) > 0;
  }
}
class cn {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && cn.empty)
      return cn.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, o = t0(e);
    if (!this.inverted)
      for (let r = 0; r < o; r++)
        n += this.ranges[r * 3 + 2] - this.ranges[r * 3 + 1];
    return this.ranges[o * 3] + n + R_(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, o) {
    let r = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + i], u = this.ranges[a + s], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, p = l + r + (f < 0 ? 0 : u);
        if (o)
          return p;
        let m = e == (n < 0 ? l : d) ? null : I_(a / 3, e - l), g = e == l ? yx : e == d ? vx : cu;
        return (n < 0 ? e != l : e != d) && (g |= bx), new Ph(p, g, m);
      }
      r += u - c;
    }
    return o ? e + r : new Ph(e + r, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let o = 0, r = t0(n), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? o : 0);
      if (l > e)
        break;
      let c = this.ranges[a + i], u = l + c;
      if (e <= u && a == r * 3)
        return !0;
      o += this.ranges[a + s] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let r = 0, i = 0; r < this.ranges.length; r += 3) {
      let s = this.ranges[r], a = s - (this.inverted ? i : 0), l = s + (this.inverted ? 0 : i), c = this.ranges[r + n], u = this.ranges[r + o];
      e(a, a + c, l, l + u), i += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new cn(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? cn.empty : new cn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
cn.empty = new cn([]);
class rl {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, n, o = 0, r = e ? e.length : 0) {
    this.mirror = n, this.from = o, this.to = r, this._maps = e || [], this.ownData = !(e || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new rl(this._maps, this.mirror, e, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, o = this._maps.length; n < e._maps.length; n++) {
      let r = e.getMirror(n);
      this.appendMap(e._maps[n], r != null && r < n ? o + r : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, o = this._maps.length + e._maps.length; n >= 0; n--) {
      let r = e.getMirror(n);
      this.appendMap(e._maps[n].invert(), r != null && r > n ? o - r - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new rl();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let o = this.from; o < this.to; o++)
      e = this._maps[o].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, o) {
    let r = 0;
    for (let i = this.from; i < this.to; i++) {
      let s = this._maps[i], a = s.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(i);
        if (l != null && l > i && l < this.to) {
          i = l, e = this._maps[l].recover(a.recover);
          continue;
        }
      }
      r |= a.delInfo, e = a.pos;
    }
    return o ? e : new Ph(e, r, null);
  }
}
const ap = /* @__PURE__ */ Object.create(null);
class Bt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return cn.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let o = ap[n.stepType];
    if (!o)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return o.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in ap)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return ap[e] = n, n.prototype.jsonID = e, n;
  }
}
class ht {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new ht(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new ht(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, o, r) {
    try {
      return ht.ok(e.replace(n, o, r));
    } catch (i) {
      if (i instanceof Ru)
        return ht.fail(i.message);
      throw i;
    }
  }
}
function Eg(t, e, n) {
  let o = [];
  for (let r = 0; r < t.childCount; r++) {
    let i = t.child(r);
    i.content.size && (i = i.copy(Eg(i.content, e, i))), i.isInline && (i = e(i, n, r)), o.push(i);
  }
  return K.fromArray(o);
}
class hr extends Bt {
  /**
  Create a mark step.
  */
  constructor(e, n, o) {
    super(), this.from = e, this.to = n, this.mark = o;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), o = e.resolve(this.from), r = o.node(o.sharedDepth(this.to)), i = new te(Eg(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), r), n.openStart, n.openEnd);
    return ht.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new oo(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
    return n.deleted && o.deleted || n.pos >= o.pos ? null : new hr(n.pos, o.pos, this.mark);
  }
  merge(e) {
    return e instanceof hr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new hr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new hr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Bt.jsonID("addMark", hr);
class oo extends Bt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, o) {
    super(), this.from = e, this.to = n, this.mark = o;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), o = new te(Eg(n.content, (r) => r.mark(this.mark.removeFromSet(r.marks)), e), n.openStart, n.openEnd);
    return ht.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new hr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
    return n.deleted && o.deleted || n.pos >= o.pos ? null : new oo(n.pos, o.pos, this.mark);
  }
  merge(e) {
    return e instanceof oo && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new oo(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new oo(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Bt.jsonID("removeMark", oo);
class mr extends Bt {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return ht.fail("No node at mark step's position");
    let o = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return ht.fromReplace(e, this.pos, this.pos + 1, new te(K.from(o), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let o = this.mark.addToSet(n.marks);
      if (o.length == n.marks.length) {
        for (let r = 0; r < n.marks.length; r++)
          if (!n.marks[r].isInSet(o))
            return new mr(this.pos, n.marks[r]);
        return new mr(this.pos, this.mark);
      }
    }
    return new vs(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new mr(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new mr(n.pos, e.markFromJSON(n.mark));
  }
}
Bt.jsonID("addNodeMark", mr);
class vs extends Bt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return ht.fail("No node at mark step's position");
    let o = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return ht.fromReplace(e, this.pos, this.pos + 1, new te(K.from(o), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new mr(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new vs(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new vs(n.pos, e.markFromJSON(n.mark));
  }
}
Bt.jsonID("removeNodeMark", vs);
class bt extends Bt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, o, r = !1) {
    super(), this.from = e, this.to = n, this.slice = o, this.structure = r;
  }
  apply(e) {
    return this.structure && Lh(e, this.from, this.to) ? ht.fail("Structure replace would overwrite content") : ht.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new cn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new bt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
    return n.deletedAcross && o.deletedAcross ? null : new bt(n.pos, Math.max(n.pos, o.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof bt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? te.empty : new te(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new bt(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? te.empty : new te(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new bt(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new bt(n.from, n.to, te.fromJSON(e, n.slice), !!n.structure);
  }
}
Bt.jsonID("replace", bt);
class wt extends Bt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, o, r, i, s, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = o, this.gapTo = r, this.slice = i, this.insert = s, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Lh(e, this.from, this.gapFrom) || Lh(e, this.gapTo, this.to)))
      return ht.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return ht.fail("Gap is not a flat range");
    let o = this.slice.insertAt(this.insert, n.content);
    return o ? ht.fromReplace(e, this.from, this.to, o) : ht.fail("Content does not fit in gap");
  }
  getMap() {
    return new cn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new wt(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1), r = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), i = this.to == this.gapTo ? o.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && o.deletedAcross || r < n.pos || i > o.pos ? null : new wt(n.pos, o.pos, r, i, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new wt(n.from, n.to, n.gapFrom, n.gapTo, te.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Bt.jsonID("replaceAround", wt);
function Lh(t, e, n) {
  let o = t.resolve(e), r = n - e, i = o.depth;
  for (; r > 0 && i > 0 && o.indexAfter(i) == o.node(i).childCount; )
    i--, r--;
  if (r > 0) {
    let s = o.node(i).maybeChild(o.indexAfter(i));
    for (; r > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, r--;
    }
  }
  return !1;
}
function $_(t, e, n, o) {
  let r = [], i = [], s, a;
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!o.isInSet(d) && u.type.allowsMarkType(o.type)) {
      let f = Math.max(c, e), p = Math.min(c + l.nodeSize, n), m = o.addToSet(d);
      for (let g = 0; g < d.length; g++)
        d[g].isInSet(m) || (s && s.to == f && s.mark.eq(d[g]) ? s.to = p : r.push(s = new oo(f, p, d[g])));
      a && a.to == f ? a.to = p : i.push(a = new hr(f, p, o));
    }
  }), r.forEach((l) => t.step(l)), i.forEach((l) => t.step(l));
}
function P_(t, e, n, o) {
  let r = [], i = 0;
  t.doc.nodesBetween(e, n, (s, a) => {
    if (!s.isInline)
      return;
    i++;
    let l = null;
    if (o instanceof Yd) {
      let c = s.marks, u;
      for (; u = o.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else o ? o.isInSet(s.marks) && (l = [o]) : l = s.marks;
    if (l && l.length) {
      let c = Math.min(a + s.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let p = 0; p < r.length; p++) {
          let m = r[p];
          m.step == i - 1 && d.eq(r[p].style) && (f = m);
        }
        f ? (f.to = c, f.step = i) : r.push({ style: d, from: Math.max(a, e), to: c, step: i });
      }
    }
  }), r.forEach((s) => t.step(new oo(s.from, s.to, s.style)));
}
function _g(t, e, n, o = n.contentMatch, r = !0) {
  let i = t.doc.nodeAt(e), s = [], a = e + 1;
  for (let l = 0; l < i.childCount; l++) {
    let c = i.child(l), u = a + c.nodeSize, d = o.matchType(c.type);
    if (!d)
      s.push(new bt(a, u, te.empty));
    else {
      o = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new oo(a, u, c.marks[f]));
      if (r && c.isText && n.whitespace != "pre") {
        let f, p = /\r?\n|\r/g, m;
        for (; f = p.exec(c.text); )
          m || (m = new te(K.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), s.push(new bt(a + f.index, a + f.index + f[0].length, m));
      }
    }
    a = u;
  }
  if (!o.validEnd) {
    let l = o.fillBefore(K.empty, !0);
    t.replace(a, a, new te(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    t.step(s[l]);
}
function L_(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Fs(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let o = t.depth; ; --o) {
    let r = t.$from.node(o), i = t.$from.index(o), s = t.$to.indexAfter(o);
    if (o < t.depth && r.canReplace(i, s, n))
      return o;
    if (o == 0 || r.type.spec.isolating || !L_(r, i, s))
      break;
  }
  return null;
}
function D_(t, e, n) {
  let { $from: o, $to: r, depth: i } = e, s = o.before(i + 1), a = r.after(i + 1), l = s, c = a, u = K.empty, d = 0;
  for (let m = i, g = !1; m > n; m--)
    g || o.index(m) > 0 ? (g = !0, u = K.from(o.node(m).copy(u)), d++) : l--;
  let f = K.empty, p = 0;
  for (let m = i, g = !1; m > n; m--)
    g || r.after(m + 1) < r.end(m) ? (g = !0, f = K.from(r.node(m).copy(f)), p++) : c++;
  t.step(new wt(l, c, s, a, new te(u.append(f), d, p), u.size - d, !0));
}
function Ag(t, e, n = null, o = t) {
  let r = N_(t, e), i = r && B_(o, e);
  return i ? r.map(n0).concat({ type: e, attrs: n }).concat(i.map(n0)) : null;
}
function n0(t) {
  return { type: t, attrs: null };
}
function N_(t, e) {
  let { parent: n, startIndex: o, endIndex: r } = t, i = n.contentMatchAt(o).findWrapping(e);
  if (!i)
    return null;
  let s = i.length ? i[0] : e;
  return n.canReplaceWith(o, r, s) ? i : null;
}
function B_(t, e) {
  let { parent: n, startIndex: o, endIndex: r } = t, i = n.child(o), s = e.contentMatch.findWrapping(i.type);
  if (!s)
    return null;
  let l = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let c = o; l && c < r; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : s;
}
function F_(t, e, n) {
  let o = K.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (o.size) {
      let a = n[s].type.contentMatch.matchFragment(o);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    o = K.from(n[s].type.create(n[s].attrs, o));
  }
  let r = e.start, i = e.end;
  t.step(new wt(r, i, r, i, new te(o, 0, 0), n.length, !0));
}
function z_(t, e, n, o, r) {
  if (!o.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let i = t.steps.length;
  t.doc.nodesBetween(e, n, (s, a) => {
    let l = typeof r == "function" ? r(s) : r;
    if (s.isTextblock && !s.hasMarkup(o, l) && H_(t.doc, t.mapping.slice(i).map(a), o)) {
      let c = null;
      if (o.schema.linebreakReplacement) {
        let p = o.whitespace == "pre", m = !!o.contentMatch.matchType(o.schema.linebreakReplacement);
        p && !m ? c = !1 : !p && m && (c = !0);
      }
      c === !1 && xx(t, s, a, i), _g(t, t.mapping.slice(i).map(a, 1), o, void 0, c === null);
      let u = t.mapping.slice(i), d = u.map(a, 1), f = u.map(a + s.nodeSize, 1);
      return t.step(new wt(d, f, d + 1, f - 1, new te(K.from(o.create(l, null, s.marks)), 0, 0), 1, !0)), c === !0 && wx(t, s, a, i), !1;
    }
  });
}
function wx(t, e, n, o) {
  e.forEach((r, i) => {
    if (r.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(r.text); ) {
        let l = t.mapping.slice(o).map(n + 1 + i + s.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function xx(t, e, n, o) {
  e.forEach((r, i) => {
    if (r.type == r.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(o).map(n + 1 + i);
      t.replaceWith(s, s + 1, e.type.schema.text(`
`));
    }
  });
}
function H_(t, e, n) {
  let o = t.resolve(e), r = o.index();
  return o.parent.canReplaceWith(r, r + 1, n);
}
function V_(t, e, n, o, r) {
  let i = t.doc.nodeAt(e);
  if (!i)
    throw new RangeError("No node at given position");
  n || (n = i.type);
  let s = n.create(o, null, r || i.marks);
  if (i.isLeaf)
    return t.replaceWith(e, e + i.nodeSize, s);
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new wt(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new te(K.from(s), 0, 0), 1, !0));
}
function Bo(t, e, n = 1, o) {
  let r = t.resolve(e), i = r.depth - n, s = o && o[o.length - 1] || r.parent;
  if (i < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !s.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount)))
    return !1;
  for (let c = r.depth - 1, u = n - 2; c > i; c--, u--) {
    let d = r.node(c), f = r.index(c);
    if (d.type.spec.isolating)
      return !1;
    let p = d.content.cutByIndex(f, d.childCount), m = o && o[u + 1];
    m && (p = p.replaceChild(0, m.type.create(m.attrs)));
    let g = o && o[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !g.type.validContent(p))
      return !1;
  }
  let a = r.indexAfter(i), l = o && o[0];
  return r.node(i).canReplaceWith(a, a, l ? l.type : r.node(i + 1).type);
}
function U_(t, e, n = 1, o) {
  let r = t.doc.resolve(e), i = K.empty, s = K.empty;
  for (let a = r.depth, l = r.depth - n, c = n - 1; a > l; a--, c--) {
    i = K.from(r.node(a).copy(i));
    let u = o && o[c];
    s = K.from(u ? u.type.create(u.attrs, s) : r.node(a).copy(s));
  }
  t.step(new bt(e, e, new te(i.append(s), n, n), !0));
}
function Lr(t, e) {
  let n = t.resolve(e), o = n.index();
  return Cx(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(o, o + 1);
}
function j_(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: o } = t.type.schema;
  for (let r = 0; r < e.childCount; r++) {
    let i = e.child(r), s = i.type == o ? t.type.schema.nodes.text : i.type;
    if (n = n.matchType(s), !n || !t.type.allowsMarks(i.marks))
      return !1;
  }
  return n.validEnd;
}
function Cx(t, e) {
  return !!(t && e && !t.isLeaf && j_(t, e));
}
function Jd(t, e, n = -1) {
  let o = t.resolve(e);
  for (let r = o.depth; ; r--) {
    let i, s, a = o.index(r);
    if (r == o.depth ? (i = o.nodeBefore, s = o.nodeAfter) : n > 0 ? (i = o.node(r + 1), a++, s = o.node(r).maybeChild(a)) : (i = o.node(r).maybeChild(a - 1), s = o.node(r + 1)), i && !i.isTextblock && Cx(i, s) && o.node(r).canReplace(a, a + 1))
      return e;
    if (r == 0)
      break;
    e = n < 0 ? o.before(r) : o.after(r);
  }
}
function W_(t, e, n) {
  let o = null, { linebreakReplacement: r } = t.doc.type.schema, i = t.doc.resolve(e - n), s = i.node().type;
  if (r && s.inlineContent) {
    let u = s.whitespace == "pre", d = !!s.contentMatch.matchType(r);
    u && !d ? o = !1 : !u && d && (o = !0);
  }
  let a = t.steps.length;
  if (o === !1) {
    let u = t.doc.resolve(e + n);
    xx(t, u.node(), u.before(), a);
  }
  s.inlineContent && _g(t, e + n - 1, s, i.node().contentMatchAt(i.index()), o == null);
  let l = t.mapping.slice(a), c = l.map(e - n);
  if (t.step(new bt(c, l.map(e + n, -1), te.empty, !0)), o === !0) {
    let u = t.doc.resolve(c);
    wx(t, u.node(), u.before(), t.steps.length);
  }
  return t;
}
function K_(t, e, n) {
  let o = t.resolve(e);
  if (o.parent.canReplaceWith(o.index(), o.index(), n))
    return e;
  if (o.parentOffset == 0)
    for (let r = o.depth - 1; r >= 0; r--) {
      let i = o.index(r);
      if (o.node(r).canReplaceWith(i, i, n))
        return o.before(r + 1);
      if (i > 0)
        return null;
    }
  if (o.parentOffset == o.parent.content.size)
    for (let r = o.depth - 1; r >= 0; r--) {
      let i = o.indexAfter(r);
      if (o.node(r).canReplaceWith(i, i, n))
        return o.after(r + 1);
      if (i < o.node(r).childCount)
        return null;
    }
  return null;
}
function Sx(t, e, n) {
  let o = t.resolve(e);
  if (!n.content.size)
    return e;
  let r = n.content;
  for (let i = 0; i < n.openStart; i++)
    r = r.firstChild.content;
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let s = o.depth; s >= 0; s--) {
      let a = s == o.depth ? 0 : o.pos <= (o.start(s + 1) + o.end(s + 1)) / 2 ? -1 : 1, l = o.index(s) + (a > 0 ? 1 : 0), c = o.node(s), u = !1;
      if (i == 1)
        u = c.canReplace(l, l, r);
      else {
        let d = c.contentMatchAt(l).findWrapping(r.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? o.pos : a < 0 ? o.before(s + 1) : o.after(s + 1);
    }
  return null;
}
function Xd(t, e, n = e, o = te.empty) {
  if (e == n && !o.size)
    return null;
  let r = t.resolve(e), i = t.resolve(n);
  return kx(r, i, o) ? new bt(e, n, o) : new G_(r, i, o).fit();
}
function kx(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class G_ {
  constructor(e, n, o) {
    this.$from = e, this.$to = n, this.unplaced = o, this.frontier = [], this.placed = K.empty;
    for (let r = 0; r <= e.depth; r++) {
      let i = e.node(r);
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(e.indexAfter(r))
      });
    }
    for (let r = e.depth; r > 0; r--)
      this.placed = K.from(e.node(r).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, o = this.$from, r = this.close(e < 0 ? this.$to : o.doc.resolve(e));
    if (!r)
      return null;
    let i = this.placed, s = o.depth, a = r.depth;
    for (; s && a && i.childCount == 1; )
      i = i.firstChild.content, s--, a--;
    let l = new te(i, s, a);
    return e > -1 ? new wt(o.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || o.pos != this.$to.pos ? new bt(o.pos, r.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, o = 0, r = this.unplaced.openEnd; o < e; o++) {
      let i = n.firstChild;
      if (n.childCount > 1 && (r = 0), i.type.spec.isolating && r <= o) {
        e = o;
        break;
      }
      n = i.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let o = n == 1 ? e : this.unplaced.openStart; o >= 0; o--) {
        let r, i = null;
        o ? (i = lp(this.unplaced.content, o - 1).firstChild, r = i.content) : r = this.unplaced.content;
        let s = r.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (n == 1 && (s ? c.matchType(s.type) || (d = c.fillBefore(K.from(s), !1)) : i && l.compatibleContent(i.type)))
            return { sliceDepth: o, frontierDepth: a, parent: i, inject: d };
          if (n == 2 && s && (u = c.findWrapping(s.type)))
            return { sliceDepth: o, frontierDepth: a, parent: i, wrap: u };
          if (i && c.matchType(i.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: o } = this.unplaced, r = lp(e, n);
    return !r.childCount || r.firstChild.isLeaf ? !1 : (this.unplaced = new te(e, n + 1, Math.max(o, r.size + n >= e.size - o ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: o } = this.unplaced, r = lp(e, n);
    if (r.childCount <= 1 && n > 0) {
      let i = e.size - n <= n + r.size;
      this.unplaced = new te(Aa(e, n - 1, 1), n - 1, i ? n - 1 : o);
    } else
      this.unplaced = new te(Aa(e, n, 1), n, o);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: o, inject: r, wrap: i }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (i)
      for (let g = 0; g < i.length; g++)
        this.openFrontierNode(i[g]);
    let s = this.unplaced, a = o ? o.content : s.content, l = s.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (r) {
      for (let g = 0; g < r.childCount; g++)
        u.push(r.child(g));
      d = d.matchFragment(r);
    }
    let p = a.size + e - (s.content.size - s.openEnd);
    for (; c < a.childCount; ) {
      let g = a.child(c), v = d.matchType(g.type);
      if (!v)
        break;
      c++, (c > 1 || l == 0 || g.content.size) && (d = v, u.push(Ex(g.mark(f.allowedMarks(g.marks)), c == 1 ? l : 0, c == a.childCount ? p : -1)));
    }
    let m = c == a.childCount;
    m || (p = -1), this.placed = Ta(this.placed, n, K.from(u)), this.frontier[n].match = d, m && p < 0 && o && o.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, v = a; g < p; g++) {
      let y = v.lastChild;
      this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), v = y.content;
    }
    this.unplaced = m ? e == 0 ? te.empty : new te(Aa(s.content, e - 1, 1), e - 1, p < 0 ? s.openEnd : e - 1) : new te(Aa(s.content, e, c), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !cp(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: o } = this.$to, r = this.$to.after(o);
    for (; o > 1 && r == this.$to.end(--o); )
      ++r;
    return r;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: o, type: r } = this.frontier[n], i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = cp(e, n, r, o, i);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], u = cp(e, a, c, l, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: i ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Ta(this.placed, n.depth, n.fit)), e = n.move;
    for (let o = n.depth + 1; o <= e.depth; o++) {
      let r = e.node(o), i = r.type.contentMatch.fillBefore(r.content, !0, e.index(o));
      this.openFrontierNode(r.type, r.attrs, i);
    }
    return e;
  }
  openFrontierNode(e, n = null, o) {
    let r = this.frontier[this.depth];
    r.match = r.match.matchType(e), this.placed = Ta(this.placed, this.depth, K.from(e.create(n, o))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(K.empty, !0);
    n.childCount && (this.placed = Ta(this.placed, this.frontier.length, n));
  }
}
function Aa(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Aa(t.firstChild.content, e - 1, n)));
}
function Ta(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Ta(t.lastChild.content, e - 1, n)));
}
function lp(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function Ex(t, e, n) {
  if (e <= 0)
    return t;
  let o = t.content;
  return e > 1 && (o = o.replaceChild(0, Ex(o.firstChild, e - 1, o.childCount == 1 ? n - 1 : 0))), e > 0 && (o = t.type.contentMatch.fillBefore(o).append(o), n <= 0 && (o = o.append(t.type.contentMatch.matchFragment(o).fillBefore(K.empty, !0)))), t.copy(o);
}
function cp(t, e, n, o, r) {
  let i = t.node(e), s = r ? t.indexAfter(e) : t.index(e);
  if (s == i.childCount && !n.compatibleContent(i.type))
    return null;
  let a = o.fillBefore(i.content, !0, s);
  return a && !q_(n, i.content, s) ? a : null;
}
function q_(t, e, n) {
  for (let o = n; o < e.childCount; o++)
    if (!t.allowsMarks(e.child(o).marks))
      return !0;
  return !1;
}
function Y_(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function J_(t, e, n, o) {
  if (!o.size)
    return t.deleteRange(e, n);
  let r = t.doc.resolve(e), i = t.doc.resolve(n);
  if (kx(r, i, o))
    return t.step(new bt(e, n, o));
  let s = Ax(r, t.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let a = -(r.depth + 1);
  s.unshift(a);
  for (let f = r.depth, p = r.pos - 1; f > 0; f--, p--) {
    let m = r.node(f).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    s.indexOf(f) > -1 ? a = f : r.before(f) == p && s.splice(1, 0, -f);
  }
  let l = s.indexOf(a), c = [], u = o.openStart;
  for (let f = o.content, p = 0; ; p++) {
    let m = f.firstChild;
    if (c.push(m), p == o.openStart)
      break;
    f = m.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let p = c[f], m = Y_(p.type);
    if (m && !p.sameMarkup(r.node(Math.abs(a) - 1)))
      u = f;
    else if (m || !p.type.isTextblock)
      break;
  }
  for (let f = o.openStart; f >= 0; f--) {
    let p = (f + u + 1) % (o.openStart + 1), m = c[p];
    if (m)
      for (let g = 0; g < s.length; g++) {
        let v = s[(g + l) % s.length], y = !0;
        v < 0 && (y = !1, v = -v);
        let w = r.node(v - 1), x = r.index(v - 1);
        if (w.canReplaceWith(x, x, m.type, m.marks))
          return t.replace(r.before(v), y ? i.after(v) : n, new te(_x(o.content, 0, o.openStart, p), p, o.openEnd));
      }
  }
  let d = t.steps.length;
  for (let f = s.length - 1; f >= 0 && (t.replace(e, n, o), !(t.steps.length > d)); f--) {
    let p = s[f];
    p < 0 || (e = r.before(p), n = i.after(p));
  }
}
function _x(t, e, n, o, r) {
  if (e < n) {
    let i = t.firstChild;
    t = t.replaceChild(0, i.copy(_x(i.content, e + 1, n, o, i)));
  }
  if (e > o) {
    let i = r.contentMatchAt(0), s = i.fillBefore(t).append(t);
    t = s.append(i.matchFragment(s).fillBefore(K.empty, !0));
  }
  return t;
}
function X_(t, e, n, o) {
  if (!o.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let r = K_(t.doc, e, o.type);
    r != null && (e = n = r);
  }
  t.replaceRange(e, n, new te(K.from(o), 0, 0));
}
function Z_(t, e, n) {
  let o = t.doc.resolve(e), r = t.doc.resolve(n), i = Ax(o, r);
  for (let s = 0; s < i.length; s++) {
    let a = i[s], l = s == i.length - 1;
    if (l && a == 0 || o.node(a).type.contentMatch.validEnd)
      return t.delete(o.start(a), r.end(a));
    if (a > 0 && (l || o.node(a - 1).canReplace(o.index(a - 1), r.indexAfter(a - 1))))
      return t.delete(o.before(a), r.after(a));
  }
  for (let s = 1; s <= o.depth && s <= r.depth; s++)
    if (e - o.start(s) == o.depth - s && n > o.end(s) && r.end(s) - n != r.depth - s && o.start(s - 1) == r.start(s - 1) && o.node(s - 1).canReplace(o.index(s - 1), r.index(s - 1)))
      return t.delete(o.before(s), n);
  t.delete(e, n);
}
function Ax(t, e) {
  let n = [], o = Math.min(t.depth, e.depth);
  for (let r = o; r >= 0; r--) {
    let i = t.start(r);
    if (i < t.pos - (t.depth - r) || e.end(r) > e.pos + (e.depth - r) || t.node(r).type.spec.isolating || e.node(r).type.spec.isolating)
      break;
    (i == e.start(r) || r == t.depth && r == e.depth && t.parent.inlineContent && e.parent.inlineContent && r && e.start(r - 1) == i - 1) && n.push(r);
  }
  return n;
}
class ds extends Bt {
  /**
  Construct an attribute step.
  */
  constructor(e, n, o) {
    super(), this.pos = e, this.attr = n, this.value = o;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return ht.fail("No node at attribute step's position");
    let o = /* @__PURE__ */ Object.create(null);
    for (let i in n.attrs)
      o[i] = n.attrs[i];
    o[this.attr] = this.value;
    let r = n.type.create(o, null, n.marks);
    return ht.fromReplace(e, this.pos, this.pos + 1, new te(K.from(r), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return cn.empty;
  }
  invert(e) {
    return new ds(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ds(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new ds(n.pos, n.attr, n.value);
  }
}
Bt.jsonID("attr", ds);
class il extends Bt {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e.attrs)
      n[r] = e.attrs[r];
    n[this.attr] = this.value;
    let o = e.type.create(n, e.content, e.marks);
    return ht.ok(o);
  }
  getMap() {
    return cn.empty;
  }
  invert(e) {
    return new il(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new il(n.attr, n.value);
  }
}
Bt.jsonID("docAttr", il);
let ys = class extends Error {
};
ys = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
ys.prototype = Object.create(Error.prototype);
ys.prototype.constructor = ys;
ys.prototype.name = "TransformError";
class Tg {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new rl();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new ys(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, o = te.empty) {
    let r = Xd(this.doc, e, n, o);
    return r && this.step(r), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, o) {
    return this.replace(e, n, new te(K.from(o), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, te.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, o) {
    return J_(this, e, n, o), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, o) {
    return X_(this, e, n, o), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return Z_(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return D_(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return W_(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return F_(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, o, r = null) {
    return z_(this, e, n, o, r), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, o = null, r) {
    return V_(this, e, n, o, r), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, o) {
    return this.step(new ds(e, n, o)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new il(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new mr(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Je)) {
      let o = this.doc.nodeAt(e);
      if (!o)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(o.marks), !n)
        return this;
    }
    return this.step(new vs(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, n = 1, o) {
    return U_(this, e, n, o), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, o) {
    return $_(this, e, n, o), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, o) {
    return P_(this, e, n, o), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, o) {
    return _g(this, e, n, o), this;
  }
}
const up = /* @__PURE__ */ Object.create(null);
let fe = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, o) {
    this.$anchor = e, this.$head = n, this.ranges = o || [new Og(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = te.empty) {
    let o = n.content.lastChild, r = null;
    for (let a = 0; a < n.openEnd; a++)
      r = o, o = o.lastChild;
    let i = e.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: c } = s[a], u = e.mapping.slice(i);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? te.empty : n), a == 0 && i0(e, i, (o ? o.isInline : r && r.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let o = e.steps.length, r = this.ranges;
    for (let i = 0; i < r.length; i++) {
      let { $from: s, $to: a } = r[i], l = e.mapping.slice(o), c = l.map(s.pos), u = l.map(a.pos);
      i ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), i0(e, o, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, o = !1) {
    let r = e.parent.inlineContent ? new ce(e) : Xi(e.node(0), e.parent, e.pos, e.index(), n, o);
    if (r)
      return r;
    for (let i = e.depth - 1; i >= 0; i--) {
      let s = n < 0 ? Xi(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, o) : Xi(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, o);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Wt(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Xi(e, e, 0, 0, 1) || new Wt(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Xi(e, e, e.content.size, e.childCount, -1) || new Wt(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let o = up[n.type];
    if (!o)
      throw new RangeError(`No selection type ${n.type} defined`);
    return o.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in up)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return up[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ce.between(this.$anchor, this.$head).getBookmark();
  }
};
fe.prototype.visible = !0;
class Og {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let o0 = !1;
function r0(t) {
  !o0 && !t.parent.inlineContent && (o0 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ce extends fe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    r0(e), r0(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let o = e.resolve(n.map(this.head));
    if (!o.parent.inlineContent)
      return fe.near(o);
    let r = e.resolve(n.map(this.anchor));
    return new ce(r.parent.inlineContent ? r : o, o);
  }
  replace(e, n = te.empty) {
    if (super.replace(e, n), n == te.empty) {
      let o = this.$from.marksAcross(this.$to);
      o && e.ensureMarks(o);
    }
  }
  eq(e) {
    return e instanceof ce && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Zd(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ce(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, o = n) {
    let r = e.resolve(n);
    return new this(r, o == n ? r : e.resolve(o));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, o) {
    let r = e.pos - n.pos;
    if ((!o || r) && (o = r >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let i = fe.findFrom(n, o, !0) || fe.findFrom(n, -o, !0);
      if (i)
        n = i.$head;
      else
        return fe.near(n, o);
    }
    return e.parent.inlineContent || (r == 0 ? e = n : (e = (fe.findFrom(e, -o, !0) || fe.findFrom(e, o, !0)).$anchor, e.pos < n.pos != r < 0 && (e = n))), new ce(e, n);
  }
}
fe.jsonID("text", ce);
class Zd {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new Zd(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ce.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class de extends fe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, o = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, o), this.node = n;
  }
  map(e, n) {
    let { deleted: o, pos: r } = n.mapResult(this.anchor), i = e.resolve(r);
    return o ? fe.near(i) : new de(i);
  }
  content() {
    return new te(K.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof de && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Mg(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new de(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new de(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
de.prototype.visible = !1;
fe.jsonID("node", de);
class Mg {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: o } = e.mapResult(this.anchor);
    return n ? new Zd(o, o) : new Mg(o);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), o = n.nodeAfter;
    return o && de.isSelectable(o) ? new de(n) : fe.near(n);
  }
}
class Wt extends fe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = te.empty) {
    if (n == te.empty) {
      e.delete(0, e.doc.content.size);
      let o = fe.atStart(e.doc);
      o.eq(e.selection) || e.setSelection(o);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Wt(e);
  }
  map(e) {
    return new Wt(e);
  }
  eq(e) {
    return e instanceof Wt;
  }
  getBookmark() {
    return Q_;
  }
}
fe.jsonID("all", Wt);
const Q_ = {
  map() {
    return this;
  },
  resolve(t) {
    return new Wt(t);
  }
};
function Xi(t, e, n, o, r, i = !1) {
  if (e.inlineContent)
    return ce.create(t, n);
  for (let s = o - (r > 0 ? 0 : 1); r > 0 ? s < e.childCount : s >= 0; s += r) {
    let a = e.child(s);
    if (a.isAtom) {
      if (!i && de.isSelectable(a))
        return de.create(t, n - (r < 0 ? a.nodeSize : 0));
    } else {
      let l = Xi(t, a, n + r, r < 0 ? a.childCount : 0, r, i);
      if (l)
        return l;
    }
    n += a.nodeSize * r;
  }
  return null;
}
function i0(t, e, n) {
  let o = t.steps.length - 1;
  if (o < e)
    return;
  let r = t.steps[o];
  if (!(r instanceof bt || r instanceof wt))
    return;
  let i = t.mapping.maps[o], s;
  i.forEach((a, l, c, u) => {
    s == null && (s = u);
  }), t.setSelection(fe.near(t.doc.resolve(s), n));
}
const s0 = 1, a0 = 2, l0 = 4;
let eA = class extends Tg {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | s0) & -3, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & s0) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= a0, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Je.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & a0) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & -3, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let o = this.selection;
    return n && (e = e.mark(this.storedMarks || (o.empty ? o.$from.marks() : o.$from.marksAcross(o.$to) || Je.none))), o.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, o) {
    let r = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection();
    {
      if (o == null && (o = n), o = o ?? n, !e)
        return this.deleteRange(n, o);
      let i = this.storedMarks;
      if (!i) {
        let s = this.doc.resolve(n);
        i = o == n ? s.marks() : s.marksAcross(this.doc.resolve(o));
      }
      return this.replaceRangeWith(n, o, r.text(e, i)), this.selection.empty || this.setSelection(fe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= l0, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & l0) > 0;
  }
};
function c0(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Oa {
  constructor(e, n, o) {
    this.name = e, this.init = c0(n.init, o), this.apply = c0(n.apply, o);
  }
}
const tA = [
  new Oa("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Oa("selection", {
    init(t, e) {
      return t.selection || fe.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Oa("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, o) {
      return o.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Oa("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class dp {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = tA.slice(), n && n.forEach((o) => {
      if (this.pluginsByKey[o.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + o.key + ")");
      this.plugins.push(o), this.pluginsByKey[o.key] = o, o.spec.state && this.fields.push(new Oa(o.key, o.spec.state, o));
    });
  }
}
class is {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let o = 0; o < this.config.plugins.length; o++)
      if (o != n) {
        let r = this.config.plugins[o];
        if (r.spec.filterTransaction && !r.spec.filterTransaction.call(r, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], o = this.applyInner(e), r = null;
    for (; ; ) {
      let i = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = r ? r[s].n : 0, c = r ? r[s].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, o);
          if (u && o.filterTransaction(u, s)) {
            if (u.setMeta("appendedTransaction", e), !r) {
              r = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                r.push(d < s ? { state: o, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), o = o.applyInner(u), i = !0;
          }
          r && (r[s] = { state: o, n: n.length });
        }
      }
      if (!i)
        return { state: o, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new is(this.config), o = this.config.fields;
    for (let r = 0; r < o.length; r++) {
      let i = o[r];
      n[i.name] = i.apply(e, this[i.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new eA(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new dp(e.doc ? e.doc.type.schema : e.schema, e.plugins), o = new is(n);
    for (let r = 0; r < n.fields.length; r++)
      o[n.fields[r].name] = n.fields[r].init(e, o);
    return o;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new dp(this.schema, e.plugins), o = n.fields, r = new is(n);
    for (let i = 0; i < o.length; i++) {
      let s = o[i].name;
      r[s] = this.hasOwnProperty(s) ? this[s] : o[i].init(e, r);
    }
    return r;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((o) => o.toJSON())), e && typeof e == "object")
      for (let o in e) {
        if (o == "doc" || o == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let r = e[o], i = r.spec.state;
        i && i.toJSON && (n[o] = i.toJSON.call(r, this[r.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, o) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let r = new dp(e.schema, e.plugins), i = new is(r);
    return r.fields.forEach((s) => {
      if (s.name == "doc")
        i.doc = yr.fromJSON(e.schema, n.doc);
      else if (s.name == "selection")
        i.selection = fe.fromJSON(i.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (o)
          for (let a in o) {
            let l = o[a], c = l.spec.state;
            if (l.key == s.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              i[s.name] = c.fromJSON.call(l, e, n[a], i);
              return;
            }
          }
        i[s.name] = s.init(e, i);
      }
    }), i;
  }
}
function Tx(t, e, n) {
  for (let o in t) {
    let r = t[o];
    r instanceof Function ? r = r.bind(e) : o == "handleDOMEvents" && (r = Tx(r, e, {})), n[o] = r;
  }
  return n;
}
class De {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Tx(e.props, this, this.props), this.key = e.key ? e.key.key : Ox("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const fp = /* @__PURE__ */ Object.create(null);
function Ox(t) {
  return t in fp ? t + "$" + ++fp[t] : (fp[t] = 0, t + "$");
}
class Ne {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = Ox(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const At = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, bs = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Dh = null;
const To = function(t, e, n) {
  let o = Dh || (Dh = document.createRange());
  return o.setEnd(t, n ?? t.nodeValue.length), o.setStart(t, e || 0), o;
}, nA = function() {
  Dh = null;
}, wi = function(t, e, n, o) {
  return n && (u0(t, e, n, o, -1) || u0(t, e, n, o, 1));
}, oA = /^(img|br|input|textarea|hr)$/i;
function u0(t, e, n, o, r) {
  for (; ; ) {
    if (t == n && e == o)
      return !0;
    if (e == (r < 0 ? 0 : kn(t))) {
      let i = t.parentNode;
      if (!i || i.nodeType != 1 || Nl(t) || oA.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = At(t) + (r < 0 ? 0 : 1), t = i;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = r < 0 ? kn(t) : 0;
    } else
      return !1;
  }
}
function kn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function rA(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = kn(t);
    } else if (t.parentNode && !Nl(t))
      e = At(t), t = t.parentNode;
    else
      return null;
  }
}
function iA(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !Nl(t))
      e = At(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function sA(t, e, n) {
  for (let o = e == 0, r = e == kn(t); o || r; ) {
    if (t == n)
      return !0;
    let i = At(t);
    if (t = t.parentNode, !t)
      return !1;
    o = o && i == 0, r = r && i == kn(t);
  }
}
function Nl(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Qd = function(t) {
  return t.focusNode && wi(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function ri(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function aA(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function lA(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let o = t.caretPositionFromPoint(e, n);
      if (o)
        return { node: o.offsetNode, offset: Math.min(kn(o.offsetNode), o.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let o = t.caretRangeFromPoint(e, n);
    if (o)
      return { node: o.startContainer, offset: Math.min(kn(o.startContainer), o.startOffset) };
  }
}
const co = typeof navigator < "u" ? navigator : null, d0 = typeof document < "u" ? document : null, Dr = co && co.userAgent || "", Nh = /Edge\/(\d+)/.exec(Dr), Mx = /MSIE \d/.exec(Dr), Bh = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Dr), en = !!(Mx || Bh || Nh), br = Mx ? document.documentMode : Bh ? +Bh[1] : Nh ? +Nh[1] : 0, Wn = !en && /gecko\/(\d+)/i.test(Dr);
Wn && +(/Firefox\/(\d+)/.exec(Dr) || [0, 0])[1];
const Fh = !en && /Chrome\/(\d+)/.exec(Dr), Pt = !!Fh, Ix = Fh ? +Fh[1] : 0, Kt = !en && !!co && /Apple Computer/.test(co.vendor), ws = Kt && (/Mobile\/\w+/.test(Dr) || !!co && co.maxTouchPoints > 2), Sn = ws || (co ? /Mac/.test(co.platform) : !1), cA = co ? /Win/.test(co.platform) : !1, $o = /Android \d/.test(Dr), Bl = !!d0 && "webkitFontSmoothing" in d0.documentElement.style, uA = Bl ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function dA(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function xo(t, e) {
  return typeof t == "number" ? t : t[e];
}
function fA(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, o = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * o
  };
}
function f0(t, e, n) {
  let o = t.someProp("scrollThreshold") || 0, r = t.someProp("scrollMargin") || 5, i = t.dom.ownerDocument;
  for (let s = n || t.dom; s; ) {
    if (s.nodeType != 1) {
      s = bs(s);
      continue;
    }
    let a = s, l = a == i.body, c = l ? dA(i) : fA(a), u = 0, d = 0;
    if (e.top < c.top + xo(o, "top") ? d = -(c.top - e.top + xo(r, "top")) : e.bottom > c.bottom - xo(o, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + xo(r, "top") - c.top : e.bottom - c.bottom + xo(r, "bottom")), e.left < c.left + xo(o, "left") ? u = -(c.left - e.left + xo(r, "left")) : e.right > c.right - xo(o, "right") && (u = e.right - c.right + xo(r, "right")), u || d)
      if (l)
        i.defaultView.scrollBy(u, d);
      else {
        let p = a.scrollLeft, m = a.scrollTop;
        d && (a.scrollTop += d), u && (a.scrollLeft += u);
        let g = a.scrollLeft - p, v = a.scrollTop - m;
        e = { left: e.left - g, top: e.top - v, right: e.right - g, bottom: e.bottom - v };
      }
    let f = l ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    s = f == "absolute" ? s.offsetParent : bs(s);
  }
}
function pA(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), o, r;
  for (let i = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
    let a = t.root.elementFromPoint(i, s);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      o = a, r = l.top;
      break;
    }
  }
  return { refDOM: o, refTop: r, stack: Rx(t.dom) };
}
function Rx(t) {
  let e = [], n = t.ownerDocument;
  for (let o = t; o && (e.push({ dom: o, top: o.scrollTop, left: o.scrollLeft }), t != n); o = bs(o))
    ;
  return e;
}
function hA({ refDOM: t, refTop: e, stack: n }) {
  let o = t ? t.getBoundingClientRect().top : 0;
  $x(n, o == 0 ? 0 : o - e);
}
function $x(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: o, top: r, left: i } = t[n];
    o.scrollTop != r + e && (o.scrollTop = r + e), o.scrollLeft != i && (o.scrollLeft = i);
  }
}
let Ui = null;
function mA(t) {
  if (t.setActive)
    return t.setActive();
  if (Ui)
    return t.focus(Ui);
  let e = Rx(t);
  t.focus(Ui == null ? {
    get preventScroll() {
      return Ui = { preventScroll: !0 }, !0;
    }
  } : void 0), Ui || (Ui = !1, $x(e, 0));
}
function Px(t, e) {
  let n, o = 2e8, r, i = 0, s = e.top, a = e.top, l, c;
  for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = To(u).getClientRects();
    else
      continue;
    for (let p = 0; p < f.length; p++) {
      let m = f[p];
      if (m.top <= s && m.bottom >= a) {
        s = Math.max(m.bottom, s), a = Math.min(m.top, a);
        let g = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (g < o) {
          n = u, o = g, r = g && n.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, u.nodeType == 1 && g && (i = d + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      } else m.top > e.top && !l && m.left <= e.left && m.right >= e.left && (l = u, c = { left: Math.max(m.left, Math.min(m.right, e.left)), top: m.top });
      !n && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (i = d + 1);
    }
  }
  return !n && l && (n = l, r = c, o = 0), n && n.nodeType == 3 ? gA(n, r) : !n || o && n.nodeType == 1 ? { node: t, offset: i } : Px(n, r);
}
function gA(t, e) {
  let n = t.nodeValue.length, o = document.createRange();
  for (let r = 0; r < n; r++) {
    o.setEnd(t, r + 1), o.setStart(t, r);
    let i = rr(o, 1);
    if (i.top != i.bottom && Ig(e, i))
      return { node: t, offset: r + (e.left >= (i.left + i.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function Ig(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function vA(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function yA(t, e, n) {
  let { node: o, offset: r } = Px(e, n), i = -1;
  if (o.nodeType == 1 && !o.firstChild) {
    let s = o.getBoundingClientRect();
    i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(o, r, i);
}
function bA(t, e, n, o) {
  let r = -1;
  for (let i = e, s = !1; i != t.dom; ) {
    let a = t.docView.nearestDesc(i, !0), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!s && l.left > o.left || l.top > o.top ? r = a.posBefore : (!s && l.right < o.left || l.bottom < o.top) && (r = a.posAfter), s = !0), !a.contentDOM && r < 0 && !a.node.isText))
      return (a.node.isBlock ? o.top < (l.top + l.bottom) / 2 : o.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    i = a.dom.parentNode;
  }
  return r > -1 ? r : t.docView.posFromDOM(e, n, -1);
}
function Lx(t, e, n) {
  let o = t.childNodes.length;
  if (o && n.top < n.bottom)
    for (let r = Math.max(0, Math.min(o - 1, Math.floor(o * (e.top - n.top) / (n.bottom - n.top)) - 2)), i = r; ; ) {
      let s = t.childNodes[i];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (Ig(e, c))
            return Lx(s, e, c);
        }
      }
      if ((i = (i + 1) % o) == r)
        break;
    }
  return t;
}
function wA(t, e) {
  let n = t.dom.ownerDocument, o, r = 0, i = lA(n, e.left, e.top);
  i && ({ node: o, offset: r } = i);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let c = t.dom.getBoundingClientRect();
    if (!Ig(e, c) || (s = Lx(t.dom, e, c), !s))
      return null;
  }
  if (Kt)
    for (let c = s; o && c; c = bs(c))
      c.draggable && (o = void 0);
  if (s = vA(s, e), o) {
    if (Wn && o.nodeType == 1 && (r = Math.min(r, o.childNodes.length), r < o.childNodes.length)) {
      let u = o.childNodes[r], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && r++;
    }
    let c;
    Bl && r && o.nodeType == 1 && (c = o.childNodes[r - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && r--, o == t.dom && r == o.childNodes.length - 1 && o.lastChild.nodeType == 1 && e.top > o.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (r == 0 || o.nodeType != 1 || o.childNodes[r - 1].nodeName != "BR") && (a = bA(t, o, r, e));
  }
  a == null && (a = yA(t, s, e));
  let l = t.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function p0(t) {
  return t.top < t.bottom || t.left < t.right;
}
function rr(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let o = n[e < 0 ? 0 : n.length - 1];
    if (p0(o))
      return o;
  }
  return Array.prototype.find.call(n, p0) || t.getBoundingClientRect();
}
const xA = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Dx(t, e, n) {
  let { node: o, offset: r, atom: i } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = Bl || Wn;
  if (o.nodeType == 3)
    if (s && (xA.test(o.nodeValue) || (n < 0 ? !r : r == o.nodeValue.length))) {
      let l = rr(To(o, r, r), n);
      if (Wn && r && /\s/.test(o.nodeValue[r - 1]) && r < o.nodeValue.length) {
        let c = rr(To(o, r - 1, r - 1), -1);
        if (c.top == l.top) {
          let u = rr(To(o, r, r + 1), -1);
          if (u.top != l.top)
            return ha(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = r, c = r, u = n < 0 ? 1 : -1;
      return n < 0 && !r ? (c++, u = -1) : n >= 0 && r == o.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++, ha(rr(To(o, l, c), u), u < 0);
    }
  if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
    if (i == null && r && (n < 0 || r == kn(o))) {
      let l = o.childNodes[r - 1];
      if (l.nodeType == 1)
        return pp(l.getBoundingClientRect(), !1);
    }
    if (i == null && r < kn(o)) {
      let l = o.childNodes[r];
      if (l.nodeType == 1)
        return pp(l.getBoundingClientRect(), !0);
    }
    return pp(o.getBoundingClientRect(), n >= 0);
  }
  if (i == null && r && (n < 0 || r == kn(o))) {
    let l = o.childNodes[r - 1], c = l.nodeType == 3 ? To(l, kn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return ha(rr(c, 1), !1);
  }
  if (i == null && r < kn(o)) {
    let l = o.childNodes[r];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? To(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return ha(rr(c, -1), !0);
  }
  return ha(rr(o.nodeType == 3 ? To(o) : o, -n), n >= 0);
}
function ha(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function pp(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function Nx(t, e, n) {
  let o = t.state, r = t.root.activeElement;
  o != e && t.updateState(e), r != t.dom && t.focus();
  try {
    return n();
  } finally {
    o != e && t.updateState(o), r != t.dom && r && r.focus();
  }
}
function CA(t, e, n) {
  let o = e.selection, r = n == "up" ? o.$from : o.$to;
  return Nx(t, e, () => {
    let { node: i } = t.docView.domFromPos(r.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(i, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        i = a.contentDOM || a.dom;
        break;
      }
      i = a.dom.parentNode;
    }
    let s = Dx(t, r.pos, 1);
    for (let a = i.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = To(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (n == "up" ? s.top - u.top > (u.bottom - s.top) * 2 : u.bottom - s.bottom > (s.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const SA = /[\u0590-\u08ac]/;
function kA(t, e, n) {
  let { $head: o } = e.selection;
  if (!o.parent.isTextblock)
    return !1;
  let r = o.parentOffset, i = !r, s = r == o.parent.content.size, a = t.domSelection();
  return a ? !SA.test(o.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? i : s : Nx(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = t.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let p = o.depth ? t.docView.domAfterPos(o.before()) : t.dom, { focusNode: m, focusOffset: g } = t.domSelectionRange(), v = m && !p.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && c == g;
    try {
      a.collapse(u, d), l && (l != u || c != d) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), v;
  }) : o.pos == o.start() || o.pos == o.end();
}
let h0 = null, m0 = null, g0 = !1;
function EA(t, e, n) {
  return h0 == e && m0 == n ? g0 : (h0 = e, m0 = n, g0 = n == "up" || n == "down" ? CA(t, e, n) : kA(t, e, n));
}
const En = 0, v0 = 1, si = 2, uo = 3;
class Fl {
  constructor(e, n, o, r) {
    this.parent = e, this.children = n, this.dom = o, this.contentDOM = r, this.dirty = En, o.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, o) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, o = this.posAtStart; ; n++) {
      let r = this.children[n];
      if (r == e)
        return o;
      o += r.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, o) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (o < 0) {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.previousSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.previousSibling;
        return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.nextSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.nextSibling;
        return i ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let r;
    if (e == this.dom && this.contentDOM)
      r = n > At(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      r = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            r = !1;
            break;
          }
          if (i.previousSibling)
            break;
        }
      if (r == null && n == e.childNodes.length)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            r = !0;
            break;
          }
          if (i.nextSibling)
            break;
        }
    }
    return r ?? o > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let o = !0, r = e; r; r = r.parentNode) {
      let i = this.getDesc(r), s;
      if (i && (!n || i.node))
        if (o && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
          o = !1;
        else
          return i;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let o = n; o; o = o.parent)
      if (o == this)
        return n;
  }
  posFromDOM(e, n, o) {
    for (let r = e; r; r = r.parentNode) {
      let i = this.getDesc(r);
      if (i)
        return i.localPosFromDOM(e, n, o);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, o = 0; n < this.children.length; n++) {
      let r = this.children[n], i = o + r.size;
      if (o == e && i != o) {
        for (; !r.border && r.children.length; )
          for (let s = 0; s < r.children.length; s++) {
            let a = r.children[s];
            if (a.size) {
              r = a;
              break;
            }
          }
        return r;
      }
      if (e < i)
        return r.descAt(e - o - r.border);
      o = i;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let o = 0, r = 0;
    for (let i = 0; o < this.children.length; o++) {
      let s = this.children[o], a = i + s.size;
      if (a > e || s instanceof Fx) {
        r = e - i;
        break;
      }
      i = a;
    }
    if (r)
      return this.children[o].domFromPos(r - this.children[o].border, n);
    for (let i; o && !(i = this.children[o - 1]).size && i instanceof Bx && i.side >= 0; o--)
      ;
    if (n <= 0) {
      let i, s = !0;
      for (; i = o ? this.children[o - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); o--, s = !1)
        ;
      return i && n && s && !i.border && !i.domAtom ? i.domFromPos(i.size, n) : { node: this.contentDOM, offset: i ? At(i.dom) + 1 : 0 };
    } else {
      let i, s = !0;
      for (; i = o < this.children.length ? this.children[o] : null, !(!i || i.dom.parentNode == this.contentDOM); o++, s = !1)
        ;
      return i && s && !i.border && !i.domAtom ? i.domFromPos(0, n) : { node: this.contentDOM, offset: i ? At(i.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, o = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let r = -1, i = -1;
    for (let s = o, a = 0; ; a++) {
      let l = this.children[a], c = s + l.size;
      if (r == -1 && e <= c) {
        let u = s + l.border;
        if (e >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, u);
        e = s;
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            r = At(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        r == -1 && (r = 0);
      }
      if (r > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            i = At(d.dom);
            break;
          }
          n += d.size;
        }
        i == -1 && (i = this.contentDOM.childNodes.length);
        break;
      }
      s = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: r, toOffset: i };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: o } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || o == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[o];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, o, r = !1) {
    let i = Math.min(e, n), s = Math.max(e, n);
    for (let p = 0, m = 0; p < this.children.length; p++) {
      let g = this.children[p], v = m + g.size;
      if (i > m && s < v)
        return g.setSelection(e - m - g.border, n - m - g.border, o, r);
      m = v;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = o.root.getSelection(), u = o.domSelectionRange(), d = !1;
    if ((Wn || Kt) && e == n) {
      let { node: p, offset: m } = a;
      if (p.nodeType == 3) {
        if (d = !!(m && p.nodeValue[m - 1] == `
`), d && m == p.nodeValue.length)
          for (let g = p, v; g; g = g.parentNode) {
            if (v = g.nextSibling) {
              v.nodeName == "BR" && (a = l = { node: v.parentNode, offset: At(v) + 1 });
              break;
            }
            let y = g.pmViewDesc;
            if (y && y.node && y.node.isBlock)
              break;
          }
      } else {
        let g = p.childNodes[m - 1];
        d = g && (g.nodeName == "BR" || g.contentEditable == "false");
      }
    }
    if (Wn && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let p = u.focusNode.childNodes[u.focusOffset];
      p && p.contentEditable == "false" && (r = !0);
    }
    if (!(r || d && Kt) && wi(a.node, a.offset, u.anchorNode, u.anchorOffset) && wi(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == n) && !d) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let m = a;
        a = l, l = m;
      }
      let p = document.createRange();
      p.setEnd(l.node, l.offset), p.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let o = 0, r = 0; r < this.children.length; r++) {
      let i = this.children[r], s = o + i.size;
      if (o == s ? e <= s && n >= o : e < s && n > o) {
        let a = o + i.border, l = s - i.border;
        if (e >= a && n <= l) {
          this.dirty = e == o || n == s ? si : v0, e == a && n == l && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = uo : i.markDirty(e - a, n - a);
          return;
        } else
          i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? si : uo;
      }
      o = s;
    }
    this.dirty = si;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let o = e == 1 ? si : v0;
      n.dirty < o && (n.dirty = o);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class Bx extends Fl {
  constructor(e, n, o, r) {
    let i, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(o, () => {
      if (!i)
        return r;
      if (i.parent)
        return i.parent.posBeforeChild(i);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), this.widget = n, this.widget = n, i = this;
  }
  matchesWidget(e) {
    return this.dirty == En && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class _A extends Fl {
  constructor(e, n, o, r) {
    super(e, [], n, null), this.textDOM = o, this.text = r;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class xi extends Fl {
  constructor(e, n, o, r, i) {
    super(e, [], o, r), this.mark = n, this.spec = i;
  }
  static create(e, n, o, r) {
    let i = r.nodeViews[n.type.name], s = i && i(n, r, o);
    return (!s || !s.dom) && (s = Pr.renderSpec(document, n.type.spec.toDOM(n, o), null, n.attrs)), new xi(e, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & uo || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != uo && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != En) {
      let o = this.parent;
      for (; !o.node; )
        o = o.parent;
      o.dirty < this.dirty && (o.dirty = this.dirty), this.dirty = En;
    }
  }
  slice(e, n, o) {
    let r = xi.create(this.parent, this.mark, !0, o), i = this.children, s = this.size;
    n < s && (i = Hh(i, n, s, o)), e > 0 && (i = Hh(i, 0, e, o));
    for (let a = 0; a < i.length; a++)
      i[a].parent = r;
    return r.children = i, r;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class wr extends Fl {
  constructor(e, n, o, r, i, s, a, l, c) {
    super(e, [], i, s), this.node = n, this.outerDeco = o, this.innerDeco = r, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, o, r, i, s) {
    let a = i.nodeViews[n.type.name], l, c = a && a(n, i, () => {
      if (!l)
        return s;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, o, r), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = Pr.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = Vx(u, o, n), c ? l = new AA(e, n, o, r, u, d || null, f, c, i, s + 1) : n.isText ? new ef(e, n, o, r, u, f, i) : new wr(e, n, o, r, u, d || null, f, i, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let o = this.children[n];
        if (this.dom.contains(o.dom.parentNode)) {
          e.contentElement = o.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => K.empty);
    }
    return e;
  }
  matchesNode(e, n, o) {
    return this.dirty == En && e.eq(this.node) && Lu(n, this.outerDeco) && o.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let o = this.node.inlineContent, r = n, i = e.composing ? this.localCompositionInfo(e, n) : null, s = i && i.pos > -1 ? i : null, a = i && i.pos < 0, l = new OA(this, s && s.node, e);
    RA(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, o, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Je.none : this.node.child(u).marks, o, e), l.placeWidget(c, e, r);
    }, (c, u, d, f) => {
      l.syncToMarks(c.marks, o, e);
      let p;
      l.findNodeMatch(c, u, d, f) || a && e.state.selection.from > r && e.state.selection.to < r + c.nodeSize && (p = l.findIndexWithChild(i.node)) > -1 && l.updateNodeAt(c, u, d, p, e) || l.updateNextNode(c, u, d, e, f, r) || l.addNode(c, u, d, e, r), r += c.nodeSize;
    }), l.syncToMarks([], o, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == si) && (s && this.protectLocalComposition(e, s), zx(this.contentDOM, this.children, e), ws && $A(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: o, to: r } = e.state.selection;
    if (!(e.state.selection instanceof ce) || o < n || r > n + this.node.content.size)
      return null;
    let i = e.input.compositionNode;
    if (!i || !this.dom.contains(i.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = i.nodeValue, a = PA(this.node.content, s, o - n, r - n);
      return a < 0 ? null : { node: i, pos: a, text: s };
    } else
      return { node: i, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: o, text: r }) {
    if (this.getDesc(n))
      return;
    let i = n;
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; )
        i.parentNode.removeChild(i.previousSibling);
      for (; i.nextSibling; )
        i.parentNode.removeChild(i.nextSibling);
      i.pmViewDesc && (i.pmViewDesc = void 0);
    }
    let s = new _A(this, i, n, r);
    e.input.compositionNodes.push(s), this.children = Hh(this.children, o, o + r.length, e, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, o, r) {
    return this.dirty == uo || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, o, r), !0);
  }
  updateInner(e, n, o, r) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = o, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = En;
  }
  updateOuterDeco(e) {
    if (Lu(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, o = this.dom;
    this.dom = Hx(this.dom, this.nodeDOM, zh(this.outerDeco, this.node, n), zh(e, this.node, n)), this.dom != o && (o.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function y0(t, e, n, o, r) {
  Vx(o, e, t);
  let i = new wr(void 0, t, e, n, o, o, o, r, 0);
  return i.contentDOM && i.updateChildren(r, 0), i;
}
class ef extends wr {
  constructor(e, n, o, r, i, s, a) {
    super(e, n, o, r, i, null, s, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, o, r) {
    return this.dirty == uo || this.dirty != En && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != En || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = En, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, o) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, o);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, o) {
    let r = this.node.cut(e, n), i = document.createTextNode(r.text);
    return new ef(this.parent, r, this.outerDeco, this.innerDeco, i, i, o);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = uo);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class Fx extends Fl {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == En && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class AA extends wr {
  constructor(e, n, o, r, i, s, a, l, c, u) {
    super(e, n, o, r, i, s, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, o, r) {
    if (this.dirty == uo)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let i = this.spec.update(e, n, o);
      return i && this.updateInner(e, n, o, r), i;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, o, r);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, o, r) {
    this.spec.setSelection ? this.spec.setSelection(e, n, o.root) : super.setSelection(e, n, o, r);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function zx(t, e, n) {
  let o = t.firstChild, r = !1;
  for (let i = 0; i < e.length; i++) {
    let s = e[i], a = s.dom;
    if (a.parentNode == t) {
      for (; a != o; )
        o = b0(o), r = !0;
      o = o.nextSibling;
    } else
      r = !0, t.insertBefore(a, o);
    if (s instanceof xi) {
      let l = o ? o.previousSibling : t.lastChild;
      zx(s.contentDOM, s.children, n), o = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; o; )
    o = b0(o), r = !0;
  r && n.trackWrites == t && (n.trackWrites = null);
}
const Na = function(t) {
  t && (this.nodeName = t);
};
Na.prototype = /* @__PURE__ */ Object.create(null);
const ai = [new Na()];
function zh(t, e, n) {
  if (t.length == 0)
    return ai;
  let o = n ? ai[0] : new Na(), r = [o];
  for (let i = 0; i < t.length; i++) {
    let s = t[i].type.attrs;
    if (s) {
      s.nodeName && r.push(o = new Na(s.nodeName));
      for (let a in s) {
        let l = s[a];
        l != null && (n && r.length == 1 && r.push(o = new Na(e.isInline ? "span" : "div")), a == "class" ? o.class = (o.class ? o.class + " " : "") + l : a == "style" ? o.style = (o.style ? o.style + ";" : "") + l : a != "nodeName" && (o[a] = l));
      }
    }
  }
  return r;
}
function Hx(t, e, n, o) {
  if (n == ai && o == ai)
    return e;
  let r = e;
  for (let i = 0; i < o.length; i++) {
    let s = o[i], a = n[i];
    if (i) {
      let l;
      a && a.nodeName == s.nodeName && r != t && (l = r.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(r), a = ai[0]), r = l;
    }
    TA(r, a || ai[0], s);
  }
  return r;
}
function TA(t, e, n) {
  for (let o in e)
    o != "class" && o != "style" && o != "nodeName" && !(o in n) && t.removeAttribute(o);
  for (let o in n)
    o != "class" && o != "style" && o != "nodeName" && n[o] != e[o] && t.setAttribute(o, n[o]);
  if (e.class != n.class) {
    let o = e.class ? e.class.split(" ").filter(Boolean) : [], r = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && t.classList.remove(o[i]);
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && t.classList.add(r[i]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let o = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, r;
      for (; r = o.exec(e.style); )
        t.style.removeProperty(r[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function Vx(t, e, n) {
  return Hx(t, t, ai, zh(e, n, t.nodeType != 1));
}
function Lu(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function b0(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class OA {
  constructor(e, n, o) {
    this.lock = n, this.view = o, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = MA(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let o = e; o < n; o++)
        this.top.children[o].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, o) {
    let r = 0, i = this.stack.length >> 1, s = Math.min(i, e.length);
    for (; r < s && (r == i - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && e[r].type.spec.spanning !== !1; )
      r++;
    for (; r < i; )
      this.destroyRest(), this.top.dirty = En, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
    for (; i < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[i]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = xi.create(this.top, e[i], n, o);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, i++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, o, r) {
    let i = -1, s;
    if (r >= this.preMatch.index && (s = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, o))
      i = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, o) && !this.preMatch.matched.has(c)) {
          i = a;
          break;
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0);
  }
  updateNodeAt(e, n, o, r, i) {
    let s = this.top.children[r];
    return s.dirty == uo && s.dom == s.contentDOM && (s.dirty = si), s.update(e, n, o, i) ? (this.destroyBetween(this.index, r), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let o = e.pmViewDesc;
        if (o) {
          for (let r = this.index; r < this.top.children.length; r++)
            if (this.top.children[r] == o)
              return r;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, o, r, i, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof wr) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != i)
          return !1;
        let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != uo && Lu(n, l.outerDeco));
        if (!f && l.update(e, n, o, r))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(l, e, n, o, r, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = si, d.updateChildren(r, s + 1), d.dirty = En), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, o, r, i, s) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Lu(o, e.outerDeco) || !r.eq(e.innerDeco))
      return null;
    let a = wr.create(this.top, n, o, r, i, s);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, o, r, i) {
    let s = wr.create(this.top, e, n, o, r, i);
    s.contentDOM && s.updateChildren(r, i + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(e, n, o) {
    let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (r && r.matchesWidget(e) && (e == r.widget || !r.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let i = new Bx(this.top, e, n, o);
      this.top.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof xi; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof ef) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Kt || Pt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let o = document.createElement(e);
      e == "IMG" && (o.className = "ProseMirror-separator", o.alt = ""), e == "BR" && (o.className = "ProseMirror-trailingBreak");
      let r = new Fx(this.top, [], o, null);
      n != this.top ? n.children.push(r) : n.children.splice(this.index++, 0, r), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function MA(t, e) {
  let n = e, o = n.children.length, r = t.childCount, i = /* @__PURE__ */ new Map(), s = [];
  e: for (; r > 0; ) {
    let a;
    for (; ; )
      if (o) {
        let c = n.children[o - 1];
        if (c instanceof xi)
          n = c, o = c.children.length;
        else {
          a = c, o--;
          break;
        }
      } else {
        if (n == e)
          break e;
        o = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = a.node;
    if (l) {
      if (l != t.child(r - 1))
        break;
      --r, i.set(a, r), s.push(a);
    }
  }
  return { index: r, matched: i, matches: s.reverse() };
}
function IA(t, e) {
  return t.type.side - e.type.side;
}
function RA(t, e, n, o) {
  let r = e.locals(t), i = 0;
  if (r.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c);
      o(u, r, e.forChild(i, u), c), i += u.nodeSize;
    }
    return;
  }
  let s = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; s < r.length && r[s].to == i; ) {
      let v = r[s++];
      v.widget && (u ? (d || (d = [u])).push(v) : u = v);
    }
    if (u)
      if (d) {
        d.sort(IA);
        for (let v = 0; v < d.length; v++)
          n(d[v], c, !!l);
      } else
        n(u, c, !!l);
    let f, p;
    if (l)
      p = -1, f = l, l = null;
    else if (c < t.childCount)
      p = c, f = t.child(c++);
    else
      break;
    for (let v = 0; v < a.length; v++)
      a[v].to <= i && a.splice(v--, 1);
    for (; s < r.length && r[s].from <= i && r[s].to > i; )
      a.push(r[s++]);
    let m = i + f.nodeSize;
    if (f.isText) {
      let v = m;
      s < r.length && r[s].from < v && (v = r[s].from);
      for (let y = 0; y < a.length; y++)
        a[y].to < v && (v = a[y].to);
      v < m && (l = f.cut(v - i), f = f.cut(0, v - i), m = v, p = -1);
    } else
      for (; s < r.length && r[s].to < m; )
        s++;
    let g = f.isInline && !f.isLeaf ? a.filter((v) => !v.inline) : a.slice();
    o(f, g, e.forChild(i, f), p), i = m;
  }
}
function $A(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function PA(t, e, n, o) {
  for (let r = 0, i = 0; r < t.childCount && i <= o; ) {
    let s = t.child(r++), a = i;
    if (i += s.nodeSize, !s.isText)
      continue;
    let l = s.text;
    for (; r < t.childCount; ) {
      let c = t.child(r++);
      if (i += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (i >= n) {
      if (i >= o && l.slice(o - e.length - a, o - a) == e)
        return o - e.length;
      let c = a < o ? l.lastIndexOf(e, o - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == o && l.length >= o + e.length - a && l.slice(o - a, o - a + e.length) == e)
        return o;
    }
  }
  return -1;
}
function Hh(t, e, n, o, r) {
  let i = [];
  for (let s = 0, a = 0; s < t.length; s++) {
    let l = t[s], c = a, u = a += l.size;
    c >= n || u <= e ? i.push(l) : (c < e && i.push(l.slice(0, e - c, o)), r && (i.push(r), r = void 0), u > n && i.push(l.slice(n - c, l.size, o)));
  }
  return i;
}
function Rg(t, e = null) {
  let n = t.domSelectionRange(), o = t.state.doc;
  if (!n.focusNode)
    return null;
  let r = t.docView.nearestDesc(n.focusNode), i = r && r.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = o.resolve(s), l, c;
  if (Qd(n)) {
    for (l = s; r && !r.node; )
      r = r.parent;
    let d = r.node;
    if (r && d.isAtom && de.isSelectable(d) && r.parent && !(d.isInline && sA(n.focusNode, n.focusOffset, r.dom))) {
      let f = r.posBefore;
      c = new de(s == f ? a : o.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = s, f = s;
      for (let p = 0; p < n.rangeCount; p++) {
        let m = n.getRangeAt(p);
        d = Math.min(d, t.docView.posFromDOM(m.startContainer, m.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(m.endContainer, m.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, s] = f == t.state.selection.anchor ? [f, d] : [d, f], a = o.resolve(s);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = o.resolve(l);
  if (!c) {
    let d = e == "pointer" || t.state.selection.head < a.pos && !i ? 1 : -1;
    c = $g(t, u, a, d);
  }
  return c;
}
function Ux(t) {
  return t.editable ? t.hasFocus() : Wx(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Fo(t, e = !1) {
  let n = t.state.selection;
  if (jx(t, n), !!Ux(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Pt) {
      let o = t.domSelectionRange(), r = t.domObserver.currentSelection;
      if (o.anchorNode && r.anchorNode && wi(o.anchorNode, o.anchorOffset, r.anchorNode, r.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      DA(t);
    else {
      let { anchor: o, head: r } = n, i, s;
      w0 && !(n instanceof ce) && (n.$from.parent.inlineContent || (i = x0(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = x0(t, n.to))), t.docView.setSelection(o, r, t, e), w0 && (i && C0(i), s && C0(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && LA(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const w0 = Kt || Pt && Ix < 63;
function x0(t, e) {
  let { node: n, offset: o } = t.docView.domFromPos(e, 0), r = o < n.childNodes.length ? n.childNodes[o] : null, i = o ? n.childNodes[o - 1] : null;
  if (Kt && r && r.contentEditable == "false")
    return hp(r);
  if ((!r || r.contentEditable == "false") && (!i || i.contentEditable == "false")) {
    if (r)
      return hp(r);
    if (i)
      return hp(i);
  }
}
function hp(t) {
  return t.contentEditable = "true", Kt && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function C0(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function LA(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), o = n.anchorNode, r = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != o || n.anchorOffset != r) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!Ux(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function DA(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let o = t.cursorWrapper.dom, r = o.nodeName == "IMG";
  r ? n.setStart(o.parentNode, At(o) + 1) : n.setStart(o, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !r && !t.state.selection.visible && en && br <= 11 && (o.disabled = !0, o.disabled = !1);
}
function jx(t, e) {
  if (e instanceof de) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (S0(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    S0(t);
}
function S0(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function $g(t, e, n, o) {
  return t.someProp("createSelectionBetween", (r) => r(t, e, n)) || ce.between(e, n, o);
}
function k0(t) {
  return t.editable && !t.hasFocus() ? !1 : Wx(t);
}
function Wx(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function NA(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return wi(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Vh(t, e) {
  let { $anchor: n, $head: o } = t.selection, r = e > 0 ? n.max(o) : n.min(o), i = r.parent.inlineContent ? r.depth ? t.doc.resolve(e > 0 ? r.after() : r.before()) : null : r;
  return i && fe.findFrom(i, e);
}
function sr(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function E0(t, e, n) {
  let o = t.state.selection;
  if (o instanceof ce)
    if (n.indexOf("s") > -1) {
      let { $head: r } = o, i = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter;
      if (!i || i.isText || !i.isLeaf)
        return !1;
      let s = t.state.doc.resolve(r.pos + i.nodeSize * (e < 0 ? -1 : 1));
      return sr(t, new ce(o.$anchor, s));
    } else if (o.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let r = Vh(t.state, e);
        return r && r instanceof de ? sr(t, r) : !1;
      } else if (!(Sn && n.indexOf("m") > -1)) {
        let r = o.$head, i = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter, s;
        if (!i || i.isText)
          return !1;
        let a = e < 0 ? r.pos - i.nodeSize : r.pos;
        return i.isAtom || (s = t.docView.descAt(a)) && !s.contentDOM ? de.isSelectable(i) ? sr(t, new de(e < 0 ? t.state.doc.resolve(r.pos - i.nodeSize) : r)) : Bl ? sr(t, new ce(t.state.doc.resolve(e < 0 ? a : a + i.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (o instanceof de && o.node.isInline)
      return sr(t, new ce(e > 0 ? o.$to : o.$from));
    {
      let r = Vh(t.state, e);
      return r ? sr(t, r) : !1;
    }
  }
}
function Du(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Ba(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function ji(t, e) {
  return e < 0 ? BA(t) : FA(t);
}
function BA(t) {
  let e = t.domSelectionRange(), n = e.focusNode, o = e.focusOffset;
  if (!n)
    return;
  let r, i, s = !1;
  for (Wn && n.nodeType == 1 && o < Du(n) && Ba(n.childNodes[o], -1) && (s = !0); ; )
    if (o > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[o - 1];
        if (Ba(a, -1))
          r = n, i = --o;
        else if (a.nodeType == 3)
          n = a, o = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (Kx(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Ba(a, -1); )
          r = n.parentNode, i = At(a), a = a.previousSibling;
        if (a)
          n = a, o = Du(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          o = 0;
        }
      }
    }
  s ? Uh(t, n, o) : r && Uh(t, r, i);
}
function FA(t) {
  let e = t.domSelectionRange(), n = e.focusNode, o = e.focusOffset;
  if (!n)
    return;
  let r = Du(n), i, s;
  for (; ; )
    if (o < r) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[o];
      if (Ba(a, 1))
        i = n, s = ++o;
      else
        break;
    } else {
      if (Kx(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Ba(a, 1); )
          i = a.parentNode, s = At(a) + 1, a = a.nextSibling;
        if (a)
          n = a, o = 0, r = Du(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          o = r = 0;
        }
      }
    }
  i && Uh(t, i, s);
}
function Kx(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function zA(t, e) {
  for (; t && e == t.childNodes.length && !Nl(t); )
    e = At(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function HA(t, e) {
  for (; t && !e && !Nl(t); )
    e = At(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function Uh(t, e, n) {
  if (e.nodeType != 3) {
    let i, s;
    (s = zA(e, n)) ? (e = s, n = 0) : (i = HA(e, n)) && (e = i, n = i.nodeValue.length);
  }
  let o = t.domSelection();
  if (!o)
    return;
  if (Qd(o)) {
    let i = document.createRange();
    i.setEnd(e, n), i.setStart(e, n), o.removeAllRanges(), o.addRange(i);
  } else o.extend && o.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: r } = t;
  setTimeout(() => {
    t.state == r && Fo(t);
  }, 50);
}
function _0(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Pt || cA) && n.parent.inlineContent) {
    let r = t.coordsAtPos(e);
    if (e > n.start()) {
      let i = t.coordsAtPos(e - 1), s = (i.top + i.bottom) / 2;
      if (s > r.top && s < r.bottom && Math.abs(i.left - r.left) > 1)
        return i.left < r.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let i = t.coordsAtPos(e + 1), s = (i.top + i.bottom) / 2;
      if (s > r.top && s < r.bottom && Math.abs(i.left - r.left) > 1)
        return i.left > r.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function A0(t, e, n) {
  let o = t.state.selection;
  if (o instanceof ce && !o.empty || n.indexOf("s") > -1 || Sn && n.indexOf("m") > -1)
    return !1;
  let { $from: r, $to: i } = o;
  if (!r.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = Vh(t.state, e);
    if (s && s instanceof de)
      return sr(t, s);
  }
  if (!r.parent.inlineContent) {
    let s = e < 0 ? r : i, a = o instanceof Wt ? fe.near(s, e) : fe.findFrom(s, e);
    return a ? sr(t, a) : !1;
  }
  return !1;
}
function T0(t, e) {
  if (!(t.state.selection instanceof ce))
    return !0;
  let { $head: n, $anchor: o, empty: r } = t.state.selection;
  if (!n.sameParent(o))
    return !0;
  if (!r)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (i && !i.isText) {
    let s = t.state.tr;
    return e < 0 ? s.delete(n.pos - i.nodeSize, n.pos) : s.delete(n.pos, n.pos + i.nodeSize), t.dispatch(s), !0;
  }
  return !1;
}
function O0(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function VA(t) {
  if (!Kt || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let o = e.firstChild;
    O0(t, o, "true"), setTimeout(() => O0(t, o, "false"), 20);
  }
  return !1;
}
function UA(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function jA(t, e) {
  let n = e.keyCode, o = UA(e);
  if (n == 8 || Sn && n == 72 && o == "c")
    return T0(t, -1) || ji(t, -1);
  if (n == 46 && !e.shiftKey || Sn && n == 68 && o == "c")
    return T0(t, 1) || ji(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Sn && n == 66 && o == "c") {
    let r = n == 37 ? _0(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return E0(t, r, o) || ji(t, r);
  } else if (n == 39 || Sn && n == 70 && o == "c") {
    let r = n == 39 ? _0(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return E0(t, r, o) || ji(t, r);
  } else {
    if (n == 38 || Sn && n == 80 && o == "c")
      return A0(t, -1, o) || ji(t, -1);
    if (n == 40 || Sn && n == 78 && o == "c")
      return VA(t) || A0(t, 1, o) || ji(t, 1);
    if (o == (Sn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function Pg(t, e) {
  t.someProp("transformCopied", (p) => {
    e = p(e, t);
  });
  let n = [], { content: o, openStart: r, openEnd: i } = e;
  for (; r > 1 && i > 1 && o.childCount == 1 && o.firstChild.childCount == 1; ) {
    r--, i--;
    let p = o.firstChild;
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), o = p.content;
  }
  let s = t.someProp("clipboardSerializer") || Pr.fromSchema(t.state.schema), a = Zx(), l = a.createElement("div");
  l.appendChild(s.serializeFragment(o, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = Xx[c.nodeName.toLowerCase()]); ) {
    for (let p = u.length - 1; p >= 0; p--) {
      let m = a.createElement(u[p]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${r} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (p) => p(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function Gx(t, e, n, o, r) {
  let i = r.parent.type.spec.code, s, a;
  if (!n && !e)
    return null;
  let l = e && (o || i || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, i || o, t);
    }), i)
      return e ? new te(K.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : te.empty;
    let d = t.someProp("clipboardTextParser", (f) => f(e, r, o, t));
    if (d)
      a = d;
    else {
      let f = r.marks(), { schema: p } = t.state, m = Pr.fromSchema(p);
      s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let v = s.appendChild(document.createElement("p"));
        g && v.appendChild(m.serializeNode(p.text(g, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), s = qA(n), Bl && YA(s);
  let c = s && s.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = s.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      s = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || Da.fromSchema(t.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(l || u),
    context: r,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !WA.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = JA(M0(a, +u[1], +u[2]), u[4]);
  else if (a = te.maxOpen(KA(a.content, r), !0), a.openStart || a.openEnd) {
    let d = 0, f = 0;
    for (let p = a.content.firstChild; d < a.openStart && !p.type.spec.isolating; d++, p = p.firstChild)
      ;
    for (let p = a.content.lastChild; f < a.openEnd && !p.type.spec.isolating; f++, p = p.lastChild)
      ;
    a = M0(a, d, f);
  }
  return t.someProp("transformPasted", (d) => {
    a = d(a, t);
  }), a;
}
const WA = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function KA(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let r = e.node(n).contentMatchAt(e.index(n)), i, s = [];
    if (t.forEach((a) => {
      if (!s)
        return;
      let l = r.findWrapping(a.type), c;
      if (!l)
        return s = null;
      if (c = s.length && i.length && Yx(l, i, a, s[s.length - 1], 0))
        s[s.length - 1] = c;
      else {
        s.length && (s[s.length - 1] = Jx(s[s.length - 1], i.length));
        let u = qx(a, l);
        s.push(u), r = r.matchType(u.type), i = l;
      }
    }), s)
      return K.from(s);
  }
  return t;
}
function qx(t, e, n = 0) {
  for (let o = e.length - 1; o >= n; o--)
    t = e[o].create(null, K.from(t));
  return t;
}
function Yx(t, e, n, o, r) {
  if (r < t.length && r < e.length && t[r] == e[r]) {
    let i = Yx(t, e, n, o.lastChild, r + 1);
    if (i)
      return o.copy(o.content.replaceChild(o.childCount - 1, i));
    if (o.contentMatchAt(o.childCount).matchType(r == t.length - 1 ? n.type : t[r + 1]))
      return o.copy(o.content.append(K.from(qx(n, t, r + 1))));
  }
}
function Jx(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, Jx(t.lastChild, e - 1)), o = t.contentMatchAt(t.childCount).fillBefore(K.empty, !0);
  return t.copy(n.append(o));
}
function jh(t, e, n, o, r, i) {
  let s = e < 0 ? t.firstChild : t.lastChild, a = s.content;
  return t.childCount > 1 && (i = 0), r < o - 1 && (a = jh(a, e, n, o, r + 1, i)), r >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, i <= r).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(K.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a));
}
function M0(t, e, n) {
  return e < t.openStart && (t = new te(jh(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new te(jh(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const Xx = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let I0 = null;
function Zx() {
  return I0 || (I0 = document.implementation.createHTMLDocument("title"));
}
let mp = null;
function GA(t) {
  let e = window.trustedTypes;
  return e ? (mp || (mp = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), mp.createHTML(t)) : t;
}
function qA(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = Zx().createElement("div"), o = /<([a-z][^>\s]+)/i.exec(t), r;
  if ((r = o && Xx[o[1].toLowerCase()]) && (t = r.map((i) => "<" + i + ">").join("") + t + r.map((i) => "</" + i + ">").reverse().join("")), n.innerHTML = GA(t), r)
    for (let i = 0; i < r.length; i++)
      n = n.querySelector(r[i]) || n;
  return n;
}
function YA(t) {
  let e = t.querySelectorAll(Pt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let o = e[n];
    o.childNodes.length == 1 && o.textContent == " " && o.parentNode && o.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), o);
  }
}
function JA(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, o;
  try {
    o = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: r, openStart: i, openEnd: s } = t;
  for (let a = o.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[o[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    r = K.from(l.create(o[a + 1], r)), i++, s++;
  }
  return new te(r, i, s);
}
const Gt = {}, qt = {}, XA = { touchstart: !0, touchmove: !0 };
class ZA {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function QA(t) {
  for (let e in Gt) {
    let n = Gt[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (o) => {
      t6(t, o) && !Lg(t, o) && (t.editable || !(o.type in qt)) && n(t, o);
    }, XA[e] ? { passive: !0 } : void 0);
  }
  Kt && t.dom.addEventListener("input", () => null), Wh(t);
}
function gr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function e6(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Wh(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (o) => Lg(t, o));
  });
}
function Lg(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let o = n[e.type];
    return o ? o(t, e) || e.defaultPrevented : !1;
  });
}
function t6(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function n6(t, e) {
  !Lg(t, e) && Gt[e.type] && (t.editable || !(e.type in qt)) && Gt[e.type](t, e);
}
qt.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !eC(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !($o && Pt && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), ws && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let o = Date.now();
      t.input.lastIOSEnter = o, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == o && (t.someProp("handleKeyDown", (r) => r(t, ri(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (o) => o(t, n)) || jA(t, n) ? n.preventDefault() : gr(t, "key");
};
qt.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
qt.keypress = (t, e) => {
  let n = e;
  if (eC(t, n) || !n.charCode || n.ctrlKey && !n.altKey || Sn && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (r) => r(t, n))) {
    n.preventDefault();
    return;
  }
  let o = t.state.selection;
  if (!(o instanceof ce) || !o.$from.sameParent(o.$to)) {
    let r = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(r) && !t.someProp("handleTextInput", (i) => i(t, o.$from.pos, o.$to.pos, r)) && t.dispatch(t.state.tr.insertText(r).scrollIntoView()), n.preventDefault();
  }
};
function tf(t) {
  return { left: t.clientX, top: t.clientY };
}
function o6(t, e) {
  let n = e.x - t.clientX, o = e.y - t.clientY;
  return n * n + o * o < 100;
}
function Dg(t, e, n, o, r) {
  if (o == -1)
    return !1;
  let i = t.state.doc.resolve(o);
  for (let s = i.depth + 1; s > 0; s--)
    if (t.someProp(e, (a) => s > i.depth ? a(t, n, i.nodeAfter, i.before(s), r, !0) : a(t, n, i.node(s), i.before(s), r, !1)))
      return !0;
  return !1;
}
function fs(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let o = t.state.tr.setSelection(e);
  o.setMeta("pointer", !0), t.dispatch(o);
}
function r6(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), o = n.nodeAfter;
  return o && o.isAtom && de.isSelectable(o) ? (fs(t, new de(n)), !0) : !1;
}
function i6(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, o, r;
  n instanceof de && (o = n.node);
  let i = t.state.doc.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let a = s > i.depth ? i.nodeAfter : i.node(s);
    if (de.isSelectable(a)) {
      o && n.$from.depth > 0 && s >= n.$from.depth && i.before(n.$from.depth + 1) == n.$from.pos ? r = i.before(n.$from.depth) : r = i.before(s);
      break;
    }
  }
  return r != null ? (fs(t, de.create(t.state.doc, r)), !0) : !1;
}
function s6(t, e, n, o, r) {
  return Dg(t, "handleClickOn", e, n, o) || t.someProp("handleClick", (i) => i(t, e, o)) || (r ? i6(t, n) : r6(t, n));
}
function a6(t, e, n, o) {
  return Dg(t, "handleDoubleClickOn", e, n, o) || t.someProp("handleDoubleClick", (r) => r(t, e, o));
}
function l6(t, e, n, o) {
  return Dg(t, "handleTripleClickOn", e, n, o) || t.someProp("handleTripleClick", (r) => r(t, e, o)) || c6(t, n, o);
}
function c6(t, e, n) {
  if (n.button != 0)
    return !1;
  let o = t.state.doc;
  if (e == -1)
    return o.inlineContent ? (fs(t, ce.create(o, 0, o.content.size)), !0) : !1;
  let r = o.resolve(e);
  for (let i = r.depth + 1; i > 0; i--) {
    let s = i > r.depth ? r.nodeAfter : r.node(i), a = r.before(i);
    if (s.inlineContent)
      fs(t, ce.create(o, a + 1, a + 1 + s.content.size));
    else if (de.isSelectable(s))
      fs(t, de.create(o, a));
    else
      continue;
    return !0;
  }
}
function Ng(t) {
  return Nu(t);
}
const Qx = Sn ? "metaKey" : "ctrlKey";
Gt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let o = Ng(t), r = Date.now(), i = "singleClick";
  r - t.input.lastClick.time < 500 && o6(n, t.input.lastClick) && !n[Qx] && (t.input.lastClick.type == "singleClick" ? i = "doubleClick" : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")), t.input.lastClick = { time: r, x: n.clientX, y: n.clientY, type: i };
  let s = t.posAtCoords(tf(n));
  s && (i == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new u6(t, s, n, !!o)) : (i == "doubleClick" ? a6 : l6)(t, s.pos, s.inside, n) ? n.preventDefault() : gr(t, "pointer"));
};
class u6 {
  constructor(e, n, o, r) {
    this.view = e, this.pos = n, this.event = o, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!o[Qx], this.allowDefault = o.shiftKey;
    let i, s;
    if (n.inside > -1)
      i = e.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      i = u.parent, s = u.depth ? u.before() : 0;
    }
    const a = r ? null : o.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (o.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== !1 || c instanceof de && c.from <= s && c.to > s) && (this.mightDrag = {
      node: i,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Wn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), gr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Fo(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(tf(e))), this.updateAllowDefault(e), this.allowDefault || !n ? gr(this.view, "pointer") : s6(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Kt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Pt && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (fs(this.view, fe.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : gr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), gr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Gt.touchstart = (t) => {
  t.input.lastTouch = Date.now(), Ng(t), gr(t, "pointer");
};
Gt.touchmove = (t) => {
  t.input.lastTouch = Date.now(), gr(t, "pointer");
};
Gt.contextmenu = (t) => Ng(t);
function eC(t, e) {
  return t.composing ? !0 : Kt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const d6 = $o ? 5e3 : -1;
qt.compositionstart = qt.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof ce && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((o) => o.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Nu(t, !0), t.markCursor = null;
    else if (Nu(t, !e.selection.empty), Wn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let o = t.domSelectionRange();
      for (let r = o.focusNode, i = o.focusOffset; r && r.nodeType == 1 && i != 0; ) {
        let s = i < 0 ? r.lastChild : r.childNodes[i - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          r = s, i = -1;
      }
    }
    t.input.composing = !0;
  }
  tC(t, d6);
};
qt.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, tC(t, 20));
};
function tC(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Nu(t), e));
}
function nC(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = p6()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function f6(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = rA(e.focusNode, e.focusOffset), o = iA(e.focusNode, e.focusOffset);
  if (n && o && n != o) {
    let r = o.pmViewDesc, i = t.domObserver.lastChangedTextNode;
    if (n == i || o == i)
      return i;
    if (!r || !r.isText(o.nodeValue))
      return o;
    if (t.input.compositionNode == o) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return o;
    }
  }
  return n || o;
}
function p6() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Nu(t, e = !1) {
  if (!($o && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), nC(t), e || t.docView && t.docView.dirty) {
      let n = Rg(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function h6(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let o = getSelection(), r = document.createRange();
  r.selectNodeContents(e), t.dom.blur(), o.removeAllRanges(), o.addRange(r), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const sl = en && br < 15 || ws && uA < 604;
Gt.copy = qt.cut = (t, e) => {
  let n = e, o = t.state.selection, r = n.type == "cut";
  if (o.empty)
    return;
  let i = sl ? null : n.clipboardData, s = o.content(), { dom: a, text: l } = Pg(t, s);
  i ? (n.preventDefault(), i.clearData(), i.setData("text/html", a.innerHTML), i.setData("text/plain", l)) : h6(t, a), r && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function m6(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function g6(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, o = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (o.contentEditable = "true"), o.style.cssText = "position: fixed; left: -10000px; top: 10px", o.focus();
  let r = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), o.parentNode && o.parentNode.removeChild(o), n ? al(t, o.value, null, r, e) : al(t, o.textContent, o.innerHTML, r, e);
  }, 50);
}
function al(t, e, n, o, r) {
  let i = Gx(t, e, n, o, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, r, i || te.empty)))
    return !0;
  if (!i)
    return !1;
  let s = m6(i), a = s ? t.state.tr.replaceSelectionWith(s, o) : t.state.tr.replaceSelection(i);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function oC(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
qt.paste = (t, e) => {
  let n = e;
  if (t.composing && !$o)
    return;
  let o = sl ? null : n.clipboardData, r = t.input.shiftKey && t.input.lastKeyCode != 45;
  o && al(t, oC(o), o.getData("text/html"), r, n) ? n.preventDefault() : g6(t, n);
};
class rC {
  constructor(e, n, o) {
    this.slice = e, this.move = n, this.node = o;
  }
}
const v6 = Sn ? "altKey" : "ctrlKey";
function iC(t, e) {
  let n = t.someProp("dragCopies", (o) => !o(e));
  return n ?? !e[v6];
}
Gt.dragstart = (t, e) => {
  let n = e, o = t.input.mouseDown;
  if (o && o.done(), !n.dataTransfer)
    return;
  let r = t.state.selection, i = r.empty ? null : t.posAtCoords(tf(n)), s;
  if (!(i && i.pos >= r.from && i.pos <= (r instanceof de ? r.to - 1 : r.to))) {
    if (o && o.mightDrag)
      s = de.create(t.state.doc, o.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (s = de.create(t.state.doc, d.posBefore));
    }
  }
  let a = (s || t.state.selection).content(), { dom: l, text: c, slice: u } = Pg(t, a);
  (!n.dataTransfer.files.length || !Pt || Ix > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(sl ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", sl || n.dataTransfer.setData("text/plain", c), t.dragging = new rC(u, iC(t, n), s);
};
Gt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
qt.dragover = qt.dragenter = (t, e) => e.preventDefault();
qt.drop = (t, e) => {
  let n = e, o = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let r = t.posAtCoords(tf(n));
  if (!r)
    return;
  let i = t.state.doc.resolve(r.pos), s = o && o.slice;
  s ? t.someProp("transformPasted", (m) => {
    s = m(s, t);
  }) : s = Gx(t, oC(n.dataTransfer), sl ? null : n.dataTransfer.getData("text/html"), !1, i);
  let a = !!(o && iC(t, n));
  if (t.someProp("handleDrop", (m) => m(t, n, s || te.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!s)
    return;
  n.preventDefault();
  let l = s ? Sx(t.state.doc, i.pos, s) : i.pos;
  l == null && (l = i.pos);
  let c = t.state.tr;
  if (a) {
    let { node: m } = o;
    m ? m.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, s.content.firstChild) : c.replaceRange(u, u, s), c.doc.eq(f))
    return;
  let p = c.doc.resolve(u);
  if (d && de.isSelectable(s.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(s.content.firstChild))
    c.setSelection(new de(p));
  else {
    let m = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, v, y, w) => m = w), c.setSelection($g(t, p, c.doc.resolve(m)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
Gt.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Fo(t);
  }, 20));
};
Gt.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
Gt.beforeinput = (t, e) => {
  if (Pt && $o && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: o } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != o || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (i) => i(t, ri(8, "Backspace")))))
        return;
      let { $cursor: r } = t.state.selection;
      r && r.pos > 0 && t.dispatch(t.state.tr.delete(r.pos - 1, r.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in qt)
  Gt[t] = qt[t];
function ll(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class Bu {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || hi, this.side = this.spec.side || 0;
  }
  map(e, n, o, r) {
    let { pos: i, deleted: s } = e.mapResult(n.from + r, this.side < 0 ? -1 : 1);
    return s ? null : new ft(i - o, i - o, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Bu && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && ll(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class xr {
  constructor(e, n) {
    this.attrs = e, this.spec = n || hi;
  }
  map(e, n, o, r) {
    let i = e.map(n.from + r, this.spec.inclusiveStart ? -1 : 1) - o, s = e.map(n.to + r, this.spec.inclusiveEnd ? 1 : -1) - o;
    return i >= s ? null : new ft(i, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof xr && ll(this.attrs, e.attrs) && ll(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof xr;
  }
  destroy() {
  }
}
class Bg {
  constructor(e, n) {
    this.attrs = e, this.spec = n || hi;
  }
  map(e, n, o, r) {
    let i = e.mapResult(n.from + r, 1);
    if (i.deleted)
      return null;
    let s = e.mapResult(n.to + r, -1);
    return s.deleted || s.pos <= i.pos ? null : new ft(i.pos - o, s.pos - o, this);
  }
  valid(e, n) {
    let { index: o, offset: r } = e.content.findIndex(n.from), i;
    return r == n.from && !(i = e.child(o)).isText && r + i.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof Bg && ll(this.attrs, e.attrs) && ll(this.spec, e.spec);
  }
  destroy() {
  }
}
class ft {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.from = e, this.to = n, this.type = o;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new ft(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, o) {
    return this.type.map(e, this, n, o);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, o) {
    return new ft(e, e, new Bu(n, o));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, o, r) {
    return new ft(e, n, new xr(o, r));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, o, r) {
    return new ft(e, n, new Bg(o, r));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof xr;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Bu;
  }
}
const Zi = [], hi = {};
class Te {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : Zi, this.children = n.length ? n : Zi;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? Fu(n, e, 0, hi) : $t;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, o) {
    let r = [];
    return this.findInner(e ?? 0, n ?? 1e9, r, 0, o), r;
  }
  findInner(e, n, o, r, i) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= e && (!i || i(a.spec)) && o.push(a.copy(a.from + r, a.to + r));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(e - a, n - a, o, r + a, i);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, o) {
    return this == $t || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, o || hi);
  }
  /**
  @internal
  */
  mapInner(e, n, o, r, i) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, o, r);
      l && l.type.valid(n, l) ? (s || (s = [])).push(l) : i.onRemove && i.onRemove(this.local[a].spec);
    }
    return this.children.length ? y6(this.children, s || [], e, n, o, r, i) : s ? new Te(s.sort(mi), Zi) : $t;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == $t ? Te.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, o) {
    let r, i = 0;
    e.forEach((a, l) => {
      let c = l + o, u;
      if (u = aC(n, a, c)) {
        for (r || (r = this.children.slice()); i < r.length && r[i] < l; )
          i += 3;
        r[i] == l ? r[i + 2] = r[i + 2].addInner(a, u, c + 1) : r.splice(i, 0, l, l + a.nodeSize, Fu(u, a, c + 1, hi)), i += 3;
      }
    });
    let s = sC(i ? lC(n) : n, -o);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || s.splice(a--, 1);
    return new Te(s.length ? this.local.concat(s).sort(mi) : this.local, r || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == $t ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let o = this.children, r = this.local;
    for (let i = 0; i < o.length; i += 3) {
      let s, a = o[i] + n, l = o[i + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (s || (s = [])).push(d));
      if (!s)
        continue;
      o == this.children && (o = this.children.slice());
      let c = o[i + 2].removeInner(s, a + 1);
      c != $t ? o[i + 2] = c : (o.splice(i, 3), i -= 3);
    }
    if (r.length) {
      for (let i = 0, s; i < e.length; i++)
        if (s = e[i])
          for (let a = 0; a < r.length; a++)
            r[a].eq(s, n) && (r == this.local && (r = this.local.slice()), r.splice(a--, 1));
    }
    return o == this.children && r == this.local ? this : r.length || o.length ? new Te(r, o) : $t;
  }
  forChild(e, n) {
    if (this == $t)
      return this;
    if (n.isLeaf)
      return Te.empty;
    let o, r;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (o = this.children[a + 2]);
        break;
      }
    let i = e + 1, s = i + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > i && l.type instanceof xr) {
        let c = Math.max(i, l.from) - i, u = Math.min(s, l.to) - i;
        c < u && (r || (r = [])).push(l.copy(c, u));
      }
    }
    if (r) {
      let a = new Te(r.sort(mi), Zi);
      return o ? new cr([a, o]) : a;
    }
    return o || $t;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Te) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return Fg(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == $t)
      return Zi;
    if (e.inlineContent || !this.local.some(xr.is))
      return this.local;
    let n = [];
    for (let o = 0; o < this.local.length; o++)
      this.local[o].type instanceof xr || n.push(this.local[o]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
Te.empty = new Te([], []);
Te.removeOverlap = Fg;
const $t = Te.empty;
class cr {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const o = this.members.map((r) => r.map(e, n, hi));
    return cr.from(o);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Te.empty;
    let o = [];
    for (let r = 0; r < this.members.length; r++) {
      let i = this.members[r].forChild(e, n);
      i != $t && (i instanceof cr ? o = o.concat(i.members) : o.push(i));
    }
    return cr.from(o);
  }
  eq(e) {
    if (!(e instanceof cr) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, o = !0;
    for (let r = 0; r < this.members.length; r++) {
      let i = this.members[r].localsInner(e);
      if (i.length)
        if (!n)
          n = i;
        else {
          o && (n = n.slice(), o = !1);
          for (let s = 0; s < i.length; s++)
            n.push(i[s]);
        }
    }
    return n ? Fg(o ? n : n.sort(mi)) : Zi;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return $t;
      case 1:
        return e[0];
      default:
        return new cr(e.every((n) => n instanceof Te) ? e : e.reduce((n, o) => n.concat(o instanceof Te ? o : o.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function y6(t, e, n, o, r, i, s) {
  let a = t.slice();
  for (let c = 0, u = i; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, p, m, g) => {
      let v = g - m - (p - f);
      for (let y = 0; y < a.length; y += 3) {
        let w = a[y + 1];
        if (w < 0 || f > w + u - d)
          continue;
        let x = a[y] + u - d;
        p >= x ? a[y + 1] = f <= x ? -2 : -1 : f >= u && v && (a[y] += v, a[y + 1] += v);
      }
      d += v;
    }), u = n.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + i), d = u - r;
      if (d < 0 || d >= o.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + i, -1), p = f - r, { index: m, offset: g } = o.content.findIndex(d), v = o.maybeChild(m);
      if (v && g == d && g + v.nodeSize == p) {
        let y = a[c + 2].mapInner(n, v, u + 1, t[c] + i + 1, s);
        y != $t ? (a[c] = d, a[c + 1] = p, a[c + 2] = y) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = b6(a, t, e, n, r, i, s), u = Fu(c, o, 0, s);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let p = u.children[d];
      for (; f < a.length && a[f] < p; )
        f += 3;
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new Te(e.sort(mi), a);
}
function sC(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    n.push(new ft(r.from + e, r.to + e, r.type));
  }
  return n;
}
function b6(t, e, n, o, r, i, s) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(o, r, c);
      d ? n.push(d) : s.onRemove && s.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + i + 1);
  return n;
}
function aC(t, e, n) {
  if (e.isLeaf)
    return null;
  let o = n + e.nodeSize, r = null;
  for (let i = 0, s; i < t.length; i++)
    (s = t[i]) && s.from > n && s.to < o && ((r || (r = [])).push(s), t[i] = null);
  return r;
}
function lC(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function Fu(t, e, n, o) {
  let r = [], i = !1;
  e.forEach((a, l) => {
    let c = aC(t, a, l + n);
    if (c) {
      i = !0;
      let u = Fu(c, a, n + l + 1, o);
      u != $t && r.push(l, l + a.nodeSize, u);
    }
  });
  let s = sC(i ? lC(t) : t, -n).sort(mi);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(e, s[a]) || (o.onRemove && o.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || r.length ? new Te(s, r) : $t;
}
function mi(t, e) {
  return t.from - e.from || t.to - e.to;
}
function Fg(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let o = e[n];
    if (o.from != o.to)
      for (let r = n + 1; r < e.length; r++) {
        let i = e[r];
        if (i.from == o.from) {
          i.to != o.to && (e == t && (e = t.slice()), e[r] = i.copy(i.from, o.to), R0(e, r + 1, i.copy(o.to, i.to)));
          continue;
        } else {
          i.from < o.to && (e == t && (e = t.slice()), e[n] = o.copy(o.from, i.from), R0(e, r, o.copy(i.from, o.to)));
          break;
        }
      }
  }
  return e;
}
function R0(t, e, n) {
  for (; e < t.length && mi(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function gp(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let o = n(t.state);
    o && o != $t && e.push(o);
  }), t.cursorWrapper && e.push(Te.create(t.state.doc, [t.cursorWrapper.deco])), cr.from(e);
}
const w6 = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, x6 = en && br <= 11;
class C6 {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class S6 {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new C6(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((o) => {
      for (let r = 0; r < o.length; r++)
        this.queue.push(o[r]);
      en && br <= 11 && o.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), x6 && (this.onCharData = (o) => {
      this.queue.push({ target: o.target, type: "characterData", oldValue: o.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, w6)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (k0(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Fo(this.view);
      if (en && br <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && wi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), o;
    for (let i = e.focusNode; i; i = bs(i))
      n.add(i);
    for (let i = e.anchorNode; i; i = bs(i))
      if (n.has(i)) {
        o = i;
        break;
      }
    let r = o && this.view.docView.nearestDesc(o);
    if (r && r.ignoreMutation({
      type: "selection",
      target: o.nodeType == 3 ? o.parentNode : o
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let o = e.domSelectionRange(), r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(o) && k0(e) && !this.ignoreSelectionChange(o), i = -1, s = -1, a = !1, l = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l);
        d && (i = i < 0 ? d.from : Math.min(d.from, i), s = s < 0 ? d.to : Math.max(d.to, s), d.typeOver && (a = !0));
      }
    if (Wn && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let p = f.parentNode;
          p && p.nodeName == "LI" && (!d || _6(e, d) != p) && f.remove();
        }
      }
    }
    let c = null;
    i < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Qd(o) && (c = Rg(e)) && c.eq(fe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Fo(e), this.currentSelection.set(o), e.scrollToSelection()) : (i > -1 || r) && (i > -1 && (e.docView.markDirty(i, s), k6(e)), this.handleDOMChange(i, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(o) || Fo(e), this.currentSelection.set(o));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let o = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (o == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !o || o.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (o.contentDOM && o.contentDOM != o.dom && !o.contentDOM.contains(e.target))
        return { from: o.posBefore, to: o.posAfter };
      let r = e.previousSibling, i = e.nextSibling;
      if (en && br <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (r = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f);
        }
      let s = r && r.parentNode == e.target ? At(r) + 1 : 0, a = o.localPosFromDOM(e.target, s, -1), l = i && i.parentNode == e.target ? At(i) : e.target.childNodes.length, c = o.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: o.posAtStart - o.border, to: o.posAtEnd + o.border } : (this.lastChangedTextNode = e.target, {
      from: o.posAtStart,
      to: o.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let $0 = /* @__PURE__ */ new WeakMap(), P0 = !1;
function k6(t) {
  if (!$0.has(t) && ($0.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = Wn, P0)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), P0 = !0;
  }
}
function L0(t, e) {
  let n = e.startContainer, o = e.startOffset, r = e.endContainer, i = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
  return wi(s.node, s.offset, r, i) && ([n, o, r, i] = [r, i, n, o]), { anchorNode: n, anchorOffset: o, focusNode: r, focusOffset: i };
}
function E6(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return L0(t, r);
  }
  let n;
  function o(r) {
    r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", o, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", o, !0), n ? L0(t, n) : null;
}
function _6(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let o = t.docView.nearestDesc(n, !0);
    if (o && o.node.isBlock)
      return n;
  }
  return null;
}
function A6(t, e, n) {
  let { node: o, fromOffset: r, toOffset: i, from: s, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, u = l.anchorNode;
  if (u && t.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], Qd(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), Pt && t.input.lastKeyCode === 8)
    for (let v = i; v > r; v--) {
      let y = o.childNodes[v - 1], w = y.pmViewDesc;
      if (y.nodeName == "BR" && !w) {
        i = v;
        break;
      }
      if (!w || w.size)
        break;
    }
  let d = t.state.doc, f = t.someProp("domParser") || Da.fromSchema(t.state.schema), p = d.resolve(s), m = null, g = f.parse(o, {
    topNode: p.parent,
    topMatch: p.parent.contentMatchAt(p.index()),
    topOpen: !0,
    from: r,
    to: i,
    preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: T6,
    context: p
  });
  if (c && c[0].pos != null) {
    let v = c[0].pos, y = c[1] && c[1].pos;
    y == null && (y = v), m = { anchor: v + s, head: y + s };
  }
  return { doc: g, sel: m, from: s, to: a };
}
function T6(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (Kt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || Kt && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const O6 = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function M6(t, e, n, o, r) {
  let i = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let O = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, M = Rg(t, O);
    if (M && !t.state.selection.eq(M)) {
      if (Pt && $o && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (F) => F(t, ri(13, "Enter"))))
        return;
      let P = t.state.tr.setSelection(M);
      O == "pointer" ? P.setMeta("pointer", !0) : O == "key" && P.scrollIntoView(), i && P.setMeta("composition", i), t.dispatch(P);
    }
    return;
  }
  let s = t.state.doc.resolve(e), a = s.sharedDepth(n);
  e = s.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, c = A6(t, e, n), u = t.state.doc, d = u.slice(c.from, c.to), f, p;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, p = "end") : (f = t.state.selection.from, p = "start"), t.input.lastKeyCode = null;
  let m = $6(d.content, c.doc.content, c.from, f, p);
  if (m && t.input.domChangeCount++, (ws && t.input.lastIOSEnter > Date.now() - 225 || $o) && r.some((O) => O.nodeType == 1 && !O6.test(O.nodeName)) && (!m || m.endA >= m.endB) && t.someProp("handleKeyDown", (O) => O(t, ri(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!m)
    if (o && l instanceof ce && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      m = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let O = D0(t, t.state.doc, c.sel);
        if (O && !O.eq(t.state.selection)) {
          let M = t.state.tr.setSelection(O);
          i && M.setMeta("composition", i), t.dispatch(M);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && m.start == m.endB && t.state.selection instanceof ce && (m.start > t.state.selection.from && m.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? m.start = t.state.selection.from : m.endA < t.state.selection.to && m.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (m.endB += t.state.selection.to - m.endA, m.endA = t.state.selection.to)), en && br <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > c.from && c.doc.textBetween(m.start - c.from - 1, m.start - c.from + 1) == "  " && (m.start--, m.endA--, m.endB--);
  let g = c.doc.resolveNoCache(m.start - c.from), v = c.doc.resolveNoCache(m.endB - c.from), y = u.resolve(m.start), w = g.sameParent(v) && g.parent.inlineContent && y.end() >= m.endA, x;
  if ((ws && t.input.lastIOSEnter > Date.now() - 225 && (!w || r.some((O) => O.nodeName == "DIV" || O.nodeName == "P")) || !w && g.pos < c.doc.content.size && (!g.sameParent(v) || !g.parent.inlineContent) && (x = fe.findFrom(c.doc.resolve(g.pos + 1), 1, !0)) && x.head > g.pos) && t.someProp("handleKeyDown", (O) => O(t, ri(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > m.start && R6(u, m.start, m.endA, g, v) && t.someProp("handleKeyDown", (O) => O(t, ri(8, "Backspace")))) {
    $o && Pt && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Pt && m.endB == m.start && (t.input.lastChromeDelete = Date.now()), $o && !w && g.start() != v.start() && v.parentOffset == 0 && g.depth == v.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == m.endA && (m.endB -= 2, v = c.doc.resolveNoCache(m.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(O) {
      return O(t, ri(13, "Enter"));
    });
  }, 20));
  let b = m.start, S = m.endA, k, A, $;
  if (w) {
    if (g.pos == v.pos)
      en && br <= 11 && g.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Fo(t), 20)), k = t.state.tr.delete(b, S), A = u.resolve(m.start).marksAcross(u.resolve(m.endA));
    else if (
      // Adding or removing a mark
      m.endA == m.endB && ($ = I6(g.parent.content.cut(g.parentOffset, v.parentOffset), y.parent.content.cut(y.parentOffset, m.endA - y.start())))
    )
      k = t.state.tr, $.type == "add" ? k.addMark(b, S, $.mark) : k.removeMark(b, S, $.mark);
    else if (g.parent.child(g.index()).isText && g.index() == v.index() - (v.textOffset ? 0 : 1)) {
      let O = g.parent.textBetween(g.parentOffset, v.parentOffset);
      if (t.someProp("handleTextInput", (M) => M(t, b, S, O)))
        return;
      k = t.state.tr.insertText(O, b, S);
    }
  }
  if (k || (k = t.state.tr.replace(b, S, c.doc.slice(m.start - c.from, m.endB - c.from))), c.sel) {
    let O = D0(t, k.doc, c.sel);
    O && !(Pt && t.composing && O.empty && (m.start != m.endB || t.input.lastChromeDelete < Date.now() - 100) && (O.head == b || O.head == k.mapping.map(S) - 1) || en && O.empty && O.head == b) && k.setSelection(O);
  }
  A && k.ensureMarks(A), i && k.setMeta("composition", i), t.dispatch(k.scrollIntoView());
}
function D0(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : $g(t, e.resolve(n.anchor), e.resolve(n.head));
}
function I6(t, e) {
  let n = t.firstChild.marks, o = e.firstChild.marks, r = n, i = o, s, a, l;
  for (let u = 0; u < o.length; u++)
    r = o[u].removeFromSet(r);
  for (let u = 0; u < n.length; u++)
    i = n[u].removeFromSet(i);
  if (r.length == 1 && i.length == 0)
    a = r[0], s = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (r.length == 0 && i.length == 1)
    a = i[0], s = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (K.from(c).eq(t))
    return { mark: a, type: s };
}
function R6(t, e, n, o, r) {
  if (
    // The content must have shrunk
    n - e <= r.pos - o.pos || // newEnd must point directly at or after the end of the block that newStart points into
    vp(o, !0, !1) < r.pos
  )
    return !1;
  let i = t.resolve(e);
  if (!o.parent.isTextblock) {
    let a = i.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
    return !1;
  let s = t.resolve(vp(i, !0, !0));
  return !s.parent.isTextblock || s.pos > n || vp(s, !0, !1) < n ? !1 : o.parent.content.cut(o.parentOffset).eq(s.parent.content);
}
function vp(t, e, n) {
  let o = t.depth, r = e ? t.end() : t.pos;
  for (; o > 0 && (e || t.indexAfter(o) == t.node(o).childCount); )
    o--, r++, e = !1;
  if (n) {
    let i = t.node(o).maybeChild(t.indexAfter(o));
    for (; i && !i.isLeaf; )
      i = i.firstChild, r++;
  }
  return r;
}
function $6(t, e, n, o, r) {
  let i = t.findDiffStart(e, n);
  if (i == null)
    return null;
  let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (r == "end") {
    let l = Math.max(0, i - Math.min(s, a));
    o -= s + l - i;
  }
  if (s < i && t.size < e.size) {
    let l = o <= i && o >= s ? i - o : 0;
    i -= l, i && i < e.size && N0(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), a = i + (a - s), s = i;
  } else if (a < i) {
    let l = o <= i && o >= a ? i - o : 0;
    i -= l, i && i < t.size && N0(t.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), s = i + (s - a), a = i;
  }
  return { start: i, endA: s, endB: a };
}
function N0(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class P6 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ZA(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(V0), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = z0(this), F0(this), this.nodeViews = H0(this), this.docView = y0(this.state.doc, B0(this), gp(this), this.dom, this), this.domObserver = new S6(this, (o, r, i, s) => M6(this, o, r, i, s)), this.domObserver.start(), QA(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Wh(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(V0), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let o in this._props)
      n[o] = this._props[o];
    n.state = this.state;
    for (let o in e)
      n[o] = e[o];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var o;
    let r = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && (nC(this), s = !0), this.state = e;
    let a = r.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let p = H0(this);
      D6(p, this.nodeViews) && (this.nodeViews = p, i = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Wh(this), this.editable = z0(this), F0(this);
    let l = gp(this), c = B0(this), u = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", d = i || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(r.selection)) && (s = !0);
    let f = u == "preserve" && s && this.dom.style.overflowAnchor == null && pA(this);
    if (s) {
      this.domObserver.stop();
      let p = d && (en || Pt) && !this.composing && !r.selection.empty && !e.selection.empty && L6(r.selection, e.selection);
      if (d) {
        let m = Pt ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = f6(this)), (i || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = y0(e.doc, c, l, this.dom, this)), m && !this.trackWrites && (p = !0);
      }
      p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && NA(this)) ? Fo(this, p) : (jx(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), !((o = this.dragging) === null || o === void 0) && o.node && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && hA(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof de) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && f0(this, n.getBoundingClientRect(), e);
      } else
        f0(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let o = this.directPlugins[n];
        o.spec.view && this.pluginViews.push(o.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let o = this.state.plugins[n];
        o.spec.view && this.pluginViews.push(o.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let o = this.pluginViews[n];
        o.update && o.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let o = e.node, r = -1;
    if (this.state.doc.nodeAt(o.from) == o.node)
      r = o.from;
    else {
      let i = o.from + (this.state.doc.content.size - n.doc.content.size);
      (i > 0 && this.state.doc.nodeAt(i)) == o.node && (r = i);
    }
    this.dragging = new rC(e.slice, e.move, r < 0 ? void 0 : de.create(this.state.doc, r));
  }
  someProp(e, n) {
    let o = this._props && this._props[e], r;
    if (o != null && (r = n ? n(o) : o))
      return r;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[e];
      if (a != null && (r = n ? n(a) : a))
        return r;
    }
    let i = this.state.plugins;
    if (i)
      for (let s = 0; s < i.length; s++) {
        let a = i[s].props[e];
        if (a != null && (r = n ? n(a) : a))
          return r;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (en) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && mA(this.dom), Fo(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return wA(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return Dx(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, o = -1) {
    let r = this.docView.posFromDOM(e, n, o);
    if (r == null)
      throw new RangeError("DOM position not inside the editor");
    return r;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return EA(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return al(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return al(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return Pg(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (e6(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], gp(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, nA());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return n6(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Kt && this.root.nodeType === 11 && aA(this.dom.ownerDocument) == this.dom && E6(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function B0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let o in n)
        o == "class" ? e.class += " " + n[o] : o == "style" ? e.style = (e.style ? e.style + ";" : "") + n[o] : !e[o] && o != "contenteditable" && o != "nodeName" && (e[o] = String(n[o]));
  }), e.translate || (e.translate = "no"), [ft.node(0, t.state.doc.content.size, e)];
}
function F0(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: ft.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function z0(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function L6(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function H0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(o) {
    for (let r in o)
      Object.prototype.hasOwnProperty.call(e, r) || (e[r] = o[r]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function D6(t, e) {
  let n = 0, o = 0;
  for (let r in t) {
    if (t[r] != e[r])
      return !0;
    n++;
  }
  for (let r in e)
    o++;
  return n != o;
}
function V0(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var kr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, zu = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, N6 = typeof navigator < "u" && /Mac/.test(navigator.platform), B6 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Tt = 0; Tt < 10; Tt++) kr[48 + Tt] = kr[96 + Tt] = String(Tt);
for (var Tt = 1; Tt <= 24; Tt++) kr[Tt + 111] = "F" + Tt;
for (var Tt = 65; Tt <= 90; Tt++)
  kr[Tt] = String.fromCharCode(Tt + 32), zu[Tt] = String.fromCharCode(Tt);
for (var yp in kr) zu.hasOwnProperty(yp) || (zu[yp] = kr[yp]);
function F6(t) {
  var e = N6 && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || B6 && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? zu : kr)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const z6 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function H6(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let o, r, i, s;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      o = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      z6 ? s = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return o && (n = "Alt-" + n), r && (n = "Ctrl-" + n), s && (n = "Meta-" + n), i && (n = "Shift-" + n), n;
}
function V6(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[H6(n)] = t[n];
  return e;
}
function bp(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function U6(t) {
  return new De({ props: { handleKeyDown: zg(t) } });
}
function zg(t) {
  let e = V6(t);
  return function(n, o) {
    let r = F6(o), i, s = e[bp(r, o)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (r.length == 1 && r != " ") {
      if (o.shiftKey) {
        let a = e[bp(r, o, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((o.shiftKey || o.altKey || o.metaKey || r.charCodeAt(0) > 127) && (i = kr[o.keyCode]) && i != r) {
        let a = e[bp(i, o)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const zl = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function cC(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const uC = (t, e, n) => {
  let o = cC(t, n);
  if (!o)
    return !1;
  let r = Hg(o);
  if (!r) {
    let s = o.blockRange(), a = s && Fs(s);
    return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
  }
  let i = r.nodeBefore;
  if (bC(t, r, e, -1))
    return !0;
  if (o.parent.content.size == 0 && (xs(i, "end") || de.isSelectable(i)))
    for (let s = o.depth; ; s--) {
      let a = Xd(t.doc, o.before(s), o.after(s), te.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(xs(i, "end") ? fe.findFrom(l.doc.resolve(l.mapping.map(r.pos, -1)), -1) : de.create(l.doc, r.pos - i.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || o.node(s - 1).childCount > 1)
        break;
    }
  return i.isAtom && r.depth == o.depth - 1 ? (e && e(t.tr.delete(r.pos - i.nodeSize, r.pos).scrollIntoView()), !0) : !1;
}, j6 = (t, e, n) => {
  let o = cC(t, n);
  if (!o)
    return !1;
  let r = Hg(o);
  return r ? dC(t, r, e) : !1;
}, W6 = (t, e, n) => {
  let o = pC(t, n);
  if (!o)
    return !1;
  let r = Vg(o);
  return r ? dC(t, r, e) : !1;
};
function dC(t, e, n) {
  let o = e.nodeBefore, r = o, i = e.pos - 1;
  for (; !r.isTextblock; i--) {
    if (r.type.spec.isolating)
      return !1;
    let u = r.lastChild;
    if (!u)
      return !1;
    r = u;
  }
  let s = e.nodeAfter, a = s, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let u = a.firstChild;
    if (!u)
      return !1;
    a = u;
  }
  let c = Xd(t.doc, i, l, te.empty);
  if (!c || c.from != i || c instanceof bt && c.slice.size >= l - i)
    return !1;
  if (n) {
    let u = t.tr.step(c);
    u.setSelection(ce.create(u.doc, i)), n(u.scrollIntoView());
  }
  return !0;
}
function xs(t, e, n = !1) {
  for (let o = t; o; o = e == "start" ? o.firstChild : o.lastChild) {
    if (o.isTextblock)
      return !0;
    if (n && o.childCount != 1)
      return !1;
  }
  return !1;
}
const fC = (t, e, n) => {
  let { $head: o, empty: r } = t.selection, i = o;
  if (!r)
    return !1;
  if (o.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : o.parentOffset > 0)
      return !1;
    i = Hg(o);
  }
  let s = i && i.nodeBefore;
  return !s || !de.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(de.create(t.doc, i.pos - s.nodeSize)).scrollIntoView()), !0);
};
function Hg(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function pC(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const hC = (t, e, n) => {
  let o = pC(t, n);
  if (!o)
    return !1;
  let r = Vg(o);
  if (!r)
    return !1;
  let i = r.nodeAfter;
  if (bC(t, r, e, 1))
    return !0;
  if (o.parent.content.size == 0 && (xs(i, "start") || de.isSelectable(i))) {
    let s = Xd(t.doc, o.before(), o.after(), te.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        let a = t.tr.step(s);
        a.setSelection(xs(i, "start") ? fe.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1) : de.create(a.doc, a.mapping.map(r.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return i.isAtom && r.depth == o.depth - 1 ? (e && e(t.tr.delete(r.pos, r.pos + i.nodeSize).scrollIntoView()), !0) : !1;
}, mC = (t, e, n) => {
  let { $head: o, empty: r } = t.selection, i = o;
  if (!r)
    return !1;
  if (o.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : o.parentOffset < o.parent.content.size)
      return !1;
    i = Vg(o);
  }
  let s = i && i.nodeAfter;
  return !s || !de.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(de.create(t.doc, i.pos)).scrollIntoView()), !0);
};
function Vg(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const K6 = (t, e) => {
  let n = t.selection, o = n instanceof de, r;
  if (o) {
    if (n.node.isTextblock || !Lr(t.doc, n.from))
      return !1;
    r = n.from;
  } else if (r = Jd(t.doc, n.from, -1), r == null)
    return !1;
  if (e) {
    let i = t.tr.join(r);
    o && i.setSelection(de.create(i.doc, r - t.doc.resolve(r).nodeBefore.nodeSize)), e(i.scrollIntoView());
  }
  return !0;
}, G6 = (t, e) => {
  let n = t.selection, o;
  if (n instanceof de) {
    if (n.node.isTextblock || !Lr(t.doc, n.to))
      return !1;
    o = n.to;
  } else if (o = Jd(t.doc, n.to, 1), o == null)
    return !1;
  return e && e(t.tr.join(o).scrollIntoView()), !0;
}, q6 = (t, e) => {
  let { $from: n, $to: o } = t.selection, r = n.blockRange(o), i = r && Fs(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, gC = (t, e) => {
  let { $head: n, $anchor: o } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(o) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Ug(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const Y6 = (t, e) => {
  let { $head: n, $anchor: o } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(o))
    return !1;
  let r = n.node(-1), i = n.indexAfter(-1), s = Ug(r.contentMatchAt(i));
  if (!s || !r.canReplaceWith(i, i, s))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, s.createAndFill());
    l.setSelection(fe.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, vC = (t, e) => {
  let n = t.selection, { $from: o, $to: r } = n;
  if (n instanceof Wt || o.parent.inlineContent || r.parent.inlineContent)
    return !1;
  let i = Ug(r.parent.contentMatchAt(r.indexAfter()));
  if (!i || !i.isTextblock)
    return !1;
  if (e) {
    let s = (!o.parentOffset && r.index() < r.parent.childCount ? o : r).pos, a = t.tr.insert(s, i.createAndFill());
    a.setSelection(ce.create(a.doc, s + 1)), e(a.scrollIntoView());
  }
  return !0;
}, yC = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let i = n.before();
    if (Bo(t.doc, i))
      return e && e(t.tr.split(i).scrollIntoView()), !0;
  }
  let o = n.blockRange(), r = o && Fs(o);
  return r == null ? !1 : (e && e(t.tr.lift(o, r).scrollIntoView()), !0);
};
function J6(t) {
  return (e, n) => {
    let { $from: o, $to: r } = e.selection;
    if (e.selection instanceof de && e.selection.node.isBlock)
      return !o.parentOffset || !Bo(e.doc, o.pos) ? !1 : (n && n(e.tr.split(o.pos).scrollIntoView()), !0);
    if (!o.depth)
      return !1;
    let i = [], s, a, l = !1, c = !1;
    for (let p = o.depth; ; p--)
      if (o.node(p).isBlock) {
        l = o.end(p) == o.pos + (o.depth - p), c = o.start(p) == o.pos - (o.depth - p), a = Ug(o.node(p - 1).contentMatchAt(o.indexAfter(p - 1))), i.unshift(l && a ? { type: a } : null), s = p;
        break;
      } else {
        if (p == 1)
          return !1;
        i.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof ce || e.selection instanceof Wt) && u.deleteSelection();
    let d = u.mapping.map(o.pos), f = Bo(u.doc, d, i.length, i);
    if (f || (i[0] = a ? { type: a } : null, f = Bo(u.doc, d, i.length, i)), u.split(d, i.length, i), !l && c && o.node(s).type != a) {
      let p = u.mapping.map(o.before(s)), m = u.doc.resolve(p);
      a && o.node(s - 1).canReplaceWith(m.index(), m.index() + 1, a) && u.setNodeMarkup(u.mapping.map(o.before(s)), a);
    }
    return n && n(u.scrollIntoView()), !0;
  };
}
const X6 = J6(), Z6 = (t, e) => {
  let { $from: n, to: o } = t.selection, r, i = n.sharedDepth(o);
  return i == 0 ? !1 : (r = n.before(i), e && e(t.tr.setSelection(de.create(t.doc, r))), !0);
};
function Q6(t, e, n) {
  let o = e.nodeBefore, r = e.nodeAfter, i = e.index();
  return !o || !r || !o.type.compatibleContent(r.type) ? !1 : !o.content.size && e.parent.canReplace(i - 1, i) ? (n && n(t.tr.delete(e.pos - o.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(i, i + 1) || !(r.isTextblock || Lr(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function bC(t, e, n, o) {
  let r = e.nodeBefore, i = e.nodeAfter, s, a, l = r.type.spec.isolating || i.type.spec.isolating;
  if (!l && Q6(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (s = (a = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && a.matchType(s[0] || i.type).validEnd) {
    if (n) {
      let p = e.pos + i.nodeSize, m = K.empty;
      for (let y = s.length - 1; y >= 0; y--)
        m = K.from(s[y].create(null, m));
      m = K.from(r.copy(m));
      let g = t.tr.step(new wt(e.pos - 1, p, e.pos, p, new te(m, 1, 0), s.length, !0)), v = g.doc.resolve(p + 2 * s.length);
      v.nodeAfter && v.nodeAfter.type == r.type && Lr(g.doc, v.pos) && g.join(v.pos), n(g.scrollIntoView());
    }
    return !0;
  }
  let u = i.type.spec.isolating || o > 0 && l ? null : fe.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Fs(d);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
  if (c && xs(i, "start", !0) && xs(r, "end")) {
    let p = r, m = [];
    for (; m.push(p), !p.isTextblock; )
      p = p.lastChild;
    let g = i, v = 1;
    for (; !g.isTextblock; g = g.firstChild)
      v++;
    if (p.canReplace(p.childCount, p.childCount, g.content)) {
      if (n) {
        let y = K.empty;
        for (let x = m.length - 1; x >= 0; x--)
          y = K.from(m[x].copy(y));
        let w = t.tr.step(new wt(e.pos - m.length, e.pos + i.nodeSize, e.pos + v, e.pos + i.nodeSize - v, new te(y, m.length, 0), 0, !0));
        n(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function wC(t) {
  return function(e, n) {
    let o = e.selection, r = t < 0 ? o.$from : o.$to, i = r.depth;
    for (; r.node(i).isInline; ) {
      if (!i)
        return !1;
      i--;
    }
    return r.node(i).isTextblock ? (n && n(e.tr.setSelection(ce.create(e.doc, t < 0 ? r.start(i) : r.end(i)))), !0) : !1;
  };
}
const e8 = wC(-1), t8 = wC(1);
function n8(t, e = null) {
  return function(n, o) {
    let { $from: r, $to: i } = n.selection, s = r.blockRange(i), a = s && Ag(s, t, e);
    return a ? (o && o(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function U0(t, e = null) {
  return function(n, o) {
    let r = !1;
    for (let i = 0; i < n.selection.ranges.length && !r; i++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[i];
      n.doc.nodesBetween(s, a, (l, c) => {
        if (r)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            r = !0;
          else {
            let u = n.doc.resolve(c), d = u.index();
            r = u.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!r)
      return !1;
    if (o) {
      let i = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
        i.setBlockType(a, l, t, e);
      }
      o(i.scrollIntoView());
    }
    return !0;
  };
}
function jg(...t) {
  return function(e, n, o) {
    for (let r = 0; r < t.length; r++)
      if (t[r](e, n, o))
        return !0;
    return !1;
  };
}
jg(zl, uC, fC);
jg(zl, hC, mC);
jg(gC, vC, yC, X6);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function o8(t, e = null) {
  return function(n, o) {
    let { $from: r, $to: i } = n.selection, s = r.blockRange(i);
    if (!s)
      return !1;
    let a = o ? n.tr : null;
    return r8(a, s, t, e) ? (o && o(a.scrollIntoView()), !0) : !1;
  };
}
function r8(t, e, n, o = null) {
  let r = !1, i = e, s = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = s.resolve(e.start - 2);
    i = new nl(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new nl(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), r = !0;
  }
  let a = Ag(i, n, o, e);
  return a ? (t && i8(t, e, a, r, n), !0) : !1;
}
function i8(t, e, n, o, r) {
  let i = K.empty;
  for (let u = n.length - 1; u >= 0; u--)
    i = K.from(n[u].type.create(n[u].attrs, i));
  t.step(new wt(e.start - (o ? 2 : 0), e.end, e.start, e.end, new te(i, 0, 0), n.length, !0));
  let s = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == r && (s = u + 1);
  let a = n.length - s, l = e.start + n.length - (o ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
    !f && Bo(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
  return t;
}
function s8(t) {
  return function(e, n) {
    let { $from: o, $to: r } = e.selection, i = o.blockRange(r, (s) => s.childCount > 0 && s.firstChild.type == t);
    return i ? n ? o.node(i.depth - 1).type == t ? a8(e, n, t, i) : l8(e, n, i) : !0 : !1;
  };
}
function a8(t, e, n, o) {
  let r = t.tr, i = o.end, s = o.$to.end(o.depth);
  i < s && (r.step(new wt(i - 1, s, i, s, new te(K.from(n.create(null, o.parent.copy())), 1, 0), 1, !0)), o = new nl(r.doc.resolve(o.$from.pos), r.doc.resolve(s), o.depth));
  const a = Fs(o);
  if (a == null)
    return !1;
  r.lift(o, a);
  let l = r.doc.resolve(r.mapping.map(i, -1) - 1);
  return Lr(r.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && r.join(l.pos), e(r.scrollIntoView()), !0;
}
function l8(t, e, n) {
  let o = t.tr, r = n.parent;
  for (let p = n.end, m = n.endIndex - 1, g = n.startIndex; m > g; m--)
    p -= r.child(m).nodeSize, o.delete(p - 1, p + 1);
  let i = o.doc.resolve(n.start), s = i.nodeAfter;
  if (o.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == r.childCount, c = i.node(-1), u = i.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? K.empty : K.from(r))))
    return !1;
  let d = i.pos, f = d + s.nodeSize;
  return o.step(new wt(d - (a ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new te((a ? K.empty : K.from(r.copy(K.empty))).append(l ? K.empty : K.from(r.copy(K.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(o.scrollIntoView()), !0;
}
function c8(t) {
  return function(e, n) {
    let { $from: o, $to: r } = e.selection, i = o.blockRange(r, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!i)
      return !1;
    let s = i.startIndex;
    if (s == 0)
      return !1;
    let a = i.parent, l = a.child(s - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, u = K.from(c ? t.create() : null), d = new te(K.from(t.create(null, K.from(a.type.create(null, u)))), c ? 3 : 1, 0), f = i.start, p = i.end;
      n(e.tr.step(new wt(f - (c ? 3 : 1), p, f, p, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function nf(t) {
  const { state: e, transaction: n } = t;
  let { selection: o } = n, { doc: r } = n, { storedMarks: i } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return i;
    },
    get selection() {
      return o;
    },
    get doc() {
      return r;
    },
    get tr() {
      return o = n.selection, r = n.doc, i = n.storedMarks, n;
    }
  };
}
class of {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: o } = this, { view: r } = n, { tr: i } = o, s = this.buildProps(i);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
      const d = l(...u)(s);
      return !i.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(i), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: o, editor: r, state: i } = this, { view: s } = r, a = [], l = !!e, c = e || i.tr, u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c), a.every((f) => f === !0)), d = {
      ...Object.fromEntries(Object.entries(o).map(([f, p]) => [f, (...g) => {
        const v = this.buildProps(c, n), y = p(...g)(v);
        return a.push(y), d;
      }])),
      run: u
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: o } = this, r = !1, i = e || o.tr, s = this.buildProps(i, r);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...s, dispatch: void 0 })])),
      chain: () => this.createChain(i, r)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: o, editor: r, state: i } = this, { view: s } = r, a = {
      tr: e,
      editor: r,
      view: s,
      state: nf({
        state: i,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(o).map(([l, c]) => [l, (...u) => c(...u)(a)]));
      }
    };
    return a;
  }
}
class u8 {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const o = this.callbacks[e];
    return o && o.forEach((r) => r.apply(this, n)), this;
  }
  off(e, n) {
    const o = this.callbacks[e];
    return o && (n ? this.callbacks[e] = o.filter((r) => r !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const o = (...r) => {
      this.off(e, o), n.apply(this, r);
    };
    return this.on(e, o);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function ie(t, e, n) {
  return t.config[e] === void 0 && t.parent ? ie(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? ie(t.parent, e, n) : null
  }) : t.config[e];
}
function rf(t) {
  const e = t.filter((r) => r.type === "extension"), n = t.filter((r) => r.type === "node"), o = t.filter((r) => r.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: o
  };
}
function xC(t) {
  const e = [], { nodeExtensions: n, markExtensions: o } = rf(t), r = [...n, ...o], i = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: r
    }, l = ie(s, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, p]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...i,
              ...p
            }
          });
        });
      });
    });
  }), r.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = ie(s, "addAttributes", a);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...i,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: s.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function Ct(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Le(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const o = { ...e };
    return Object.entries(n).forEach(([r, i]) => {
      if (!o[r]) {
        o[r] = i;
        return;
      }
      if (r === "class") {
        const a = i ? String(i).split(" ") : [], l = o[r] ? o[r].split(" ") : [], c = a.filter((u) => !l.includes(u));
        o[r] = [...l, ...c].join(" ");
      } else if (r === "style") {
        const a = i ? i.split(";").map((u) => u.trim()).filter(Boolean) : [], l = o[r] ? o[r].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((p) => p.trim());
          c.set(d, f);
        }), a.forEach((u) => {
          const [d, f] = u.split(":").map((p) => p.trim());
          c.set(d, f);
        }), o[r] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        o[r] = i;
    }), o;
  }, {});
}
function Kh(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, o) => Le(n, o), {});
}
function CC(t) {
  return typeof t == "function";
}
function Se(t, e = void 0, ...n) {
  return CC(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function d8(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function f8(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function j0(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const o = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (o === !1)
        return !1;
      const r = e.reduce((i, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : f8(n.getAttribute(s.name));
        return a == null ? i : {
          ...i,
          [s.name]: a
        };
      }, {});
      return { ...o, ...r };
    }
  };
}
function W0(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && d8(n) ? !1 : n != null)
  );
}
function p8(t, e) {
  var n;
  const o = xC(t), { nodeExtensions: r, markExtensions: i } = rf(t), s = (n = r.find((c) => ie(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(r.map((c) => {
    const u = o.filter((y) => y.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((y, w) => {
      const x = ie(w, "extendNodeSchema", d);
      return {
        ...y,
        ...x ? x(c) : {}
      };
    }, {}), p = W0({
      ...f,
      content: Se(ie(c, "content", d)),
      marks: Se(ie(c, "marks", d)),
      group: Se(ie(c, "group", d)),
      inline: Se(ie(c, "inline", d)),
      atom: Se(ie(c, "atom", d)),
      selectable: Se(ie(c, "selectable", d)),
      draggable: Se(ie(c, "draggable", d)),
      code: Se(ie(c, "code", d)),
      whitespace: Se(ie(c, "whitespace", d)),
      linebreakReplacement: Se(ie(c, "linebreakReplacement", d)),
      defining: Se(ie(c, "defining", d)),
      isolating: Se(ie(c, "isolating", d)),
      attrs: Object.fromEntries(u.map((y) => {
        var w;
        return [y.name, { default: (w = y == null ? void 0 : y.attribute) === null || w === void 0 ? void 0 : w.default }];
      }))
    }), m = Se(ie(c, "parseHTML", d));
    m && (p.parseDOM = m.map((y) => j0(y, u)));
    const g = ie(c, "renderHTML", d);
    g && (p.toDOM = (y) => g({
      node: y,
      HTMLAttributes: Kh(y, u)
    }));
    const v = ie(c, "renderText", d);
    return v && (p.toText = v), [c.name, p];
  })), l = Object.fromEntries(i.map((c) => {
    const u = o.filter((v) => v.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((v, y) => {
      const w = ie(y, "extendMarkSchema", d);
      return {
        ...v,
        ...w ? w(c) : {}
      };
    }, {}), p = W0({
      ...f,
      inclusive: Se(ie(c, "inclusive", d)),
      excludes: Se(ie(c, "excludes", d)),
      group: Se(ie(c, "group", d)),
      spanning: Se(ie(c, "spanning", d)),
      code: Se(ie(c, "code", d)),
      attrs: Object.fromEntries(u.map((v) => {
        var y;
        return [v.name, { default: (y = v == null ? void 0 : v.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), m = Se(ie(c, "parseHTML", d));
    m && (p.parseDOM = m.map((v) => j0(v, u)));
    const g = ie(c, "renderHTML", d);
    return g && (p.toDOM = (v) => g({
      mark: v,
      HTMLAttributes: Kh(v, u)
    })), [c.name, p];
  }));
  return new fx({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function wp(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function K0(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function Wg(t, e) {
  const n = Pr.fromSchema(e).serializeFragment(t), r = document.implementation.createHTMLDocument().createElement("div");
  return r.appendChild(n), r.innerHTML;
}
const h8 = (t, e = 500) => {
  let n = "";
  const o = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, o - e), o, (r, i, s, a) => {
    var l, c;
    const u = ((c = (l = r.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: r,
      pos: i,
      parent: s,
      index: a
    })) || r.textContent || "%leaf%";
    n += r.isAtom && !r.isText ? u : u.slice(0, Math.max(0, o - i));
  }), n;
};
function Kg(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class sf {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const m8 = (t, e) => {
  if (Kg(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const o = [n.text];
  return o.index = n.index, o.input = t, o.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), o.push(n.replaceWith)), o;
};
function yc(t) {
  var e;
  const { editor: n, from: o, to: r, text: i, rules: s, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(o);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = h8(c) + i;
  return s.forEach((f) => {
    if (u)
      return;
    const p = m8(d, f.find);
    if (!p)
      return;
    const m = l.state.tr, g = nf({
      state: l.state,
      transaction: m
    }), v = {
      from: o - (p[0].length - i.length),
      to: r
    }, { commands: y, chain: w, can: x } = new of({
      editor: n,
      state: g
    });
    f.handler({
      state: g,
      range: v,
      match: p,
      commands: y,
      chain: w,
      can: x
    }) === null || !m.steps.length || (m.setMeta(a, {
      transform: m,
      from: o,
      to: r,
      text: i
    }), l.dispatch(m), u = !0);
  }), u;
}
function g8(t) {
  const { editor: e, rules: n } = t, o = new De({
    state: {
      init() {
        return null;
      },
      apply(r, i, s) {
        const a = r.getMeta(o);
        if (a)
          return a;
        const l = r.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: u } = l;
          typeof u == "string" ? u = u : u = Wg(K.from(u), s.schema);
          const { from: d } = l, f = d + u.length;
          yc({
            editor: e,
            from: d,
            to: f,
            text: u,
            rules: n,
            plugin: o
          });
        }), r.selectionSet || r.docChanged ? null : i;
      }
    },
    props: {
      handleTextInput(r, i, s, a) {
        return yc({
          editor: e,
          from: i,
          to: s,
          text: a,
          rules: n,
          plugin: o
        });
      },
      handleDOMEvents: {
        compositionend: (r) => (setTimeout(() => {
          const { $cursor: i } = r.state.selection;
          i && yc({
            editor: e,
            from: i.pos,
            to: i.pos,
            text: "",
            rules: n,
            plugin: o
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(r, i) {
        if (i.key !== "Enter")
          return !1;
        const { $cursor: s } = r.state.selection;
        return s ? yc({
          editor: e,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: o
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return o;
}
function v8(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function bc(t) {
  return v8(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function af(t, e) {
  const n = { ...t };
  return bc(t) && bc(e) && Object.keys(e).forEach((o) => {
    bc(e[o]) && bc(t[o]) ? n[o] = af(t[o], e[o]) : n[o] = e[o];
  }), n;
}
class on {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Se(ie(this, "addOptions", {
      name: this.name
    }))), this.storage = Se(ie(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new on(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => af(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new on(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Se(ie(n, "addOptions", {
      name: n.name
    })), n.storage = Se(ie(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: o } = e.state, r = e.state.selection.$from;
    if (r.pos === r.end()) {
      const s = r.marks();
      if (!!!s.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = s.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && o.removeStoredMark(l), o.insertText(" ", r.pos), e.view.dispatch(o), !0;
    }
    return !1;
  }
}
function y8(t) {
  return typeof t == "number";
}
class b8 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const w8 = (t, e, n) => {
  if (Kg(e))
    return [...t.matchAll(e)];
  const o = e(t, n);
  return o ? o.map((r) => {
    const i = [r.text];
    return i.index = r.index, i.input = t, i.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(r.replaceWith)), i;
  }) : [];
};
function x8(t) {
  const { editor: e, state: n, from: o, to: r, rule: i, pasteEvent: s, dropEvent: a } = t, { commands: l, chain: c, can: u } = new of({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(o, r, (p, m) => {
    if (!p.isTextblock || p.type.spec.code)
      return;
    const g = Math.max(o, m), v = Math.min(r, m + p.content.size), y = p.textBetween(g - m, v - m, void 0, "￼");
    w8(y, i.find, s).forEach((x) => {
      if (x.index === void 0)
        return;
      const b = g + x.index + 1, S = b + x[0].length, k = {
        from: n.tr.mapping.map(b),
        to: n.tr.mapping.map(S)
      }, A = i.handler({
        state: n,
        range: k,
        match: x,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: s,
        dropEvent: a
      });
      d.push(A);
    });
  }), d.every((p) => p !== null);
}
let wc = null;
const C8 = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function S8(t) {
  const { editor: e, rules: n } = t;
  let o = null, r = !1, i = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: u, from: d, to: f, rule: p, pasteEvt: m }) => {
    const g = u.tr, v = nf({
      state: u,
      transaction: g
    });
    if (!(!x8({
      editor: e,
      state: v,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: p,
      pasteEvent: m,
      dropEvent: a
    }) || !g.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, g;
    }
  };
  return n.map((u) => new De({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (m) => {
        var g;
        o = !((g = d.dom.parentElement) === null || g === void 0) && g.contains(m.target) ? d.dom.parentElement : null, o && (wc = e);
      }, p = () => {
        wc && (wc = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", p), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", p);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (i = o === d.dom.parentElement, a = f, !i) {
            const p = wc;
            p && setTimeout(() => {
              const m = p.state.selection;
              m && p.commands.deleteRange({ from: m.from, to: m.to });
            }, 10);
          }
          return !1;
        },
        paste: (d, f) => {
          var p;
          const m = (p = f.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html");
          return s = f, r = !!(m != null && m.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, f, p) => {
      const m = d[0], g = m.getMeta("uiEvent") === "paste" && !r, v = m.getMeta("uiEvent") === "drop" && !i, y = m.getMeta("applyPasteRules"), w = !!y;
      if (!g && !v && !w)
        return;
      if (w) {
        let { text: S } = y;
        typeof S == "string" ? S = S : S = Wg(K.from(S), p.schema);
        const { from: k } = y, A = k + S.length, $ = C8(S);
        return l({
          rule: u,
          state: p,
          from: k,
          to: { b: A },
          pasteEvt: $
        });
      }
      const x = f.doc.content.findDiffStart(p.doc.content), b = f.doc.content.findDiffEnd(p.doc.content);
      if (!(!y8(x) || !b || x === b.b))
        return l({
          rule: u,
          state: p,
          from: x,
          to: b,
          pasteEvt: s
        });
    }
  }));
}
function k8(t) {
  const e = t.filter((n, o) => t.indexOf(n) !== o);
  return Array.from(new Set(e));
}
class ss {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = ss.resolve(e), this.schema = p8(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = ss.sort(ss.flatten(e)), o = k8(n.map((r) => r.name));
    return o.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${o.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const o = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, r = ie(n, "addExtensions", o);
      return r ? [n, ...this.flatten(r())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((o, r) => {
      const i = ie(o, "priority") || 100, s = ie(r, "priority") || 100;
      return i > s ? -1 : i < s ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const o = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: wp(n.name, this.schema)
      }, r = ie(n, "addCommands", o);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = ss.sort([...this.extensions].reverse()), o = [], r = [], i = n.map((s) => {
      const a = {
        name: s.name,
        options: s.options,
        storage: s.storage,
        editor: e,
        type: wp(s.name, this.schema)
      }, l = [], c = ie(s, "addKeyboardShortcuts", a);
      let u = {};
      if (s.type === "mark" && ie(s, "exitable", a) && (u.ArrowRight = () => on.handleExit({ editor: e, mark: s })), c) {
        const g = Object.fromEntries(Object.entries(c()).map(([v, y]) => [v, () => y({ editor: e })]));
        u = { ...u, ...g };
      }
      const d = U6(u);
      l.push(d);
      const f = ie(s, "addInputRules", a);
      K0(s, e.options.enableInputRules) && f && o.push(...f());
      const p = ie(s, "addPasteRules", a);
      K0(s, e.options.enablePasteRules) && p && r.push(...p());
      const m = ie(s, "addProseMirrorPlugins", a);
      if (m) {
        const g = m();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      g8({
        editor: e,
        rules: o
      }),
      ...S8({
        editor: e,
        rules: r
      }),
      ...i
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return xC(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = rf(this.extensions);
    return Object.fromEntries(n.filter((o) => !!ie(o, "addNodeView")).map((o) => {
      const r = this.attributes.filter((l) => l.type === o.name), i = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: Ct(o.name, this.schema)
      }, s = ie(o, "addNodeView", i);
      if (!s)
        return [];
      const a = (l, c, u, d, f) => {
        const p = Kh(l, r);
        return s()({
          // pass-through
          node: l,
          view: c,
          getPos: u,
          decorations: d,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: o,
          HTMLAttributes: p
        });
      };
      return [o.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const o = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: wp(e.name, this.schema)
      };
      e.type === "mark" && (!((n = Se(ie(e, "keepOnSplit", o))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const r = ie(e, "onBeforeCreate", o), i = ie(e, "onCreate", o), s = ie(e, "onUpdate", o), a = ie(e, "onSelectionUpdate", o), l = ie(e, "onTransaction", o), c = ie(e, "onFocus", o), u = ie(e, "onBlur", o), d = ie(e, "onDestroy", o);
      r && this.editor.on("beforeCreate", r), i && this.editor.on("create", i), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
}
class ke {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Se(ie(this, "addOptions", {
      name: this.name
    }))), this.storage = Se(ie(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new ke(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => af(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new ke({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Se(ie(n, "addOptions", {
      name: n.name
    })), n.storage = Se(ie(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function SC(t, e, n) {
  const { from: o, to: r } = e, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return t.nodesBetween(o, r, (l, c, u, d) => {
    var f;
    l.isBlock && c > o && (a += i);
    const p = s == null ? void 0 : s[l.type.name];
    if (p)
      return u && (a += p({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(o, c) - c, r - c));
  }), a;
}
function Gg(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const E8 = ke.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: o, selection: r } = e, { ranges: i } = r, s = Math.min(...i.map((u) => u.$from.pos)), a = Math.max(...i.map((u) => u.$to.pos)), l = Gg(n);
            return SC(o, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), _8 = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), A8 = (t = !1) => ({ commands: e }) => e.setContent("", t), T8 = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: o } = e, { ranges: r } = o;
  return n && r.forEach(({ $from: i, $to: s }) => {
    t.doc.nodesBetween(i.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), p = d.blockRange(f);
      if (!p)
        return;
      const m = Fs(p);
      if (a.type.isTextblock) {
        const { defaultType: g } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(p.start, g);
      }
      (m || m === 0) && e.lift(p, m);
    });
  }), !0;
}, O8 = (t) => (e) => t(e), M8 = () => ({ state: t, dispatch: e }) => vC(t, e), I8 = (t, e) => ({ editor: n, tr: o }) => {
  const { state: r } = n, i = r.doc.slice(t.from, t.to);
  o.deleteRange(t.from, t.to);
  const s = o.mapping.map(e);
  return o.insert(s, i.content), o.setSelection(new ce(o.doc.resolve(s - 1))), !0;
}, R8 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, o = n.$anchor.node();
  if (o.content.size > 0)
    return !1;
  const r = t.selection.$anchor;
  for (let i = r.depth; i > 0; i -= 1)
    if (r.node(i).type === o.type) {
      if (e) {
        const a = r.before(i), l = r.after(i);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, $8 = (t) => ({ tr: e, state: n, dispatch: o }) => {
  const r = Ct(t, n.schema), i = e.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === r) {
      if (o) {
        const l = i.before(s), c = i.after(s);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, P8 = (t) => ({ tr: e, dispatch: n }) => {
  const { from: o, to: r } = t;
  return n && e.delete(o, r), !0;
}, L8 = () => ({ state: t, dispatch: e }) => zl(t, e), D8 = () => ({ commands: t }) => t.keyboardShortcut("Enter"), N8 = () => ({ state: t, dispatch: e }) => Y6(t, e);
function Hu(t, e, n = { strict: !0 }) {
  const o = Object.keys(e);
  return o.length ? o.every((r) => n.strict ? e[r] === t[r] : Kg(e[r]) ? e[r].test(t[r]) : e[r] === t[r]) : !0;
}
function kC(t, e, n = {}) {
  return t.find((o) => o.type === e && Hu(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((r) => [r, o.attrs[r]])),
    n
  ));
}
function G0(t, e, n = {}) {
  return !!kC(t, e, n);
}
function lf(t, e, n) {
  var o;
  if (!t || !e)
    return;
  let r = t.parent.childAfter(t.parentOffset);
  if ((!r.node || !r.node.marks.some((u) => u.type === e)) && (r = t.parent.childBefore(t.parentOffset)), !r.node || !r.node.marks.some((u) => u.type === e) || (n = n || ((o = r.node.marks[0]) === null || o === void 0 ? void 0 : o.attrs), !kC([...r.node.marks], e, n)))
    return;
  let s = r.index, a = t.start() + r.offset, l = s + 1, c = a + r.node.nodeSize;
  for (; s > 0 && G0([...t.parent.child(s - 1).marks], e, n); )
    s -= 1, a -= t.parent.child(s).nodeSize;
  for (; l < t.parent.childCount && G0([...t.parent.child(l).marks], e, n); )
    c += t.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function Nr(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const B8 = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  const i = Nr(t, o.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (r) {
    const d = lf(l, i, e);
    if (d && d.from <= c && d.to >= u) {
      const f = ce.create(s, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, F8 = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let o = 0; o < n.length; o += 1)
    if (n[o](e))
      return !0;
  return !1;
};
function qg(t) {
  return t instanceof ce;
}
function Po(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function EC(t, e = null) {
  if (!e)
    return null;
  const n = fe.atStart(t), o = fe.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return o;
  const r = n.from, i = o.to;
  return e === "all" ? ce.create(t, Po(0, r, i), Po(t.content.size, r, i)) : ce.create(t, Po(e, r, i), Po(e, r, i));
}
function _C() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function cf() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const z8 = (t = null, e = {}) => ({ editor: n, view: o, tr: r, dispatch: i }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const s = () => {
    (cf() || _C()) && o.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (o.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (o.hasFocus() && t === null || t === !1)
    return !0;
  if (i && t === null && !qg(n.state.selection))
    return s(), !0;
  const a = EC(r.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return i && (l || r.setSelection(a), l && r.storedMarks && r.setStoredMarks(r.storedMarks), s()), !0;
}, H8 = (t, e) => (n) => t.every((o, r) => e(o, { ...n, index: r })), V8 = (t, e) => ({ tr: n, commands: o }) => o.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), AC = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const o = e[n];
    o.nodeType === 3 && o.nodeValue && /^(\n\s\s|\n)$/.test(o.nodeValue) ? t.removeChild(o) : o.nodeType === 1 && AC(o);
  }
  return t;
};
function xc(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return AC(n);
}
function Vu(t, e, n) {
  if (t instanceof yr || t instanceof K)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const o = typeof t == "object" && t !== null, r = typeof t == "string";
  if (o)
    try {
      if (Array.isArray(t) && t.length > 0)
        return K.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", i), Vu("", e, n);
    }
  if (r) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new fx({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Da.fromSchema(l).parseSlice(xc(t), n.parseOptions) : Da.fromSchema(l).parse(xc(t), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const i = Da.fromSchema(e);
    return n.slice ? i.parseSlice(xc(t), n.parseOptions).content : i.parse(xc(t), n.parseOptions);
  }
  return Vu("", e, n);
}
function U8(t, e, n) {
  const o = t.steps.length - 1;
  if (o < e)
    return;
  const r = t.steps[o];
  if (!(r instanceof bt || r instanceof wt))
    return;
  const i = t.mapping.maps[o];
  let s = 0;
  i.forEach((a, l, c, u) => {
    s === 0 && (s = u);
  }), t.setSelection(fe.near(t.doc.resolve(s), n));
}
const j8 = (t) => !("type" in t), W8 = (t, e, n) => ({ tr: o, dispatch: r, editor: i }) => {
  var s;
  if (r) {
    n = {
      parseOptions: i.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    try {
      a = Vu(e, i.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== void 0 ? s : i.options.enableContentCheck
      });
    } catch (m) {
      return i.emit("contentError", {
        editor: i,
        error: m,
        disableCollaboration: () => {
          i.storage.collaboration && (i.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: l, to: c } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, u = !0, d = !0;
    if ((j8(a) ? a : [a]).forEach((m) => {
      m.check(), u = u ? m.isText && m.marks.length === 0 : !1, d = d ? m.isBlock : !1;
    }), l === c && d) {
      const { parent: m } = o.doc.resolve(l);
      m.isTextblock && !m.type.spec.code && !m.childCount && (l -= 1, c += 1);
    }
    let p;
    if (u) {
      if (Array.isArray(e))
        p = e.map((m) => m.text || "").join("");
      else if (e instanceof K) {
        let m = "";
        e.forEach((g) => {
          g.text && (m += g.text);
        }), p = m;
      } else typeof e == "object" && e && e.text ? p = e.text : p = e;
      o.insertText(p, l, c);
    } else
      p = a, o.replaceWith(l, c, p);
    n.updateSelection && U8(o, o.steps.length - 1, -1), n.applyInputRules && o.setMeta("applyInputRules", { from: l, text: p }), n.applyPasteRules && o.setMeta("applyPasteRules", { from: l, text: p });
  }
  return !0;
}, K8 = () => ({ state: t, dispatch: e }) => K6(t, e), G8 = () => ({ state: t, dispatch: e }) => G6(t, e), q8 = () => ({ state: t, dispatch: e }) => uC(t, e), Y8 = () => ({ state: t, dispatch: e }) => hC(t, e), J8 = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const o = Jd(t.doc, t.selection.$from.pos, -1);
    return o == null ? !1 : (n.join(o, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, X8 = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const o = Jd(t.doc, t.selection.$from.pos, 1);
    return o == null ? !1 : (n.join(o, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, Z8 = () => ({ state: t, dispatch: e }) => j6(t, e), Q8 = () => ({ state: t, dispatch: e }) => W6(t, e);
function TC() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function eT(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let o, r, i, s;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      o = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      cf() || TC() ? s = !0 : r = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return o && (n = `Alt-${n}`), r && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
}
const tT = (t) => ({ editor: e, view: n, tr: o, dispatch: r }) => {
  const i = eT(t).split(/-(?!$)/), s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: i.includes("Alt"),
    ctrlKey: i.includes("Ctrl"),
    metaKey: i.includes("Meta"),
    shiftKey: i.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(o.mapping);
    u && r && o.maybeStep(u);
  }), !0;
};
function cl(t, e, n = {}) {
  const { from: o, to: r, empty: i } = t.selection, s = e ? Ct(e, t.schema) : null, a = [];
  t.doc.nodesBetween(o, r, (d, f) => {
    if (d.isText)
      return;
    const p = Math.max(o, f), m = Math.min(r, f + d.nodeSize);
    a.push({
      node: d,
      from: p,
      to: m
    });
  });
  const l = r - o, c = a.filter((d) => s ? s.name === d.node.type.name : !0).filter((d) => Hu(d.node.attrs, n, { strict: !1 }));
  return i ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
const nT = (t, e = {}) => ({ state: n, dispatch: o }) => {
  const r = Ct(t, n.schema);
  return cl(n, r, e) ? q6(n, o) : !1;
}, oT = () => ({ state: t, dispatch: e }) => yC(t, e), rT = (t) => ({ state: e, dispatch: n }) => {
  const o = Ct(t, e.schema);
  return s8(o)(e, n);
}, iT = () => ({ state: t, dispatch: e }) => gC(t, e);
function uf(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function q0(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((o, r) => (n.includes(r) || (o[r] = t[r]), o), {});
}
const sT = (t, e) => ({ tr: n, state: o, dispatch: r }) => {
  let i = null, s = null;
  const a = uf(typeof t == "string" ? t : t.name, o.schema);
  return a ? (a === "node" && (i = Ct(t, o.schema)), a === "mark" && (s = Nr(t, o.schema)), r && n.selection.ranges.forEach((l) => {
    o.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
      i && i === c.type && n.setNodeMarkup(u, void 0, q0(c.attrs, e)), s && c.marks.length && c.marks.forEach((d) => {
        s === d.type && n.addMark(u, u + c.nodeSize, s.create(q0(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, aT = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), lT = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const n = new Wt(t.doc);
    t.setSelection(n);
  }
  return !0;
}, cT = () => ({ state: t, dispatch: e }) => fC(t, e), uT = () => ({ state: t, dispatch: e }) => mC(t, e), dT = () => ({ state: t, dispatch: e }) => Z6(t, e), fT = () => ({ state: t, dispatch: e }) => t8(t, e), pT = () => ({ state: t, dispatch: e }) => e8(t, e);
function Gh(t, e, n = {}, o = {}) {
  return Vu(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: o.errorOnInvalidContent
  });
}
const hT = (t, e = !1, n = {}, o = {}) => ({ editor: r, tr: i, dispatch: s, commands: a }) => {
  var l, c;
  const { doc: u } = i;
  if (n.preserveWhitespace !== "full") {
    const d = Gh(t, r.schema, n, {
      errorOnInvalidContent: (l = o.errorOnInvalidContent) !== null && l !== void 0 ? l : r.options.enableContentCheck
    });
    return s && i.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), !0;
  }
  return s && i.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (c = o.errorOnInvalidContent) !== null && c !== void 0 ? c : r.options.enableContentCheck
  });
};
function Yg(t, e) {
  const n = Nr(e, t.schema), { from: o, to: r, empty: i } = t.selection, s = [];
  i ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks())) : t.doc.nodesBetween(o, r, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function mT(t, e) {
  const n = new Tg(t);
  return e.forEach((o) => {
    o.steps.forEach((r) => {
      n.step(r);
    });
  }), n;
}
function gT(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function vT(t, e, n) {
  const o = [];
  return t.nodesBetween(e.from, e.to, (r, i) => {
    n(r) && o.push({
      node: r,
      pos: i
    });
  }), o;
}
function OC(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const o = t.node(n);
    if (e(o))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: o
      };
  }
}
function Jg(t) {
  return (e) => OC(e.$from, t);
}
function MC(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return SC(t, n, e);
}
function yT(t, e) {
  const n = Ct(e, t.schema), { from: o, to: r } = t.selection, i = [];
  t.doc.nodesBetween(o, r, (a) => {
    i.push(a);
  });
  const s = i.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function IC(t, e) {
  const n = uf(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? yT(t, e) : n === "mark" ? Yg(t, e) : {};
}
function bT(t, e = JSON.stringify) {
  const n = {};
  return t.filter((o) => {
    const r = e(o);
    return Object.prototype.hasOwnProperty.call(n, r) ? !1 : n[r] = !0;
  });
}
function wT(t) {
  const e = bT(t);
  return e.length === 1 ? e : e.filter((n, o) => !e.filter((i, s) => s !== o).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
}
function xT(t) {
  const { mapping: e, steps: n } = t, o = [];
  return e.maps.forEach((r, i) => {
    const s = [];
    if (r.ranges.length)
      r.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[i];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const c = e.slice(i).map(a, -1), u = e.slice(i).map(l), d = e.invert().map(c, -1), f = e.invert().map(u);
      o.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), wT(o);
}
function Xg(t, e, n) {
  const o = [];
  return t === e ? n.resolve(t).marks().forEach((r) => {
    const i = n.resolve(t), s = lf(i, r.type);
    s && o.push({
      mark: r,
      ...s
    });
  }) : n.nodesBetween(t, e, (r, i) => {
    !r || (r == null ? void 0 : r.nodeSize) === void 0 || o.push(...r.marks.map((s) => ({
      from: i,
      to: i + r.nodeSize,
      mark: s
    })));
  }), o;
}
function uu(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([o]) => {
    const r = t.find((i) => i.type === e && i.name === o);
    return r ? r.attribute.keepOnSplit : !1;
  }));
}
function qh(t, e, n = {}) {
  const { empty: o, ranges: r } = t.selection, i = e ? Nr(e, t.schema) : null;
  if (o)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : !0).find((d) => Hu(d.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (r.forEach(({ $from: d, $to: f }) => {
    const p = d.pos, m = f.pos;
    t.doc.nodesBetween(p, m, (g, v) => {
      if (!g.isText && !g.marks.length)
        return;
      const y = Math.max(p, v), w = Math.min(m, v + g.nodeSize), x = w - y;
      s += x, a.push(...g.marks.map((b) => ({
        mark: b,
        from: y,
        to: w
      })));
    });
  }), s === 0)
    return !1;
  const l = a.filter((d) => i ? i.name === d.mark.type.name : !0).filter((d) => Hu(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= s;
}
function df(t, e, n = {}) {
  if (!e)
    return cl(t, null, n) || qh(t, null, n);
  const o = uf(e, t.schema);
  return o === "node" ? cl(t, e, n) : o === "mark" ? qh(t, e, n) : !1;
}
function Yh(t, e) {
  const { nodeExtensions: n } = rf(e), o = n.find((s) => s.name === t);
  if (!o)
    return !1;
  const r = {
    name: o.name,
    options: o.options,
    storage: o.storage
  }, i = Se(ie(o, "group", r));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function ff(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var o;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((o = t.text) !== null && o !== void 0 ? o : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let r = !0;
    return t.content.forEach((i) => {
      r !== !1 && (ff(i, { ignoreWhitespace: n, checkChildren: e }) || (r = !1));
    }), r;
  }
  return !1;
}
function RC(t) {
  return t instanceof de;
}
function $C(t, e, n) {
  const r = t.state.doc.content.size, i = Po(e, 0, r), s = Po(n, 0, r), a = t.coordsAtPos(i), l = t.coordsAtPos(s, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), p = f - d, m = u - c, y = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: p,
    height: m,
    x: d,
    y: c
  };
  return {
    ...y,
    toJSON: () => y
  };
}
function CT(t, e, n) {
  var o;
  const { selection: r } = e;
  let i = null;
  if (qg(r) && (i = r.$cursor), i) {
    const a = (o = t.storedMarks) !== null && o !== void 0 ? o : i.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: s } = r;
  return s.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const p = !f || f.type.allowsMarkType(n), m = !!n.isInSet(u.marks) || !u.marks.some((g) => g.type.excludes(n));
        c = p && m;
      }
      return !c;
    }), c;
  });
}
const ST = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  const { selection: i } = n, { empty: s, ranges: a } = i, l = Nr(t, o.schema);
  if (r)
    if (s) {
      const c = Yg(o, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        o.doc.nodesBetween(u, d, (f, p) => {
          const m = Math.max(p, u), g = Math.min(p + f.nodeSize, d);
          f.marks.find((y) => y.type === l) ? f.marks.forEach((y) => {
            l === y.type && n.addMark(m, g, l.create({
              ...y.attrs,
              ...e
            }));
          }) : n.addMark(m, g, l.create(e));
        });
      });
  return CT(o, n, l);
}, kT = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), ET = (t, e = {}) => ({ state: n, dispatch: o, chain: r }) => {
  const i = Ct(t, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? r().command(({ commands: a }) => U0(i, { ...s, ...e })(n) ? !0 : a.clearNodes()).command(({ state: a }) => U0(i, { ...s, ...e })(a, o)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, _T = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: o } = e, r = Po(t, 0, o.content.size), i = de.create(o, r);
    e.setSelection(i);
  }
  return !0;
}, AT = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: o } = e, { from: r, to: i } = typeof t == "number" ? { from: t, to: t } : t, s = ce.atStart(o).from, a = ce.atEnd(o).to, l = Po(r, s, a), c = Po(i, s, a), u = ce.create(o, l, c);
    e.setSelection(u);
  }
  return !0;
}, TT = (t) => ({ state: e, dispatch: n }) => {
  const o = Ct(t, e.schema);
  return c8(o)(e, n);
};
function Y0(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const o = n.filter((r) => e == null ? void 0 : e.includes(r.type.name));
    t.tr.ensureMarks(o);
  }
}
const OT = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: o, editor: r }) => {
  const { selection: i, doc: s } = e, { $from: a, $to: l } = i, c = r.extensionManager.attributes, u = uu(c, a.node().type.name, a.node().attrs);
  if (i instanceof de && i.node.isBlock)
    return !a.parentOffset || !Bo(s, a.pos) ? !1 : (o && (t && Y0(n, r.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : gT(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let p = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, m = Bo(e.doc, e.mapping.map(a.pos), 1, p);
  if (!p && !m && Bo(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (m = !0, p = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), o) {
    if (m && (i instanceof ce && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, p), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const g = e.mapping.map(a.before()), v = e.doc.resolve(g);
      a.node(-1).canReplaceWith(v.index(), v.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && Y0(n, r.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return m;
}, MT = (t, e = {}) => ({ tr: n, state: o, dispatch: r, editor: i }) => {
  var s;
  const a = Ct(t, o.schema), { $from: l, $to: c } = o.selection, u = o.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const f = i.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (r) {
      let y = K.empty;
      const w = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let $ = l.depth - w; $ >= l.depth - 3; $ -= 1)
        y = K.from(l.node($).copy(y));
      const x = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, b = {
        ...uu(f, l.node().type.name, l.node().attrs),
        ...e
      }, S = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(b)) || void 0;
      y = y.append(K.from(a.createAndFill(null, S) || void 0));
      const k = l.before(l.depth - (w - 1));
      n.replace(k, l.after(-x), new te(y, 4 - w, 0));
      let A = -1;
      n.doc.nodesBetween(k, n.doc.content.size, ($, O) => {
        if (A > -1)
          return !1;
        $.isTextblock && $.content.size === 0 && (A = O + 1);
      }), A > -1 && n.setSelection(ce.near(n.doc.resolve(A))), n.scrollIntoView();
    }
    return !0;
  }
  const p = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, m = {
    ...uu(f, d.type.name, d.attrs),
    ...e
  }, g = {
    ...uu(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const v = p ? [
    { type: a, attrs: m },
    { type: p, attrs: g }
  ] : [{ type: a, attrs: m }];
  if (!Bo(n.doc, l.pos, 2))
    return !1;
  if (r) {
    const { selection: y, storedMarks: w } = o, { splittableMarks: x } = i.extensionManager, b = w || y.$to.parentOffset && y.$from.marks();
    if (n.split(l.pos, 2, v).scrollIntoView(), !b || !r)
      return !0;
    const S = b.filter((k) => x.includes(k.type.name));
    n.ensureMarks(S);
  }
  return !0;
}, xp = (t, e) => {
  const n = Jg((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const o = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (o === void 0)
    return !0;
  const r = t.doc.nodeAt(o);
  return n.node.type === (r == null ? void 0 : r.type) && Lr(t.doc, n.pos) && t.join(n.pos), !0;
}, Cp = (t, e) => {
  const n = Jg((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const o = t.doc.resolve(n.start).after(n.depth);
  if (o === void 0)
    return !0;
  const r = t.doc.nodeAt(o);
  return n.node.type === (r == null ? void 0 : r.type) && Lr(t.doc, o) && t.join(o), !0;
}, IT = (t, e, n, o = {}) => ({ editor: r, tr: i, state: s, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = r.extensionManager, p = Ct(t, s.schema), m = Ct(e, s.schema), { selection: g, storedMarks: v } = s, { $from: y, $to: w } = g, x = y.blockRange(w), b = v || g.$to.parentOffset && g.$from.marks();
  if (!x)
    return !1;
  const S = Jg((k) => Yh(k.type.name, d))(g);
  if (x.depth >= 1 && S && x.depth - S.depth <= 1) {
    if (S.node.type === p)
      return c.liftListItem(m);
    if (Yh(S.node.type.name, d) && p.validContent(S.node.content) && a)
      return l().command(() => (i.setNodeMarkup(S.pos, p), !0)).command(() => xp(i, p)).command(() => Cp(i, p)).run();
  }
  return !n || !b || !a ? l().command(() => u().wrapInList(p, o) ? !0 : c.clearNodes()).wrapInList(p, o).command(() => xp(i, p)).command(() => Cp(i, p)).run() : l().command(() => {
    const k = u().wrapInList(p, o), A = b.filter(($) => f.includes($.type.name));
    return i.ensureMarks(A), k ? !0 : c.clearNodes();
  }).wrapInList(p, o).command(() => xp(i, p)).command(() => Cp(i, p)).run();
}, RT = (t, e = {}, n = {}) => ({ state: o, commands: r }) => {
  const { extendEmptyMarkRange: i = !1 } = n, s = Nr(t, o.schema);
  return qh(o, s, e) ? r.unsetMark(s, { extendEmptyMarkRange: i }) : r.setMark(s, e);
}, $T = (t, e, n = {}) => ({ state: o, commands: r }) => {
  const i = Ct(t, o.schema), s = Ct(e, o.schema), a = cl(o, i, n);
  let l;
  return o.selection.$anchor.sameParent(o.selection.$head) && (l = o.selection.$anchor.parent.attrs), a ? r.setNode(s, l) : r.setNode(i, { ...l, ...n });
}, PT = (t, e = {}) => ({ state: n, commands: o }) => {
  const r = Ct(t, n.schema);
  return cl(n, r, e) ? o.lift(r) : o.wrapIn(r, e);
}, LT = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let o = 0; o < n.length; o += 1) {
    const r = n[o];
    let i;
    if (r.spec.isInputRules && (i = r.getState(t))) {
      if (e) {
        const s = t.tr, a = i.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (i.text) {
          const l = s.doc.resolve(i.from).marks();
          s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
        } else
          s.delete(i.from, i.to);
      }
      return !0;
    }
  }
  return !1;
}, DT = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: o, ranges: r } = n;
  return o || e && r.forEach((i) => {
    t.removeMark(i.$from.pos, i.$to.pos);
  }), !0;
}, NT = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  var i;
  const { extendEmptyMarkRange: s = !1 } = e, { selection: a } = n, l = Nr(t, o.schema), { $from: c, empty: u, ranges: d } = a;
  if (!r)
    return !0;
  if (u && s) {
    let { from: f, to: p } = a;
    const m = (i = c.marks().find((v) => v.type === l)) === null || i === void 0 ? void 0 : i.attrs, g = lf(c, l, m);
    g && (f = g.from, p = g.to), n.removeMark(f, p, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, BT = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  let i = null, s = null;
  const a = uf(typeof t == "string" ? t : t.name, o.schema);
  return a ? (a === "node" && (i = Ct(t, o.schema)), a === "mark" && (s = Nr(t, o.schema)), r && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, u = l.$to.pos;
    let d, f, p, m;
    n.selection.empty ? o.doc.nodesBetween(c, u, (g, v) => {
      i && i === g.type && (p = Math.max(v, c), m = Math.min(v + g.nodeSize, u), d = v, f = g);
    }) : o.doc.nodesBetween(c, u, (g, v) => {
      v < c && i && i === g.type && (p = Math.max(v, c), m = Math.min(v + g.nodeSize, u), d = v, f = g), v >= c && v <= u && (i && i === g.type && n.setNodeMarkup(v, void 0, {
        ...g.attrs,
        ...e
      }), s && g.marks.length && g.marks.forEach((y) => {
        if (s === y.type) {
          const w = Math.max(v, c), x = Math.min(v + g.nodeSize, u);
          n.addMark(w, x, s.create({
            ...y.attrs,
            ...e
          }));
        }
      }));
    }), f && (d !== void 0 && n.setNodeMarkup(d, void 0, {
      ...f.attrs,
      ...e
    }), s && f.marks.length && f.marks.forEach((g) => {
      s === g.type && n.addMark(p, m, s.create({
        ...g.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, FT = (t, e = {}) => ({ state: n, dispatch: o }) => {
  const r = Ct(t, n.schema);
  return n8(r, e)(n, o);
}, zT = (t, e = {}) => ({ state: n, dispatch: o }) => {
  const r = Ct(t, n.schema);
  return o8(r, e)(n, o);
};
var HT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: _8,
  clearContent: A8,
  clearNodes: T8,
  command: O8,
  createParagraphNear: M8,
  cut: I8,
  deleteCurrentNode: R8,
  deleteNode: $8,
  deleteRange: P8,
  deleteSelection: L8,
  enter: D8,
  exitCode: N8,
  extendMarkRange: B8,
  first: F8,
  focus: z8,
  forEach: H8,
  insertContent: V8,
  insertContentAt: W8,
  joinBackward: q8,
  joinDown: G8,
  joinForward: Y8,
  joinItemBackward: J8,
  joinItemForward: X8,
  joinTextblockBackward: Z8,
  joinTextblockForward: Q8,
  joinUp: K8,
  keyboardShortcut: tT,
  lift: nT,
  liftEmptyBlock: oT,
  liftListItem: rT,
  newlineInCode: iT,
  resetAttributes: sT,
  scrollIntoView: aT,
  selectAll: lT,
  selectNodeBackward: cT,
  selectNodeForward: uT,
  selectParentNode: dT,
  selectTextblockEnd: fT,
  selectTextblockStart: pT,
  setContent: hT,
  setMark: ST,
  setMeta: kT,
  setNode: ET,
  setNodeSelection: _T,
  setTextSelection: AT,
  sinkListItem: TT,
  splitBlock: OT,
  splitListItem: MT,
  toggleList: IT,
  toggleMark: RT,
  toggleNode: $T,
  toggleWrap: PT,
  undoInputRule: LT,
  unsetAllMarks: DT,
  unsetMark: NT,
  updateAttributes: BT,
  wrapIn: FT,
  wrapInList: zT
});
const VT = ke.create({
  name: "commands",
  addCommands() {
    return {
      ...HT
    };
  }
}), UT = ke.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, o) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: o
            });
          }
        }
      })
    ];
  }
}), jT = ke.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), WT = new Ne("focusEvents"), KT = ke.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new De({
        key: WT,
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const o = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(o), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const o = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(o), !1;
            }
          }
        }
      })
    ];
  }
}), GT = ke.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: p } = d, m = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, g = m.parent.type.spec.isolating, v = d.pos - d.parentOffset, y = g && m.parent.childCount === 1 ? v === d.pos : fe.atStart(c).from === f;
        return !u || !p.type.isTextblock || p.textContent.length || !y || y && d.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), o = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, r = {
      ...o
    }, i = {
      ...o,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return cf() || TC() ? i : r;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new De({
        key: new Ne("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (t.some((g) => g.getMeta("composition")))
            return;
          const o = t.some((g) => g.docChanged) && !e.doc.eq(n.doc), r = t.some((g) => g.getMeta("preventClearDocument"));
          if (!o || r)
            return;
          const { empty: i, from: s, to: a } = e.selection, l = fe.atStart(e.doc).from, c = fe.atEnd(e.doc).to;
          if (i || !(s === l && a === c) || !ff(n.doc))
            return;
          const f = n.tr, p = nf({
            state: n,
            transaction: f
          }), { commands: m } = new of({
            editor: this.editor,
            state: p
          });
          if (m.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), qT = ke.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), YT = ke.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class ii {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, o = !1, r = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = o, this.resolvedPos = e, this.editor = n, this.currentNode = r;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, o = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, o = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: o }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new ii(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new ii(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new ii(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, o) => {
      const r = n.isBlock && !n.isTextblock, i = n.isAtom && !n.isText, s = this.pos + o + (i ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
      if (!r && a.depth <= this.depth)
        return;
      const l = new ii(a, this.editor, r, r ? n : null);
      r && (l.actualDepth = this.depth + 1), e.push(new ii(a, this.editor, r, r ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let o = null, r = this.parent;
    for (; r && !o; ) {
      if (r.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const i = r.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (i[l] !== n[l])
              break;
          }
        } else
          o = r;
      r = r.parent;
    }
    return o;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, o = !1) {
    let r = [];
    if (!this.children || this.children.length === 0)
      return r;
    const i = Object.keys(n);
    return this.children.forEach((s) => {
      o && r.length > 0 || (s.node.type.name === e && i.every((l) => n[l] === s.node.attrs[l]) && r.push(s), !(o && r.length > 0) && (r = r.concat(s.querySelectorAll(e, n, o))));
    }), r;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const JT = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function XT(t, e, n) {
  const o = document.querySelector("style[data-tiptap-style]");
  if (o !== null)
    return o;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute("data-tiptap-style", ""), r.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let PC = class extends u8 {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: o, moved: r }) => this.options.onDrop(n, o, r)), this.on("paste", ({ event: n, slice: o }) => this.options.onPaste(n, o)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = XT(JT, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const o = CC(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: o });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let o = n;
    if ([].concat(e).forEach((i) => {
      const s = typeof i == "string" ? `${i}$` : i.key;
      o = n.filter((a) => !a.key.startsWith(s));
    }), n.length === o.length)
      return;
    const r = this.state.reconfigure({
      plugins: o
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const r = [...this.options.enableCoreExtensions ? [
      jT,
      E8.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      VT,
      KT,
      GT,
      YT,
      UT,
      qT
    ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== !1 : !0) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i == null ? void 0 : i.type));
    this.extensionManager = new ss(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new of({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = Gh(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = Gh(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const o = EC(n, this.options.autofocus);
    this.view = new P6(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: is.create({
        doc: n,
        selection: o || void 0
      })
    });
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews(), this.prependClass();
    const i = this.view.dom;
    i.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((s) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
      });
      return;
    }
    const n = this.state.apply(e), o = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), o && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const r = e.getMeta("focus"), i = e.getMeta("blur");
    r && this.emit("focus", {
      editor: this,
      event: r.event,
      transaction: e
    }), i && this.emit("blur", {
      editor: this,
      event: i.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return IC(this.state, e);
  }
  isActive(e, n) {
    const o = typeof e == "string" ? e : null, r = typeof e == "string" ? n : e;
    return df(this.state, o, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return Wg(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: o = {} } = e || {};
    return MC(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...Gg(this.schema),
        ...o
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return ff(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var o;
    return ((o = this.$doc) === null || o === void 0 ? void 0 : o.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var o;
    return ((o = this.$doc) === null || o === void 0 ? void 0 : o.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new ii(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Ci(t) {
  return new sf({
    find: t.find,
    handler: ({ state: e, range: n, match: o }) => {
      const r = Se(t.getAttributes, void 0, o);
      if (r === !1 || r === null)
        return null;
      const { tr: i } = e, s = o[o.length - 1], a = o[0];
      if (s) {
        const l = a.search(/\S/), c = n.from + a.indexOf(s), u = c + s.length;
        if (Xg(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type)).filter((p) => p.to > c).length)
          return null;
        u < n.to && i.delete(u, n.to), c > n.from && i.delete(n.from + l, c);
        const f = n.from + l + s.length;
        i.addMark(n.from + l, f, t.type.create(r || {})), i.removeStoredMark(t.type);
      }
    }
  });
}
function LC(t) {
  return new sf({
    find: t.find,
    handler: ({ state: e, range: n, match: o }) => {
      const r = Se(t.getAttributes, void 0, o) || {}, { tr: i } = e, s = n.from;
      let a = n.to;
      const l = t.type.create(r);
      if (o[1]) {
        const c = o[0].lastIndexOf(o[1]);
        let u = s + c;
        u > a ? u = a : a = u + o[1].length;
        const d = o[0][o[0].length - 1];
        i.insertText(d, s + o[0].length - 1), i.replaceWith(u, a, l);
      } else if (o[0]) {
        const c = t.type.isInline ? s : s - 1;
        i.insert(c, t.type.create(r)).delete(i.mapping.map(s), i.mapping.map(a));
      }
      i.scrollIntoView();
    }
  });
}
function Jh(t) {
  return new sf({
    find: t.find,
    handler: ({ state: e, range: n, match: o }) => {
      const r = e.doc.resolve(n.from), i = Se(t.getAttributes, void 0, o) || {};
      if (!r.node(-1).canReplaceWith(r.index(-1), r.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
    }
  });
}
function Cs(t) {
  return new sf({
    find: t.find,
    handler: ({ state: e, range: n, match: o, chain: r }) => {
      const i = Se(t.getAttributes, void 0, o) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), c = l && Ag(l, t.type, i);
      if (!c)
        return null;
      if (s.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: p } = t.editor.extensionManager, m = f || d.$to.parentOffset && d.$from.marks();
        if (m) {
          const g = m.filter((v) => p.includes(v.type.name));
          s.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        r().updateAttributes(d, i).run();
      }
      const u = s.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t.type && Lr(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(o, u)) && s.join(n.from - 1);
    }
  });
}
let Ze = class Xh {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Se(ie(this, "addOptions", {
      name: this.name
    }))), this.storage = Se(ie(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Xh(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => af(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Xh(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Se(ie(n, "addOptions", {
      name: n.name
    })), n.storage = Se(ie(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
class ZT {
  constructor(e, n, o) {
    this.isDragging = !1, this.component = e, this.editor = n.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...o
    }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, o, r, i, s, a, l;
    const { view: c } = this.editor, u = e.target, d = u.nodeType === 3 ? (n = u.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || !((o = this.contentDOM) === null || o === void 0) && o.contains(u) || !d)
      return;
    let f = 0, p = 0;
    if (this.dom !== d) {
      const w = this.dom.getBoundingClientRect(), x = d.getBoundingClientRect(), b = (r = e.offsetX) !== null && r !== void 0 ? r : (i = e.nativeEvent) === null || i === void 0 ? void 0 : i.offsetX, S = (s = e.offsetY) !== null && s !== void 0 ? s : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
      f = x.x - w.x + b, p = x.y - w.y + S;
    }
    const m = this.dom.cloneNode(!0);
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(m, f, p);
    const g = this.getPos();
    if (typeof g != "number")
      return;
    const v = de.create(c.state.doc, g), y = c.state.tr.setSelection(v);
    c.dispatch(y);
  }
  stopEvent(e) {
    var n;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const o = e.target;
    if (!(this.dom.contains(o) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(o))))
      return !1;
    const i = e.type.startsWith("drag"), s = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(o.tagName) || o.isContentEditable) && !s && !i)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, d = de.isSelectable(this.node), f = e.type === "copy", p = e.type === "paste", m = e.type === "cut", g = e.type === "mousedown";
    if (!u && d && i && e.target === this.dom && e.preventDefault(), u && i && !c && e.target === this.dom)
      return e.preventDefault(), !1;
    if (u && l && !c && g) {
      const v = o.closest("[data-drag-handle]");
      v && (this.dom === v || this.dom.contains(v)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(c || s || f || p || m || g && d);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (cf() || _C()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((o) => o.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const o = this.getPos();
      return typeof o != "number" ? !1 : (n.setNodeMarkup(o, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function Er(t) {
  return new b8({
    find: t.find,
    handler: ({ state: e, range: n, match: o, pasteEvent: r }) => {
      const i = Se(t.getAttributes, void 0, o, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, a = o[o.length - 1], l = o[0];
      let c = n.to;
      if (a) {
        const u = l.search(/\S/), d = n.from + l.indexOf(a), f = d + a.length;
        if (Xg(n.from, n.to, e.doc).filter((m) => m.mark.type.excluded.find((v) => v === t.type && v !== m.mark.type)).filter((m) => m.to > d).length)
          return null;
        f < n.to && s.delete(f, n.to), d > n.from && s.delete(n.from + u, d), c = n.from + u + a.length, s.addMark(n.from + u, c, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function QT(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tn = "top", Tn = "bottom", On = "right", nn = "left", Zg = "auto", Hl = [tn, Tn, On, nn], Ss = "start", ul = "end", e5 = "clippingParents", DC = "viewport", ma = "popper", t5 = "reference", J0 = /* @__PURE__ */ Hl.reduce(function(t, e) {
  return t.concat([e + "-" + Ss, e + "-" + ul]);
}, []), NC = /* @__PURE__ */ [].concat(Hl, [Zg]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Ss, e + "-" + ul]);
}, []), n5 = "beforeRead", o5 = "read", r5 = "afterRead", i5 = "beforeMain", s5 = "main", a5 = "afterMain", l5 = "beforeWrite", c5 = "write", u5 = "afterWrite", d5 = [n5, o5, r5, i5, s5, a5, l5, c5, u5];
function fo(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function mn(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Si(t) {
  var e = mn(t).Element;
  return t instanceof e || t instanceof Element;
}
function _n(t) {
  var e = mn(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Qg(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = mn(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function f5(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var o = e.styles[n] || {}, r = e.attributes[n] || {}, i = e.elements[n];
    !_n(i) || !fo(i) || (Object.assign(i.style, o), Object.keys(r).forEach(function(s) {
      var a = r[s];
      a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function p5(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(o) {
      var r = e.elements[o], i = e.attributes[o] || {}, s = Object.keys(e.styles.hasOwnProperty(o) ? e.styles[o] : n[o]), a = s.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !_n(r) || !fo(r) || (Object.assign(r.style, a), Object.keys(i).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
const BC = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: f5,
  effect: p5,
  requires: ["computeStyles"]
};
function io(t) {
  return t.split("-")[0];
}
var gi = Math.max, Uu = Math.min, ks = Math.round;
function Zh() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function FC() {
  return !/^((?!chrome|android).)*safari/i.test(Zh());
}
function Es(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var o = t.getBoundingClientRect(), r = 1, i = 1;
  e && _n(t) && (r = t.offsetWidth > 0 && ks(o.width) / t.offsetWidth || 1, i = t.offsetHeight > 0 && ks(o.height) / t.offsetHeight || 1);
  var s = Si(t) ? mn(t) : window, a = s.visualViewport, l = !FC() && n, c = (o.left + (l && a ? a.offsetLeft : 0)) / r, u = (o.top + (l && a ? a.offsetTop : 0)) / i, d = o.width / r, f = o.height / i;
  return {
    width: d,
    height: f,
    top: u,
    right: c + d,
    bottom: u + f,
    left: c,
    x: c,
    y: u
  };
}
function e1(t) {
  var e = Es(t), n = t.offsetWidth, o = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - o) <= 1 && (o = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: o
  };
}
function zC(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Qg(n)) {
    var o = e;
    do {
      if (o && t.isSameNode(o))
        return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function Vo(t) {
  return mn(t).getComputedStyle(t);
}
function h5(t) {
  return ["table", "td", "th"].indexOf(fo(t)) >= 0;
}
function Br(t) {
  return ((Si(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function pf(t) {
  return fo(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (Qg(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Br(t)
  );
}
function X0(t) {
  return !_n(t) || // https://github.com/popperjs/popper-core/issues/837
  Vo(t).position === "fixed" ? null : t.offsetParent;
}
function m5(t) {
  var e = /firefox/i.test(Zh()), n = /Trident/i.test(Zh());
  if (n && _n(t)) {
    var o = Vo(t);
    if (o.position === "fixed")
      return null;
  }
  var r = pf(t);
  for (Qg(r) && (r = r.host); _n(r) && ["html", "body"].indexOf(fo(r)) < 0; ) {
    var i = Vo(r);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function Vl(t) {
  for (var e = mn(t), n = X0(t); n && h5(n) && Vo(n).position === "static"; )
    n = X0(n);
  return n && (fo(n) === "html" || fo(n) === "body" && Vo(n).position === "static") ? e : n || m5(t) || e;
}
function t1(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function Fa(t, e, n) {
  return gi(t, Uu(e, n));
}
function g5(t, e, n) {
  var o = Fa(t, e, n);
  return o > n ? n : o;
}
function HC() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function VC(t) {
  return Object.assign({}, HC(), t);
}
function UC(t, e) {
  return e.reduce(function(n, o) {
    return n[o] = t, n;
  }, {});
}
var v5 = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, VC(typeof e != "number" ? e : UC(e, Hl));
};
function y5(t) {
  var e, n = t.state, o = t.name, r = t.options, i = n.elements.arrow, s = n.modifiersData.popperOffsets, a = io(n.placement), l = t1(a), c = [nn, On].indexOf(a) >= 0, u = c ? "height" : "width";
  if (!(!i || !s)) {
    var d = v5(r.padding, n), f = e1(i), p = l === "y" ? tn : nn, m = l === "y" ? Tn : On, g = n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u], v = s[l] - n.rects.reference[l], y = Vl(i), w = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, x = g / 2 - v / 2, b = d[p], S = w - f[u] - d[m], k = w / 2 - f[u] / 2 + x, A = Fa(b, k, S), $ = l;
    n.modifiersData[o] = (e = {}, e[$] = A, e.centerOffset = A - k, e);
  }
}
function b5(t) {
  var e = t.state, n = t.options, o = n.element, r = o === void 0 ? "[data-popper-arrow]" : o;
  r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || zC(e.elements.popper, r) && (e.elements.arrow = r));
}
const w5 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: y5,
  effect: b5,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function _s(t) {
  return t.split("-")[1];
}
var x5 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function C5(t, e) {
  var n = t.x, o = t.y, r = e.devicePixelRatio || 1;
  return {
    x: ks(n * r) / r || 0,
    y: ks(o * r) / r || 0
  };
}
function Z0(t) {
  var e, n = t.popper, o = t.popperRect, r = t.placement, i = t.variation, s = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, d = t.isFixed, f = s.x, p = f === void 0 ? 0 : f, m = s.y, g = m === void 0 ? 0 : m, v = typeof u == "function" ? u({
    x: p,
    y: g
  }) : {
    x: p,
    y: g
  };
  p = v.x, g = v.y;
  var y = s.hasOwnProperty("x"), w = s.hasOwnProperty("y"), x = nn, b = tn, S = window;
  if (c) {
    var k = Vl(n), A = "clientHeight", $ = "clientWidth";
    if (k === mn(n) && (k = Br(n), Vo(k).position !== "static" && a === "absolute" && (A = "scrollHeight", $ = "scrollWidth")), k = k, r === tn || (r === nn || r === On) && i === ul) {
      b = Tn;
      var O = d && k === S && S.visualViewport ? S.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        k[A]
      );
      g -= O - o.height, g *= l ? 1 : -1;
    }
    if (r === nn || (r === tn || r === Tn) && i === ul) {
      x = On;
      var M = d && k === S && S.visualViewport ? S.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        k[$]
      );
      p -= M - o.width, p *= l ? 1 : -1;
    }
  }
  var P = Object.assign({
    position: a
  }, c && x5), F = u === !0 ? C5({
    x: p,
    y: g
  }, mn(n)) : {
    x: p,
    y: g
  };
  if (p = F.x, g = F.y, l) {
    var J;
    return Object.assign({}, P, (J = {}, J[b] = w ? "0" : "", J[x] = y ? "0" : "", J.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + g + "px)" : "translate3d(" + p + "px, " + g + "px, 0)", J));
  }
  return Object.assign({}, P, (e = {}, e[b] = w ? g + "px" : "", e[x] = y ? p + "px" : "", e.transform = "", e));
}
function S5(t) {
  var e = t.state, n = t.options, o = n.gpuAcceleration, r = o === void 0 ? !0 : o, i = n.adaptive, s = i === void 0 ? !0 : i, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: io(e.placement),
    variation: _s(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: r,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Z0(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Z0(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const k5 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: S5,
  data: {}
};
var Cc = {
  passive: !0
};
function E5(t) {
  var e = t.state, n = t.instance, o = t.options, r = o.scroll, i = r === void 0 ? !0 : r, s = o.resize, a = s === void 0 ? !0 : s, l = mn(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, Cc);
  }), a && l.addEventListener("resize", n.update, Cc), function() {
    i && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, Cc);
    }), a && l.removeEventListener("resize", n.update, Cc);
  };
}
const _5 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: E5,
  data: {}
};
var A5 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function du(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return A5[e];
  });
}
var T5 = {
  start: "end",
  end: "start"
};
function Q0(t) {
  return t.replace(/start|end/g, function(e) {
    return T5[e];
  });
}
function n1(t) {
  var e = mn(t), n = e.pageXOffset, o = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: o
  };
}
function o1(t) {
  return Es(Br(t)).left + n1(t).scrollLeft;
}
function O5(t, e) {
  var n = mn(t), o = Br(t), r = n.visualViewport, i = o.clientWidth, s = o.clientHeight, a = 0, l = 0;
  if (r) {
    i = r.width, s = r.height;
    var c = FC();
    (c || !c && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: a + o1(t),
    y: l
  };
}
function M5(t) {
  var e, n = Br(t), o = n1(t), r = (e = t.ownerDocument) == null ? void 0 : e.body, i = gi(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), s = gi(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -o.scrollLeft + o1(t), l = -o.scrollTop;
  return Vo(r || n).direction === "rtl" && (a += gi(n.clientWidth, r ? r.clientWidth : 0) - i), {
    width: i,
    height: s,
    x: a,
    y: l
  };
}
function r1(t) {
  var e = Vo(t), n = e.overflow, o = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + r + o);
}
function jC(t) {
  return ["html", "body", "#document"].indexOf(fo(t)) >= 0 ? t.ownerDocument.body : _n(t) && r1(t) ? t : jC(pf(t));
}
function za(t, e) {
  var n;
  e === void 0 && (e = []);
  var o = jC(t), r = o === ((n = t.ownerDocument) == null ? void 0 : n.body), i = mn(o), s = r ? [i].concat(i.visualViewport || [], r1(o) ? o : []) : o, a = e.concat(s);
  return r ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(za(pf(s)))
  );
}
function Qh(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function I5(t, e) {
  var n = Es(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function ey(t, e, n) {
  return e === DC ? Qh(O5(t, n)) : Si(e) ? I5(e, n) : Qh(M5(Br(t)));
}
function R5(t) {
  var e = za(pf(t)), n = ["absolute", "fixed"].indexOf(Vo(t).position) >= 0, o = n && _n(t) ? Vl(t) : t;
  return Si(o) ? e.filter(function(r) {
    return Si(r) && zC(r, o) && fo(r) !== "body";
  }) : [];
}
function $5(t, e, n, o) {
  var r = e === "clippingParents" ? R5(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], a = i.reduce(function(l, c) {
    var u = ey(t, c, o);
    return l.top = gi(u.top, l.top), l.right = Uu(u.right, l.right), l.bottom = Uu(u.bottom, l.bottom), l.left = gi(u.left, l.left), l;
  }, ey(t, s, o));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function WC(t) {
  var e = t.reference, n = t.element, o = t.placement, r = o ? io(o) : null, i = o ? _s(o) : null, s = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (r) {
    case tn:
      l = {
        x: s,
        y: e.y - n.height
      };
      break;
    case Tn:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case On:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case nn:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = r ? t1(r) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (i) {
      case Ss:
        l[c] = l[c] - (e[u] / 2 - n[u] / 2);
        break;
      case ul:
        l[c] = l[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function dl(t, e) {
  e === void 0 && (e = {});
  var n = e, o = n.placement, r = o === void 0 ? t.placement : o, i = n.strategy, s = i === void 0 ? t.strategy : i, a = n.boundary, l = a === void 0 ? e5 : a, c = n.rootBoundary, u = c === void 0 ? DC : c, d = n.elementContext, f = d === void 0 ? ma : d, p = n.altBoundary, m = p === void 0 ? !1 : p, g = n.padding, v = g === void 0 ? 0 : g, y = VC(typeof v != "number" ? v : UC(v, Hl)), w = f === ma ? t5 : ma, x = t.rects.popper, b = t.elements[m ? w : f], S = $5(Si(b) ? b : b.contextElement || Br(t.elements.popper), l, u, s), k = Es(t.elements.reference), A = WC({
    reference: k,
    element: x,
    placement: r
  }), $ = Qh(Object.assign({}, x, A)), O = f === ma ? $ : k, M = {
    top: S.top - O.top + y.top,
    bottom: O.bottom - S.bottom + y.bottom,
    left: S.left - O.left + y.left,
    right: O.right - S.right + y.right
  }, P = t.modifiersData.offset;
  if (f === ma && P) {
    var F = P[r];
    Object.keys(M).forEach(function(J) {
      var Q = [On, Tn].indexOf(J) >= 0 ? 1 : -1, G = [tn, Tn].indexOf(J) >= 0 ? "y" : "x";
      M[J] += F[G] * Q;
    });
  }
  return M;
}
function P5(t, e) {
  e === void 0 && (e = {});
  var n = e, o = n.placement, r = n.boundary, i = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? NC : l, u = _s(o), d = u ? a ? J0 : J0.filter(function(m) {
    return _s(m) === u;
  }) : Hl, f = d.filter(function(m) {
    return c.indexOf(m) >= 0;
  });
  f.length === 0 && (f = d);
  var p = f.reduce(function(m, g) {
    return m[g] = dl(t, {
      placement: g,
      boundary: r,
      rootBoundary: i,
      padding: s
    })[io(g)], m;
  }, {});
  return Object.keys(p).sort(function(m, g) {
    return p[m] - p[g];
  });
}
function L5(t) {
  if (io(t) === Zg)
    return [];
  var e = du(t);
  return [Q0(t), e, Q0(e)];
}
function D5(t) {
  var e = t.state, n = t.options, o = t.name;
  if (!e.modifiersData[o]._skip) {
    for (var r = n.mainAxis, i = r === void 0 ? !0 : r, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, g = n.allowedAutoPlacements, v = e.options.placement, y = io(v), w = y === v, x = l || (w || !m ? [du(v)] : L5(v)), b = [v].concat(x).reduce(function(we, Ae) {
      return we.concat(io(Ae) === Zg ? P5(e, {
        placement: Ae,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: m,
        allowedAutoPlacements: g
      }) : Ae);
    }, []), S = e.rects.reference, k = e.rects.popper, A = /* @__PURE__ */ new Map(), $ = !0, O = b[0], M = 0; M < b.length; M++) {
      var P = b[M], F = io(P), J = _s(P) === Ss, Q = [tn, Tn].indexOf(F) >= 0, G = Q ? "width" : "height", V = dl(e, {
        placement: P,
        boundary: u,
        rootBoundary: d,
        altBoundary: f,
        padding: c
      }), B = Q ? J ? On : nn : J ? Tn : tn;
      S[G] > k[G] && (B = du(B));
      var q = du(B), z = [];
      if (i && z.push(V[F] <= 0), a && z.push(V[B] <= 0, V[q] <= 0), z.every(function(we) {
        return we;
      })) {
        O = P, $ = !1;
        break;
      }
      A.set(P, z);
    }
    if ($)
      for (var H = m ? 3 : 1, Z = function(Ae) {
        var Re = b.find(function(qe) {
          var Ue = A.get(qe);
          if (Ue)
            return Ue.slice(0, Ae).every(function(Be) {
              return Be;
            });
        });
        if (Re)
          return O = Re, "break";
      }, ne = H; ne > 0; ne--) {
        var he = Z(ne);
        if (he === "break") break;
      }
    e.placement !== O && (e.modifiersData[o]._skip = !0, e.placement = O, e.reset = !0);
  }
}
const N5 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: D5,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function ty(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function ny(t) {
  return [tn, On, Tn, nn].some(function(e) {
    return t[e] >= 0;
  });
}
function B5(t) {
  var e = t.state, n = t.name, o = e.rects.reference, r = e.rects.popper, i = e.modifiersData.preventOverflow, s = dl(e, {
    elementContext: "reference"
  }), a = dl(e, {
    altBoundary: !0
  }), l = ty(s, o), c = ty(a, r, i), u = ny(l), d = ny(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
const F5 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: B5
};
function z5(t, e, n) {
  var o = io(t), r = [nn, tn].indexOf(o) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, s = i[0], a = i[1];
  return s = s || 0, a = (a || 0) * r, [nn, On].indexOf(o) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function H5(t) {
  var e = t.state, n = t.options, o = t.name, r = n.offset, i = r === void 0 ? [0, 0] : r, s = NC.reduce(function(u, d) {
    return u[d] = z5(d, e.rects, i), u;
  }, {}), a = s[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[o] = s;
}
const V5 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: H5
};
function U5(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = WC({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
const j5 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: U5,
  data: {}
};
function W5(t) {
  return t === "x" ? "y" : "x";
}
function K5(t) {
  var e = t.state, n = t.options, o = t.name, r = n.mainAxis, i = r === void 0 ? !0 : r, s = n.altAxis, a = s === void 0 ? !1 : s, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, p = f === void 0 ? !0 : f, m = n.tetherOffset, g = m === void 0 ? 0 : m, v = dl(e, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), y = io(e.placement), w = _s(e.placement), x = !w, b = t1(y), S = W5(b), k = e.modifiersData.popperOffsets, A = e.rects.reference, $ = e.rects.popper, O = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, M = typeof O == "number" ? {
    mainAxis: O,
    altAxis: O
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, O), P = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, F = {
    x: 0,
    y: 0
  };
  if (k) {
    if (i) {
      var J, Q = b === "y" ? tn : nn, G = b === "y" ? Tn : On, V = b === "y" ? "height" : "width", B = k[b], q = B + v[Q], z = B - v[G], H = p ? -$[V] / 2 : 0, Z = w === Ss ? A[V] : $[V], ne = w === Ss ? -$[V] : -A[V], he = e.elements.arrow, we = p && he ? e1(he) : {
        width: 0,
        height: 0
      }, Ae = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : HC(), Re = Ae[Q], qe = Ae[G], Ue = Fa(0, A[V], we[V]), Be = x ? A[V] / 2 - H - Ue - Re - M.mainAxis : Z - Ue - Re - M.mainAxis, rt = x ? -A[V] / 2 + H + Ue + qe + M.mainAxis : ne + Ue + qe + M.mainAxis, yn = e.elements.arrow && Vl(e.elements.arrow), Jt = yn ? b === "y" ? yn.clientTop || 0 : yn.clientLeft || 0 : 0, bn = (J = P == null ? void 0 : P[b]) != null ? J : 0, Fi = B + Be - bn - Jt, ac = B + rt - bn, la = Fa(p ? Uu(q, Fi) : q, B, p ? gi(z, ac) : z);
      k[b] = la, F[b] = la - B;
    }
    if (a) {
      var ca, lc = b === "x" ? tn : nn, cc = b === "x" ? Tn : On, wo = k[S], Xo = S === "y" ? "height" : "width", ua = wo + v[lc], Yr = wo - v[cc], da = [tn, nn].indexOf(y) !== -1, uc = (ca = P == null ? void 0 : P[S]) != null ? ca : 0, dc = da ? ua : wo - A[Xo] - $[Xo] - uc + M.altAxis, fc = da ? wo + A[Xo] + $[Xo] - uc - M.altAxis : Yr, pc = p && da ? g5(dc, wo, fc) : Fa(p ? dc : ua, wo, p ? fc : Yr);
      k[S] = pc, F[S] = pc - wo;
    }
    e.modifiersData[o] = F;
  }
}
const G5 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: K5,
  requiresIfExists: ["offset"]
};
function q5(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function Y5(t) {
  return t === mn(t) || !_n(t) ? n1(t) : q5(t);
}
function J5(t) {
  var e = t.getBoundingClientRect(), n = ks(e.width) / t.offsetWidth || 1, o = ks(e.height) / t.offsetHeight || 1;
  return n !== 1 || o !== 1;
}
function X5(t, e, n) {
  n === void 0 && (n = !1);
  var o = _n(e), r = _n(e) && J5(e), i = Br(e), s = Es(t, r, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (o || !o && !n) && ((fo(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  r1(i)) && (a = Y5(e)), _n(e) ? (l = Es(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : i && (l.x = o1(i))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function Z5(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
  t.forEach(function(i) {
    e.set(i.name, i);
  });
  function r(i) {
    n.add(i.name);
    var s = [].concat(i.requires || [], i.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), o.push(i);
  }
  return t.forEach(function(i) {
    n.has(i.name) || r(i);
  }), o;
}
function Q5(t) {
  var e = Z5(t);
  return d5.reduce(function(n, o) {
    return n.concat(e.filter(function(r) {
      return r.phase === o;
    }));
  }, []);
}
function eO(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function tO(t) {
  var e = t.reduce(function(n, o) {
    var r = n[o.name];
    return n[o.name] = r ? Object.assign({}, r, o, {
      options: Object.assign({}, r.options, o.options),
      data: Object.assign({}, r.data, o.data)
    }) : o, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var oy = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function ry() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function nO(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, o = n === void 0 ? [] : n, r = e.defaultOptions, i = r === void 0 ? oy : r;
  return function(a, l, c) {
    c === void 0 && (c = i);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, oy, i),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, p = {
      state: u,
      setOptions: function(y) {
        var w = typeof y == "function" ? y(u.options) : y;
        g(), u.options = Object.assign({}, i, u.options, w), u.scrollParents = {
          reference: Si(a) ? za(a) : a.contextElement ? za(a.contextElement) : [],
          popper: za(l)
        };
        var x = Q5(tO([].concat(o, u.options.modifiers)));
        return u.orderedModifiers = x.filter(function(b) {
          return b.enabled;
        }), m(), p.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var y = u.elements, w = y.reference, x = y.popper;
          if (ry(w, x)) {
            u.rects = {
              reference: X5(w, Vl(x), u.options.strategy === "fixed"),
              popper: e1(x)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(M) {
              return u.modifiersData[M.name] = Object.assign({}, M.data);
            });
            for (var b = 0; b < u.orderedModifiers.length; b++) {
              if (u.reset === !0) {
                u.reset = !1, b = -1;
                continue;
              }
              var S = u.orderedModifiers[b], k = S.fn, A = S.options, $ = A === void 0 ? {} : A, O = S.name;
              typeof k == "function" && (u = k({
                state: u,
                options: $,
                name: O,
                instance: p
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: eO(function() {
        return new Promise(function(v) {
          p.forceUpdate(), v(u);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!ry(a, l))
      return p;
    p.setOptions(c).then(function(v) {
      !f && c.onFirstUpdate && c.onFirstUpdate(v);
    });
    function m() {
      u.orderedModifiers.forEach(function(v) {
        var y = v.name, w = v.options, x = w === void 0 ? {} : w, b = v.effect;
        if (typeof b == "function") {
          var S = b({
            state: u,
            name: y,
            instance: p,
            options: x
          }), k = function() {
          };
          d.push(S || k);
        }
      });
    }
    function g() {
      d.forEach(function(v) {
        return v();
      }), d = [];
    }
    return p;
  };
}
var oO = [_5, j5, k5, BC, V5, N5, G5, w5, F5], rO = /* @__PURE__ */ nO({
  defaultModifiers: oO
}), iO = "tippy-box", KC = "tippy-content", sO = "tippy-backdrop", GC = "tippy-arrow", qC = "tippy-svg-arrow", ti = {
  passive: !0,
  capture: !0
}, YC = function() {
  return document.body;
};
function aO(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function Sp(t, e, n) {
  if (Array.isArray(t)) {
    var o = t[e];
    return o ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function i1(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function JC(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function iy(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(o) {
    clearTimeout(n), n = setTimeout(function() {
      t(o);
    }, e);
  };
}
function lO(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(o) {
    delete n[o];
  }), n;
}
function cO(t) {
  return t.split(/\s+/).filter(Boolean);
}
function Qi(t) {
  return [].concat(t);
}
function sy(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function uO(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function dO(t) {
  return t.split("-")[0];
}
function ju(t) {
  return [].slice.call(t);
}
function ay(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function Ha() {
  return document.createElement("div");
}
function fl(t) {
  return ["Element", "Fragment"].some(function(e) {
    return i1(t, e);
  });
}
function fO(t) {
  return i1(t, "NodeList");
}
function pO(t) {
  return i1(t, "MouseEvent");
}
function hO(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function mO(t) {
  return fl(t) ? [t] : fO(t) ? ju(t) : Array.isArray(t) ? t : ju(document.querySelectorAll(t));
}
function kp(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function ly(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function gO(t) {
  var e, n = Qi(t), o = n[0];
  return o != null && (e = o.ownerDocument) != null && e.body ? o.ownerDocument : document;
}
function vO(t, e) {
  var n = e.clientX, o = e.clientY;
  return t.every(function(r) {
    var i = r.popperRect, s = r.popperState, a = r.props, l = a.interactiveBorder, c = dO(s.placement), u = s.modifiersData.offset;
    if (!u)
      return !0;
    var d = c === "bottom" ? u.top.y : 0, f = c === "top" ? u.bottom.y : 0, p = c === "right" ? u.left.x : 0, m = c === "left" ? u.right.x : 0, g = i.top - o + d > l, v = o - i.bottom - f > l, y = i.left - n + p > l, w = n - i.right - m > l;
    return g || v || y || w;
  });
}
function Ep(t, e, n) {
  var o = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(r) {
    t[o](r, n);
  });
}
function cy(t, e) {
  for (var n = e; n; ) {
    var o;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (o = n.getRootNode()) == null ? void 0 : o.host;
  }
  return !1;
}
var to = {
  isTouch: !1
}, uy = 0;
function yO() {
  to.isTouch || (to.isTouch = !0, window.performance && document.addEventListener("mousemove", XC));
}
function XC() {
  var t = performance.now();
  t - uy < 20 && (to.isTouch = !1, document.removeEventListener("mousemove", XC)), uy = t;
}
function bO() {
  var t = document.activeElement;
  if (hO(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function wO() {
  document.addEventListener("touchstart", yO, ti), window.addEventListener("blur", bO);
}
var xO = typeof window < "u" && typeof document < "u", CO = xO ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function Wi(t) {
  var e = t === "destroy" ? "n already-" : " ";
  return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function dy(t) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t.replace(e, " ").replace(n, "").trim();
}
function SO(t) {
  return dy(`
  %ctippy.js

  %c` + dy(t) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function ZC(t) {
  return [
    SO(t),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var pl;
process.env.NODE_ENV !== "production" && kO();
function kO() {
  pl = /* @__PURE__ */ new Set();
}
function Oo(t, e) {
  if (t && !pl.has(e)) {
    var n;
    pl.add(e), (n = console).warn.apply(n, ZC(e));
  }
}
function em(t, e) {
  if (t && !pl.has(e)) {
    var n;
    pl.add(e), (n = console).error.apply(n, ZC(e));
  }
}
function EO(t) {
  var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
  em(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), em(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var QC = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, _O = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, un = Object.assign({
  appendTo: YC,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, QC, _O), AO = Object.keys(un), TO = function(e) {
  process.env.NODE_ENV !== "production" && tS(e, []);
  var n = Object.keys(e);
  n.forEach(function(o) {
    un[o] = e[o];
  });
};
function eS(t) {
  var e = t.plugins || [], n = e.reduce(function(o, r) {
    var i = r.name, s = r.defaultValue;
    if (i) {
      var a;
      o[i] = t[i] !== void 0 ? t[i] : (a = un[i]) != null ? a : s;
    }
    return o;
  }, {});
  return Object.assign({}, t, n);
}
function OO(t, e) {
  var n = e ? Object.keys(eS(Object.assign({}, un, {
    plugins: e
  }))) : AO, o = n.reduce(function(r, i) {
    var s = (t.getAttribute("data-tippy-" + i) || "").trim();
    if (!s)
      return r;
    if (i === "content")
      r[i] = s;
    else
      try {
        r[i] = JSON.parse(s);
      } catch {
        r[i] = s;
      }
    return r;
  }, {});
  return o;
}
function fy(t, e) {
  var n = Object.assign({}, e, {
    content: JC(e.content, [t])
  }, e.ignoreAttributes ? {} : OO(t, e.plugins));
  return n.aria = Object.assign({}, un.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function tS(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = []);
  var n = Object.keys(t);
  n.forEach(function(o) {
    var r = lO(un, Object.keys(QC)), i = !aO(r, o);
    i && (i = e.filter(function(s) {
      return s.name === o;
    }).length === 0), Oo(i, ["`" + o + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var MO = function() {
  return "innerHTML";
};
function tm(t, e) {
  t[MO()] = e;
}
function py(t) {
  var e = Ha();
  return t === !0 ? e.className = GC : (e.className = qC, fl(t) ? e.appendChild(t) : tm(e, t)), e;
}
function hy(t, e) {
  fl(e.content) ? (tm(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? tm(t, e.content) : t.textContent = e.content);
}
function nm(t) {
  var e = t.firstElementChild, n = ju(e.children);
  return {
    box: e,
    content: n.find(function(o) {
      return o.classList.contains(KC);
    }),
    arrow: n.find(function(o) {
      return o.classList.contains(GC) || o.classList.contains(qC);
    }),
    backdrop: n.find(function(o) {
      return o.classList.contains(sO);
    })
  };
}
function nS(t) {
  var e = Ha(), n = Ha();
  n.className = iO, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var o = Ha();
  o.className = KC, o.setAttribute("data-state", "hidden"), hy(o, t.props), e.appendChild(n), n.appendChild(o), r(t.props, t.props);
  function r(i, s) {
    var a = nm(e), l = a.box, c = a.content, u = a.arrow;
    s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (i.content !== s.content || i.allowHTML !== s.allowHTML) && hy(c, t.props), s.arrow ? u ? i.arrow !== s.arrow && (l.removeChild(u), l.appendChild(py(s.arrow))) : l.appendChild(py(s.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: e,
    onUpdate: r
  };
}
nS.$$tippy = !0;
var IO = 1, Sc = [], _p = [];
function RO(t, e) {
  var n = fy(t, Object.assign({}, un, eS(ay(e)))), o, r, i, s = !1, a = !1, l = !1, c = !1, u, d, f, p = [], m = iy(Fi, n.interactiveDebounce), g, v = IO++, y = null, w = uO(n.plugins), x = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: v,
    reference: t,
    popper: Ha(),
    popperInstance: y,
    props: n,
    state: x,
    plugins: w,
    // methods
    clearDelayTimeouts: dc,
    setProps: fc,
    setContent: pc,
    show: KE,
    hide: GE,
    hideWithInteractivity: qE,
    enable: da,
    disable: uc,
    unmount: YE,
    destroy: JE
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && em(!0, "render() function has not been supplied."), b;
  var S = n.render(b), k = S.popper, A = S.onUpdate;
  k.setAttribute("data-tippy-root", ""), k.id = "tippy-" + b.id, b.popper = k, t._tippy = b, k._tippy = b;
  var $ = w.map(function(U) {
    return U.fn(b);
  }), O = t.hasAttribute("aria-expanded");
  return yn(), H(), B(), q("onCreate", [b]), n.showOnCreate && ua(), k.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), k.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && Q().addEventListener("mousemove", m);
  }), b;
  function M() {
    var U = b.props.touch;
    return Array.isArray(U) ? U : [U, 0];
  }
  function P() {
    return M()[0] === "hold";
  }
  function F() {
    var U;
    return !!((U = b.props.render) != null && U.$$tippy);
  }
  function J() {
    return g || t;
  }
  function Q() {
    var U = J().parentNode;
    return U ? gO(U) : document;
  }
  function G() {
    return nm(k);
  }
  function V(U) {
    return b.state.isMounted && !b.state.isVisible || to.isTouch || u && u.type === "focus" ? 0 : Sp(b.props.delay, U ? 0 : 1, un.delay);
  }
  function B(U) {
    U === void 0 && (U = !1), k.style.pointerEvents = b.props.interactive && !U ? "" : "none", k.style.zIndex = "" + b.props.zIndex;
  }
  function q(U, se, pe) {
    if (pe === void 0 && (pe = !0), $.forEach(function($e) {
      $e[U] && $e[U].apply($e, se);
    }), pe) {
      var We;
      (We = b.props)[U].apply(We, se);
    }
  }
  function z() {
    var U = b.props.aria;
    if (U.content) {
      var se = "aria-" + U.content, pe = k.id, We = Qi(b.props.triggerTarget || t);
      We.forEach(function($e) {
        var zt = $e.getAttribute(se);
        if (b.state.isVisible)
          $e.setAttribute(se, zt ? zt + " " + pe : pe);
        else {
          var wn = zt && zt.replace(pe, "").trim();
          wn ? $e.setAttribute(se, wn) : $e.removeAttribute(se);
        }
      });
    }
  }
  function H() {
    if (!(O || !b.props.aria.expanded)) {
      var U = Qi(b.props.triggerTarget || t);
      U.forEach(function(se) {
        b.props.interactive ? se.setAttribute("aria-expanded", b.state.isVisible && se === J() ? "true" : "false") : se.removeAttribute("aria-expanded");
      });
    }
  }
  function Z() {
    Q().removeEventListener("mousemove", m), Sc = Sc.filter(function(U) {
      return U !== m;
    });
  }
  function ne(U) {
    if (!(to.isTouch && (l || U.type === "mousedown"))) {
      var se = U.composedPath && U.composedPath()[0] || U.target;
      if (!(b.props.interactive && cy(k, se))) {
        if (Qi(b.props.triggerTarget || t).some(function(pe) {
          return cy(pe, se);
        })) {
          if (to.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          q("onClickOutside", [b, U]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), b.state.isMounted || Re());
      }
    }
  }
  function he() {
    l = !0;
  }
  function we() {
    l = !1;
  }
  function Ae() {
    var U = Q();
    U.addEventListener("mousedown", ne, !0), U.addEventListener("touchend", ne, ti), U.addEventListener("touchstart", we, ti), U.addEventListener("touchmove", he, ti);
  }
  function Re() {
    var U = Q();
    U.removeEventListener("mousedown", ne, !0), U.removeEventListener("touchend", ne, ti), U.removeEventListener("touchstart", we, ti), U.removeEventListener("touchmove", he, ti);
  }
  function qe(U, se) {
    Be(U, function() {
      !b.state.isVisible && k.parentNode && k.parentNode.contains(k) && se();
    });
  }
  function Ue(U, se) {
    Be(U, se);
  }
  function Be(U, se) {
    var pe = G().box;
    function We($e) {
      $e.target === pe && (Ep(pe, "remove", We), se());
    }
    if (U === 0)
      return se();
    Ep(pe, "remove", d), Ep(pe, "add", We), d = We;
  }
  function rt(U, se, pe) {
    pe === void 0 && (pe = !1);
    var We = Qi(b.props.triggerTarget || t);
    We.forEach(function($e) {
      $e.addEventListener(U, se, pe), p.push({
        node: $e,
        eventType: U,
        handler: se,
        options: pe
      });
    });
  }
  function yn() {
    P() && (rt("touchstart", bn, {
      passive: !0
    }), rt("touchend", ac, {
      passive: !0
    })), cO(b.props.trigger).forEach(function(U) {
      if (U !== "manual")
        switch (rt(U, bn), U) {
          case "mouseenter":
            rt("mouseleave", ac);
            break;
          case "focus":
            rt(CO ? "focusout" : "blur", la);
            break;
          case "focusin":
            rt("focusout", la);
            break;
        }
    });
  }
  function Jt() {
    p.forEach(function(U) {
      var se = U.node, pe = U.eventType, We = U.handler, $e = U.options;
      se.removeEventListener(pe, We, $e);
    }), p = [];
  }
  function bn(U) {
    var se, pe = !1;
    if (!(!b.state.isEnabled || ca(U) || a)) {
      var We = ((se = u) == null ? void 0 : se.type) === "focus";
      u = U, g = U.currentTarget, H(), !b.state.isVisible && pO(U) && Sc.forEach(function($e) {
        return $e(U);
      }), U.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || s) && b.props.hideOnClick !== !1 && b.state.isVisible ? pe = !0 : ua(U), U.type === "click" && (s = !pe), pe && !We && Yr(U);
    }
  }
  function Fi(U) {
    var se = U.target, pe = J().contains(se) || k.contains(se);
    if (!(U.type === "mousemove" && pe)) {
      var We = Xo().concat(k).map(function($e) {
        var zt, wn = $e._tippy, zi = (zt = wn.popperInstance) == null ? void 0 : zt.state;
        return zi ? {
          popperRect: $e.getBoundingClientRect(),
          popperState: zi,
          props: n
        } : null;
      }).filter(Boolean);
      vO(We, U) && (Z(), Yr(U));
    }
  }
  function ac(U) {
    var se = ca(U) || b.props.trigger.indexOf("click") >= 0 && s;
    if (!se) {
      if (b.props.interactive) {
        b.hideWithInteractivity(U);
        return;
      }
      Yr(U);
    }
  }
  function la(U) {
    b.props.trigger.indexOf("focusin") < 0 && U.target !== J() || b.props.interactive && U.relatedTarget && k.contains(U.relatedTarget) || Yr(U);
  }
  function ca(U) {
    return to.isTouch ? P() !== U.type.indexOf("touch") >= 0 : !1;
  }
  function lc() {
    cc();
    var U = b.props, se = U.popperOptions, pe = U.placement, We = U.offset, $e = U.getReferenceClientRect, zt = U.moveTransition, wn = F() ? nm(k).arrow : null, zi = $e ? {
      getBoundingClientRect: $e,
      contextElement: $e.contextElement || J()
    } : t, Fv = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(hc) {
        var Hi = hc.state;
        if (F()) {
          var XE = G(), rp = XE.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(mc) {
            mc === "placement" ? rp.setAttribute("data-placement", Hi.placement) : Hi.attributes.popper["data-popper-" + mc] ? rp.setAttribute("data-" + mc, "") : rp.removeAttribute("data-" + mc);
          }), Hi.attributes.popper = {};
        }
      }
    }, Jr = [{
      name: "offset",
      options: {
        offset: We
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !zt
      }
    }, Fv];
    F() && wn && Jr.push({
      name: "arrow",
      options: {
        element: wn,
        padding: 3
      }
    }), Jr.push.apply(Jr, (se == null ? void 0 : se.modifiers) || []), b.popperInstance = rO(zi, k, Object.assign({}, se, {
      placement: pe,
      onFirstUpdate: f,
      modifiers: Jr
    }));
  }
  function cc() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function wo() {
    var U = b.props.appendTo, se, pe = J();
    b.props.interactive && U === YC || U === "parent" ? se = pe.parentNode : se = JC(U, [pe]), se.contains(k) || se.appendChild(k), b.state.isMounted = !0, lc(), process.env.NODE_ENV !== "production" && Oo(b.props.interactive && U === un.appendTo && pe.nextElementSibling !== k, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function Xo() {
    return ju(k.querySelectorAll("[data-tippy-root]"));
  }
  function ua(U) {
    b.clearDelayTimeouts(), U && q("onTrigger", [b, U]), Ae();
    var se = V(!0), pe = M(), We = pe[0], $e = pe[1];
    to.isTouch && We === "hold" && $e && (se = $e), se ? o = setTimeout(function() {
      b.show();
    }, se) : b.show();
  }
  function Yr(U) {
    if (b.clearDelayTimeouts(), q("onUntrigger", [b, U]), !b.state.isVisible) {
      Re();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(U.type) >= 0 && s)) {
      var se = V(!1);
      se ? r = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, se) : i = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function da() {
    b.state.isEnabled = !0;
  }
  function uc() {
    b.hide(), b.state.isEnabled = !1;
  }
  function dc() {
    clearTimeout(o), clearTimeout(r), cancelAnimationFrame(i);
  }
  function fc(U) {
    if (process.env.NODE_ENV !== "production" && Oo(b.state.isDestroyed, Wi("setProps")), !b.state.isDestroyed) {
      q("onBeforeUpdate", [b, U]), Jt();
      var se = b.props, pe = fy(t, Object.assign({}, se, ay(U), {
        ignoreAttributes: !0
      }));
      b.props = pe, yn(), se.interactiveDebounce !== pe.interactiveDebounce && (Z(), m = iy(Fi, pe.interactiveDebounce)), se.triggerTarget && !pe.triggerTarget ? Qi(se.triggerTarget).forEach(function(We) {
        We.removeAttribute("aria-expanded");
      }) : pe.triggerTarget && t.removeAttribute("aria-expanded"), H(), B(), A && A(se, pe), b.popperInstance && (lc(), Xo().forEach(function(We) {
        requestAnimationFrame(We._tippy.popperInstance.forceUpdate);
      })), q("onAfterUpdate", [b, U]);
    }
  }
  function pc(U) {
    b.setProps({
      content: U
    });
  }
  function KE() {
    process.env.NODE_ENV !== "production" && Oo(b.state.isDestroyed, Wi("show"));
    var U = b.state.isVisible, se = b.state.isDestroyed, pe = !b.state.isEnabled, We = to.isTouch && !b.props.touch, $e = Sp(b.props.duration, 0, un.duration);
    if (!(U || se || pe || We) && !J().hasAttribute("disabled") && (q("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, F() && (k.style.visibility = "visible"), B(), Ae(), b.state.isMounted || (k.style.transition = "none"), F()) {
        var zt = G(), wn = zt.box, zi = zt.content;
        kp([wn, zi], 0);
      }
      f = function() {
        var Jr;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, k.offsetHeight, k.style.transition = b.props.moveTransition, F() && b.props.animation) {
            var op = G(), hc = op.box, Hi = op.content;
            kp([hc, Hi], $e), ly([hc, Hi], "visible");
          }
          z(), H(), sy(_p, b), (Jr = b.popperInstance) == null || Jr.forceUpdate(), q("onMount", [b]), b.props.animation && F() && Ue($e, function() {
            b.state.isShown = !0, q("onShown", [b]);
          });
        }
      }, wo();
    }
  }
  function GE() {
    process.env.NODE_ENV !== "production" && Oo(b.state.isDestroyed, Wi("hide"));
    var U = !b.state.isVisible, se = b.state.isDestroyed, pe = !b.state.isEnabled, We = Sp(b.props.duration, 1, un.duration);
    if (!(U || se || pe) && (q("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, s = !1, F() && (k.style.visibility = "hidden"), Z(), Re(), B(!0), F()) {
        var $e = G(), zt = $e.box, wn = $e.content;
        b.props.animation && (kp([zt, wn], We), ly([zt, wn], "hidden"));
      }
      z(), H(), b.props.animation ? F() && qe(We, b.unmount) : b.unmount();
    }
  }
  function qE(U) {
    process.env.NODE_ENV !== "production" && Oo(b.state.isDestroyed, Wi("hideWithInteractivity")), Q().addEventListener("mousemove", m), sy(Sc, m), m(U);
  }
  function YE() {
    process.env.NODE_ENV !== "production" && Oo(b.state.isDestroyed, Wi("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (cc(), Xo().forEach(function(U) {
      U._tippy.unmount();
    }), k.parentNode && k.parentNode.removeChild(k), _p = _p.filter(function(U) {
      return U !== b;
    }), b.state.isMounted = !1, q("onHidden", [b]));
  }
  function JE() {
    process.env.NODE_ENV !== "production" && Oo(b.state.isDestroyed, Wi("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), Jt(), delete t._tippy, b.state.isDestroyed = !0, q("onDestroy", [b]));
  }
}
function Fr(t, e) {
  e === void 0 && (e = {});
  var n = un.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (EO(t), tS(e, n)), wO();
  var o = Object.assign({}, e, {
    plugins: n
  }), r = mO(t);
  if (process.env.NODE_ENV !== "production") {
    var i = fl(o.content), s = r.length > 1;
    Oo(i && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = r.reduce(function(l, c) {
    var u = c && RO(c, o);
    return u && l.push(u), l;
  }, []);
  return fl(t) ? a[0] : a;
}
Fr.defaultProps = un;
Fr.setDefaultProps = TO;
Fr.currentInput = to;
Object.assign({}, BC, {
  effect: function(e) {
    var n = e.state, o = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, o.popper), n.styles = o, n.elements.arrow && Object.assign(n.elements.arrow.style, o.arrow);
  }
});
var s1 = {
  name: "sticky",
  defaultValue: !1,
  fn: function(e) {
    var n = e.reference, o = e.popper;
    function r() {
      return e.popperInstance ? e.popperInstance.state.elements.reference : n;
    }
    function i(c) {
      return e.props.sticky === !0 || e.props.sticky === c;
    }
    var s = null, a = null;
    function l() {
      var c = i("reference") ? r().getBoundingClientRect() : null, u = i("popper") ? o.getBoundingClientRect() : null;
      (c && my(s, c) || u && my(a, u)) && e.popperInstance && e.popperInstance.update(), s = c, a = u, e.state.isMounted && requestAnimationFrame(l);
    }
    return {
      onMount: function() {
        e.props.sticky && l();
      }
    };
  }
};
function my(t, e) {
  return t && e ? t.top !== e.top || t.right !== e.right || t.bottom !== e.bottom || t.left !== e.left : !0;
}
Fr.setDefaultProps({
  render: nS
});
class $O {
  constructor({ editor: e, element: n, view: o, tippyOptions: r = {}, updateDelay: i = 250, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: c, to: u }) => {
      const { doc: d, selection: f } = l, { empty: p } = f, m = !d.textBetween(c, u).length && qg(l.selection), g = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || g) || p || m || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const c = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
      !c && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, c, u, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, c, u) => {
      var d, f, p;
      const { state: m, composing: g } = a, { selection: v } = m;
      if (g || !l && !c)
        return;
      this.createTooltip();
      const { ranges: w } = v, x = Math.min(...w.map((k) => k.$from.pos)), b = Math.max(...w.map((k) => k.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        element: this.element,
        view: a,
        state: m,
        oldState: u,
        from: x,
        to: b
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((p = this.tippyOptions) === null || p === void 0 ? void 0 : p.getReferenceClientRect) || (() => {
          if (RC(m.selection)) {
            let k = a.nodeDOM(x);
            if (k) {
              const A = k.dataset.nodeViewWrapper ? k : k.querySelector("[data-node-view-wrapper]");
              if (A && (k = A.firstChild), k)
                return k.getBoundingClientRect();
            }
          }
          return $C(a, x, b);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = o, this.updateDelay = i, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Fr(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: o } = e, r = o.selection.from !== o.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const i = !(n != null && n.selection.eq(e.state.selection)), s = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, i, s, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const oS = (t) => new De({
  key: typeof t.pluginKey == "string" ? new Ne(t.pluginKey) : t.pluginKey,
  view: (e) => new $O({ view: e, ...t })
});
ke.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      oS({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class PO {
  getTextContent(e) {
    return MC(e, { textSerializers: Gg(this.editor.schema) });
  }
  constructor({ editor: e, element: n, view: o, tippyOptions: r = {}, shouldShow: i }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: a }) => {
      const { selection: l } = a, { $anchor: c, empty: u } = l, d = c.depth === 1, f = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent && c.parent.childCount === 0 && !this.getTextContent(c.parent);
      return !(!s.hasFocus() || !u || !d || !f || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.editor = e, this.element = n, this.view = o, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Fr(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var o, r, i;
    const { state: s } = e, { doc: a, selection: l } = s, { from: c, to: u } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((o = this.shouldShow) === null || o === void 0 ? void 0 : o.call(this, {
      editor: this.editor,
      view: e,
      state: s,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (r = this.tippy) === null || r === void 0 || r.setProps({
      getReferenceClientRect: ((i = this.tippyOptions) === null || i === void 0 ? void 0 : i.getReferenceClientRect) || (() => $C(e, c, u))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const rS = (t) => new De({
  key: typeof t.pluginKey == "string" ? new Ne(t.pluginKey) : t.pluginKey,
  view: (e) => new PO({ view: e, ...t })
});
ke.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      rS({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const zs = I({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = R(null);
    return be(() => {
      const { updateDelay: o, editor: r, pluginKey: i, shouldShow: s, tippyOptions: a } = t;
      r.registerPlugin(oS({
        updateDelay: o,
        editor: r,
        element: n.value,
        pluginKey: i,
        shouldShow: s,
        tippyOptions: a
      }));
    }), mo(() => {
      const { pluginKey: o, editor: r } = t;
      r.unregisterPlugin(o);
    }), () => {
      var o;
      return Ot("div", { ref: n }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
    };
  }
});
function gy(t) {
  return wg((e, n) => ({
    get() {
      return e(), t;
    },
    set(o) {
      t = o, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class iS extends PC {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = gy(this.view.state), this.reactiveExtensionStorage = gy(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), bg(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const o = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = o), o;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const LO = I({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t) {
    const e = R(), n = qn();
    return Ve(() => {
      const o = t.editor;
      o && o.options.element && e.value && ze(() => {
        if (!e.value || !o.options.element.firstChild)
          return;
        const r = h(e.value);
        e.value.append(...o.options.element.childNodes), o.contentComponent = n.ctx._, n && (o.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), o.setOptions({
          element: r
        }), o.createNodeViews();
      });
    }), mo(() => {
      const o = t.editor;
      o && (o.contentComponent = null, o.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return Ot("div", {
      ref: (t) => {
        this.rootEl = t;
      }
    });
  }
});
I({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = R(null);
    return be(() => {
      const { pluginKey: o, editor: r, tippyOptions: i, shouldShow: s } = t;
      r.registerPlugin(rS({
        pluginKey: o,
        editor: r,
        element: n.value,
        tippyOptions: i,
        shouldShow: s
      }));
    }), mo(() => {
      const { pluginKey: o, editor: r } = t;
      r.unregisterPlugin(o);
    }), () => {
      var o;
      return Ot("div", { ref: n }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
    };
  }
});
I({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return Ot(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
const Ul = I({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t, e;
    return Ot(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t));
  }
}), ire = (t = {}) => {
  const e = Oi();
  return be(() => {
    e.value = new iS(t);
  }), mo(() => {
    var n, o, r;
    const i = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, s = i == null ? void 0 : i.cloneNode(!0);
    (o = i == null ? void 0 : i.parentNode) === null || o === void 0 || o.replaceChild(s, i), (r = e.value) === null || r === void 0 || r.destroy();
  }), e;
};
class sS {
  constructor(e, { props: n = {}, editor: o }) {
    this.editor = o, this.component = bg(e), this.el = document.createElement("div"), this.props = hn(n), this.renderedComponent = this.renderComponent();
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, n, o, r;
    return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (r = (o = this.renderedComponent.vNode) === null || o === void 0 ? void 0 : o.component) === null || r === void 0 ? void 0 : r.proxy;
  }
  renderComponent() {
    let e = Ot(this.component, this.props);
    return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && Uv(e, this.el), { vNode: e, destroy: () => {
      this.el && Uv(null, this.el), this.el = null, e = null;
    }, el: this.el ? this.el.firstElementChild : null };
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([n, o]) => {
      this.props[n] = o;
    }), this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const jl = {
  editor: {
    type: Object,
    required: !0
  },
  node: {
    type: Object,
    required: !0
  },
  decorations: {
    type: Object,
    required: !0
  },
  selected: {
    type: Boolean,
    required: !0
  },
  extension: {
    type: Object,
    required: !0
  },
  getPos: {
    type: Function,
    required: !0
  },
  updateAttributes: {
    type: Function,
    required: !0
  },
  deleteNode: {
    type: Function,
    required: !0
  },
  view: {
    type: Object,
    required: !0
  },
  innerDecorations: {
    type: Object,
    required: !0
  },
  HTMLAttributes: {
    type: Object,
    required: !0
  }
};
class DO extends ZT {
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (r = {}) => this.updateAttributes(r),
      deleteNode: () => this.deleteNode()
    }, n = this.onDragStart.bind(this);
    this.decorationClasses = R(this.getDecorationClasses());
    const o = I({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (r) => {
        var i, s;
        return el("onDragStart", n), el("decorationClasses", this.decorationClasses), (s = (i = this.component).setup) === null || s === void 0 ? void 0 : s.call(i, r, {
          expose: () => {
          }
        });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new sS(o, {
      editor: this.editor,
      props: e
    });
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: n } = this.editor.state.selection, o = this.getPos();
    if (typeof o == "number")
      if (e <= o && n >= o + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, n, o) {
    const r = (i) => {
      this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(i);
    };
    if (typeof this.options.update == "function") {
      const i = this.node, s = this.decorations, a = this.innerDecorations;
      return this.node = e, this.decorations = n, this.innerDecorations = o, this.options.update({
        oldNode: i,
        oldDecorations: s,
        newNode: e,
        newDecorations: n,
        oldInnerDecorations: a,
        innerDecorations: o,
        updateProps: () => r({ node: e, decorations: n, innerDecorations: o })
      });
    }
    return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === n && this.innerDecorations === o || (this.node = e, this.decorations = n, this.innerDecorations = o, r({ node: e, decorations: n, innerDecorations: o })), !0);
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
}
function Wl(t, e) {
  return (n) => {
    if (!n.editor.contentComponent)
      return {};
    const o = typeof t == "function" && "__vccOpts" in t ? t.__vccOpts : t;
    return new DO(o, n, e);
  };
}
const aS = "zhHans", vy = 200, NO = 20, yy = 1e5, by = 16, kc = 10, Ec = 10, _c = 2, BO = "#262626", FO = [
  "#000000",
  "#262626",
  "#595959",
  "#8C8C8C",
  "#BFBFBF",
  "#D9D9D9",
  "#E9E9E9",
  "#F5F5F5",
  "#FAFAFA",
  "#FFFFFF",
  "#F5222D",
  "#FA541C",
  "#FA8C16",
  "#FADB14",
  "#52C41A",
  "#13C2C2",
  "#1890FF",
  "#2F54EB",
  "#722ED1",
  "#EB2F96",
  "#FFE8E6",
  "#FFECE0",
  "#FFEFD1",
  "#FCFCCA",
  "#E4F7D2",
  "#D3F5F0",
  "#D4EEFC",
  "#DEE8FC",
  "#EFE1FA",
  "#FAE1EB",
  "#FFA39E",
  "#FFBB96",
  "#FFD591",
  "#FFFB8F",
  "#B7EB8F",
  "#87E8DE",
  "#91D5FF",
  "#ADC6FF",
  "#D3ADF7",
  "#FFADD2",
  "#FF4D4F",
  "#FF7A45",
  "#FFA940",
  "#FFEC3D",
  "#73D13D",
  "#36CFC9",
  "#40A9FF",
  "#597EF7",
  "#9254DE",
  "#F759AB",
  "#CF1322",
  "#D4380D",
  "#D46B08",
  "#D4B106",
  "#389E0D",
  "#08979C",
  "#096DD9",
  "#1D39C4",
  "#531DAB",
  "#C41D7F",
  "#820014",
  "#871400",
  "#873800",
  "#614700",
  "#135200",
  "#00474F",
  "#003A8C",
  "#061178",
  "#22075E",
  "#780650"
], zO = [
  "10px",
  "11px",
  "12px",
  "14px",
  "16px",
  "18px",
  "20px",
  "22px",
  "24px",
  "26px",
  "28px",
  "36px",
  "48px",
  "72px"
], Ki = "defaut";
var Wu = /* @__PURE__ */ ((t) => (t[t["size-small"] = 480] = "size-small", t[t["size-medium"] = 640] = "size-medium", t["size-large"] = "100%", t))(Wu || {});
const lS = "1", HO = {
  text: [
    "AI",
    "divider",
    "text-bubble",
    "divider",
    "bold",
    "italic",
    "underline",
    "strike",
    "code",
    "link",
    "divider",
    "color",
    "highlight",
    "textAlign"
  ],
  video: ["video-size-small", "video-size-medium", "video-size-large", "divider", "remove"]
}, VO = [
  "Arial",
  "Arial Black",
  "Georgia",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Verdana",
  "Courier New",
  "Lucida Console",
  "Monaco",
  "monospace"
], UO = VO.reduce(
  (t, e) => (t[e] = e, t),
  {}
);
var Ac = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Kl(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var jO = typeof Ac == "object" && Ac && Ac.Object === Object && Ac, cS = jO, WO = cS, KO = typeof self == "object" && self && self.Object === Object && self, GO = WO || KO || Function("return this")(), go = GO, qO = go, YO = qO.Symbol, Gl = YO, wy = Gl, uS = Object.prototype, JO = uS.hasOwnProperty, XO = uS.toString, ga = wy ? wy.toStringTag : void 0;
function ZO(t) {
  var e = JO.call(t, ga), n = t[ga];
  try {
    t[ga] = void 0;
    var o = !0;
  } catch {
  }
  var r = XO.call(t);
  return o && (e ? t[ga] = n : delete t[ga]), r;
}
var QO = ZO, eM = Object.prototype, tM = eM.toString;
function nM(t) {
  return tM.call(t);
}
var oM = nM, xy = Gl, rM = QO, iM = oM, sM = "[object Null]", aM = "[object Undefined]", Cy = xy ? xy.toStringTag : void 0;
function lM(t) {
  return t == null ? t === void 0 ? aM : sM : Cy && Cy in Object(t) ? rM(t) : iM(t);
}
var Hs = lM;
function cM(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Mi = cM, uM = Hs, dM = Mi, fM = "[object AsyncFunction]", pM = "[object Function]", hM = "[object GeneratorFunction]", mM = "[object Proxy]";
function gM(t) {
  if (!dM(t))
    return !1;
  var e = uM(t);
  return e == pM || e == hM || e == fM || e == mM;
}
var dS = gM, vM = go, yM = vM["__core-js_shared__"], bM = yM, Ap = bM, Sy = function() {
  var t = /[^.]+$/.exec(Ap && Ap.keys && Ap.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function wM(t) {
  return !!Sy && Sy in t;
}
var xM = wM, CM = Function.prototype, SM = CM.toString;
function kM(t) {
  if (t != null) {
    try {
      return SM.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var fS = kM, EM = dS, _M = xM, AM = Mi, TM = fS, OM = /[\\^$.*+?()[\]{}|]/g, MM = /^\[object .+?Constructor\]$/, IM = Function.prototype, RM = Object.prototype, $M = IM.toString, PM = RM.hasOwnProperty, LM = RegExp(
  "^" + $M.call(PM).replace(OM, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function DM(t) {
  if (!AM(t) || _M(t))
    return !1;
  var e = EM(t) ? LM : MM;
  return e.test(TM(t));
}
var NM = DM;
function BM(t, e) {
  return t == null ? void 0 : t[e];
}
var FM = BM, zM = NM, HM = FM;
function VM(t, e) {
  var n = HM(t, e);
  return zM(n) ? n : void 0;
}
var Ii = VM, UM = Ii, jM = UM(Object, "create"), hf = jM, ky = hf;
function WM() {
  this.__data__ = ky ? ky(null) : {}, this.size = 0;
}
var KM = WM;
function GM(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var qM = GM, YM = hf, JM = "__lodash_hash_undefined__", XM = Object.prototype, ZM = XM.hasOwnProperty;
function QM(t) {
  var e = this.__data__;
  if (YM) {
    var n = e[t];
    return n === JM ? void 0 : n;
  }
  return ZM.call(e, t) ? e[t] : void 0;
}
var eI = QM, tI = hf, nI = Object.prototype, oI = nI.hasOwnProperty;
function rI(t) {
  var e = this.__data__;
  return tI ? e[t] !== void 0 : oI.call(e, t);
}
var iI = rI, sI = hf, aI = "__lodash_hash_undefined__";
function lI(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = sI && e === void 0 ? aI : e, this;
}
var cI = lI, uI = KM, dI = qM, fI = eI, pI = iI, hI = cI;
function Vs(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
Vs.prototype.clear = uI;
Vs.prototype.delete = dI;
Vs.prototype.get = fI;
Vs.prototype.has = pI;
Vs.prototype.set = hI;
var mI = Vs;
function gI() {
  this.__data__ = [], this.size = 0;
}
var vI = gI;
function yI(t, e) {
  return t === e || t !== t && e !== e;
}
var pS = yI, bI = pS;
function wI(t, e) {
  for (var n = t.length; n--; )
    if (bI(t[n][0], e))
      return n;
  return -1;
}
var mf = wI, xI = mf, CI = Array.prototype, SI = CI.splice;
function kI(t) {
  var e = this.__data__, n = xI(e, t);
  if (n < 0)
    return !1;
  var o = e.length - 1;
  return n == o ? e.pop() : SI.call(e, n, 1), --this.size, !0;
}
var EI = kI, _I = mf;
function AI(t) {
  var e = this.__data__, n = _I(e, t);
  return n < 0 ? void 0 : e[n][1];
}
var TI = AI, OI = mf;
function MI(t) {
  return OI(this.__data__, t) > -1;
}
var II = MI, RI = mf;
function $I(t, e) {
  var n = this.__data__, o = RI(n, t);
  return o < 0 ? (++this.size, n.push([t, e])) : n[o][1] = e, this;
}
var PI = $I, LI = vI, DI = EI, NI = TI, BI = II, FI = PI;
function Us(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
Us.prototype.clear = LI;
Us.prototype.delete = DI;
Us.prototype.get = NI;
Us.prototype.has = BI;
Us.prototype.set = FI;
var gf = Us, zI = Ii, HI = go, VI = zI(HI, "Map"), a1 = VI, Ey = mI, UI = gf, jI = a1;
function WI() {
  this.size = 0, this.__data__ = {
    hash: new Ey(),
    map: new (jI || UI)(),
    string: new Ey()
  };
}
var KI = WI;
function GI(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
var qI = GI, YI = qI;
function JI(t, e) {
  var n = t.__data__;
  return YI(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
var vf = JI, XI = vf;
function ZI(t) {
  var e = XI(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
var QI = ZI, e7 = vf;
function t7(t) {
  return e7(this, t).get(t);
}
var n7 = t7, o7 = vf;
function r7(t) {
  return o7(this, t).has(t);
}
var i7 = r7, s7 = vf;
function a7(t, e) {
  var n = s7(this, t), o = n.size;
  return n.set(t, e), this.size += n.size == o ? 0 : 1, this;
}
var l7 = a7, c7 = KI, u7 = QI, d7 = n7, f7 = i7, p7 = l7;
function js(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
js.prototype.clear = c7;
js.prototype.delete = u7;
js.prototype.get = d7;
js.prototype.has = f7;
js.prototype.set = p7;
var l1 = js, h7 = "__lodash_hash_undefined__";
function m7(t) {
  return this.__data__.set(t, h7), this;
}
var g7 = m7;
function v7(t) {
  return this.__data__.has(t);
}
var y7 = v7, b7 = l1, w7 = g7, x7 = y7;
function Ku(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new b7(); ++e < n; )
    this.add(t[e]);
}
Ku.prototype.add = Ku.prototype.push = w7;
Ku.prototype.has = x7;
var hS = Ku;
function C7(t, e, n, o) {
  for (var r = t.length, i = n + (o ? 1 : -1); o ? i-- : ++i < r; )
    if (e(t[i], i, t))
      return i;
  return -1;
}
var S7 = C7;
function k7(t) {
  return t !== t;
}
var E7 = k7;
function _7(t, e, n) {
  for (var o = n - 1, r = t.length; ++o < r; )
    if (t[o] === e)
      return o;
  return -1;
}
var A7 = _7, T7 = S7, O7 = E7, M7 = A7;
function I7(t, e, n) {
  return e === e ? M7(t, e, n) : T7(t, O7, n);
}
var R7 = I7, $7 = R7;
function P7(t, e) {
  var n = t == null ? 0 : t.length;
  return !!n && $7(t, e, 0) > -1;
}
var L7 = P7;
function D7(t, e, n) {
  for (var o = -1, r = t == null ? 0 : t.length; ++o < r; )
    if (n(e, t[o]))
      return !0;
  return !1;
}
var N7 = D7;
function B7(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length, r = Array(o); ++n < o; )
    r[n] = e(t[n], n, t);
  return r;
}
var mS = B7;
function F7(t) {
  return function(e) {
    return t(e);
  };
}
var c1 = F7;
function z7(t, e) {
  return t.has(e);
}
var gS = z7, H7 = hS, V7 = L7, U7 = N7, j7 = mS, W7 = c1, K7 = gS, G7 = 200;
function q7(t, e, n, o) {
  var r = -1, i = V7, s = !0, a = t.length, l = [], c = e.length;
  if (!a)
    return l;
  n && (e = j7(e, W7(n))), o ? (i = U7, s = !1) : e.length >= G7 && (i = K7, s = !1, e = new H7(e));
  e:
    for (; ++r < a; ) {
      var u = t[r], d = n == null ? u : n(u);
      if (u = o || u !== 0 ? u : 0, s && d === d) {
        for (var f = c; f--; )
          if (e[f] === d)
            continue e;
        l.push(u);
      } else i(e, d, o) || l.push(u);
    }
  return l;
}
var Y7 = q7;
function J7(t, e) {
  for (var n = -1, o = e.length, r = t.length; ++n < o; )
    t[r + n] = e[n];
  return t;
}
var vS = J7;
function X7(t) {
  return t != null && typeof t == "object";
}
var Ri = X7, Z7 = Hs, Q7 = Ri, eR = "[object Arguments]";
function tR(t) {
  return Q7(t) && Z7(t) == eR;
}
var nR = tR, _y = nR, oR = Ri, yS = Object.prototype, rR = yS.hasOwnProperty, iR = yS.propertyIsEnumerable, sR = _y(/* @__PURE__ */ function() {
  return arguments;
}()) ? _y : function(t) {
  return oR(t) && rR.call(t, "callee") && !iR.call(t, "callee");
}, u1 = sR, aR = Array.isArray, Go = aR, Ay = Gl, lR = u1, cR = Go, Ty = Ay ? Ay.isConcatSpreadable : void 0;
function uR(t) {
  return cR(t) || lR(t) || !!(Ty && t && t[Ty]);
}
var dR = uR, fR = vS, pR = dR;
function bS(t, e, n, o, r) {
  var i = -1, s = t.length;
  for (n || (n = pR), r || (r = []); ++i < s; ) {
    var a = t[i];
    e > 0 && n(a) ? e > 1 ? bS(a, e - 1, n, o, r) : fR(r, a) : o || (r[r.length] = a);
  }
  return r;
}
var hR = bS, mR = gf;
function gR() {
  this.__data__ = new mR(), this.size = 0;
}
var vR = gR;
function yR(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
var bR = yR;
function wR(t) {
  return this.__data__.get(t);
}
var xR = wR;
function CR(t) {
  return this.__data__.has(t);
}
var SR = CR, kR = gf, ER = a1, _R = l1, AR = 200;
function TR(t, e) {
  var n = this.__data__;
  if (n instanceof kR) {
    var o = n.__data__;
    if (!ER || o.length < AR - 1)
      return o.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new _R(o);
  }
  return n.set(t, e), this.size = n.size, this;
}
var OR = TR, MR = gf, IR = vR, RR = bR, $R = xR, PR = SR, LR = OR;
function Ws(t) {
  var e = this.__data__ = new MR(t);
  this.size = e.size;
}
Ws.prototype.clear = IR;
Ws.prototype.delete = RR;
Ws.prototype.get = $R;
Ws.prototype.has = PR;
Ws.prototype.set = LR;
var wS = Ws;
function DR(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length; ++n < o; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
var NR = DR, BR = hS, FR = NR, zR = gS, HR = 1, VR = 2;
function UR(t, e, n, o, r, i) {
  var s = n & HR, a = t.length, l = e.length;
  if (a != l && !(s && l > a))
    return !1;
  var c = i.get(t), u = i.get(e);
  if (c && u)
    return c == e && u == t;
  var d = -1, f = !0, p = n & VR ? new BR() : void 0;
  for (i.set(t, e), i.set(e, t); ++d < a; ) {
    var m = t[d], g = e[d];
    if (o)
      var v = s ? o(g, m, d, e, t, i) : o(m, g, d, t, e, i);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!FR(e, function(y, w) {
        if (!zR(p, w) && (m === y || r(m, y, n, o, i)))
          return p.push(w);
      })) {
        f = !1;
        break;
      }
    } else if (!(m === g || r(m, g, n, o, i))) {
      f = !1;
      break;
    }
  }
  return i.delete(t), i.delete(e), f;
}
var xS = UR, jR = go, WR = jR.Uint8Array, KR = WR;
function GR(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(o, r) {
    n[++e] = [r, o];
  }), n;
}
var qR = GR;
function YR(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(o) {
    n[++e] = o;
  }), n;
}
var JR = YR, Oy = Gl, My = KR, XR = pS, ZR = xS, QR = qR, e$ = JR, t$ = 1, n$ = 2, o$ = "[object Boolean]", r$ = "[object Date]", i$ = "[object Error]", s$ = "[object Map]", a$ = "[object Number]", l$ = "[object RegExp]", c$ = "[object Set]", u$ = "[object String]", d$ = "[object Symbol]", f$ = "[object ArrayBuffer]", p$ = "[object DataView]", Iy = Oy ? Oy.prototype : void 0, Tp = Iy ? Iy.valueOf : void 0;
function h$(t, e, n, o, r, i, s) {
  switch (n) {
    case p$:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case f$:
      return !(t.byteLength != e.byteLength || !i(new My(t), new My(e)));
    case o$:
    case r$:
    case a$:
      return XR(+t, +e);
    case i$:
      return t.name == e.name && t.message == e.message;
    case l$:
    case u$:
      return t == e + "";
    case s$:
      var a = QR;
    case c$:
      var l = o & t$;
      if (a || (a = e$), t.size != e.size && !l)
        return !1;
      var c = s.get(t);
      if (c)
        return c == e;
      o |= n$, s.set(t, e);
      var u = ZR(a(t), a(e), o, r, i, s);
      return s.delete(t), u;
    case d$:
      if (Tp)
        return Tp.call(t) == Tp.call(e);
  }
  return !1;
}
var m$ = h$, g$ = vS, v$ = Go;
function y$(t, e, n) {
  var o = e(t);
  return v$(t) ? o : g$(o, n(t));
}
var b$ = y$;
function w$(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length, r = 0, i = []; ++n < o; ) {
    var s = t[n];
    e(s, n, t) && (i[r++] = s);
  }
  return i;
}
var x$ = w$;
function C$() {
  return [];
}
var S$ = C$, k$ = x$, E$ = S$, _$ = Object.prototype, A$ = _$.propertyIsEnumerable, Ry = Object.getOwnPropertySymbols, T$ = Ry ? function(t) {
  return t == null ? [] : (t = Object(t), k$(Ry(t), function(e) {
    return A$.call(t, e);
  }));
} : E$, O$ = T$;
function M$(t, e) {
  for (var n = -1, o = Array(t); ++n < t; )
    o[n] = e(n);
  return o;
}
var I$ = M$, Gu = { exports: {} };
function R$() {
  return !1;
}
var $$ = R$;
Gu.exports;
(function(t, e) {
  var n = go, o = $$, r = e && !e.nodeType && e, i = r && !0 && t && !t.nodeType && t, s = i && i.exports === r, a = s ? n.Buffer : void 0, l = a ? a.isBuffer : void 0, c = l || o;
  t.exports = c;
})(Gu, Gu.exports);
var CS = Gu.exports, P$ = 9007199254740991, L$ = /^(?:0|[1-9]\d*)$/;
function D$(t, e) {
  var n = typeof t;
  return e = e ?? P$, !!e && (n == "number" || n != "symbol" && L$.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var SS = D$, N$ = 9007199254740991;
function B$(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= N$;
}
var d1 = B$, F$ = Hs, z$ = d1, H$ = Ri, V$ = "[object Arguments]", U$ = "[object Array]", j$ = "[object Boolean]", W$ = "[object Date]", K$ = "[object Error]", G$ = "[object Function]", q$ = "[object Map]", Y$ = "[object Number]", J$ = "[object Object]", X$ = "[object RegExp]", Z$ = "[object Set]", Q$ = "[object String]", eP = "[object WeakMap]", tP = "[object ArrayBuffer]", nP = "[object DataView]", oP = "[object Float32Array]", rP = "[object Float64Array]", iP = "[object Int8Array]", sP = "[object Int16Array]", aP = "[object Int32Array]", lP = "[object Uint8Array]", cP = "[object Uint8ClampedArray]", uP = "[object Uint16Array]", dP = "[object Uint32Array]", et = {};
et[oP] = et[rP] = et[iP] = et[sP] = et[aP] = et[lP] = et[cP] = et[uP] = et[dP] = !0;
et[V$] = et[U$] = et[tP] = et[j$] = et[nP] = et[W$] = et[K$] = et[G$] = et[q$] = et[Y$] = et[J$] = et[X$] = et[Z$] = et[Q$] = et[eP] = !1;
function fP(t) {
  return H$(t) && z$(t.length) && !!et[F$(t)];
}
var pP = fP, qu = { exports: {} };
qu.exports;
(function(t, e) {
  var n = cS, o = e && !e.nodeType && e, r = o && !0 && t && !t.nodeType && t, i = r && r.exports === o, s = i && n.process, a = function() {
    try {
      var l = r && r.require && r.require("util").types;
      return l || s && s.binding && s.binding("util");
    } catch {
    }
  }();
  t.exports = a;
})(qu, qu.exports);
var kS = qu.exports, hP = pP, mP = c1, $y = kS, Py = $y && $y.isTypedArray, gP = Py ? mP(Py) : hP, ES = gP, vP = I$, yP = u1, bP = Go, wP = CS, xP = SS, CP = ES, SP = Object.prototype, kP = SP.hasOwnProperty;
function EP(t, e) {
  var n = bP(t), o = !n && yP(t), r = !n && !o && wP(t), i = !n && !o && !r && CP(t), s = n || o || r || i, a = s ? vP(t.length, String) : [], l = a.length;
  for (var c in t)
    (e || kP.call(t, c)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    xP(c, l))) && a.push(c);
  return a;
}
var _P = EP, AP = Object.prototype;
function TP(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || AP;
  return t === n;
}
var OP = TP;
function MP(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var IP = MP, RP = IP, $P = RP(Object.keys, Object), PP = $P, LP = OP, DP = PP, NP = Object.prototype, BP = NP.hasOwnProperty;
function FP(t) {
  if (!LP(t))
    return DP(t);
  var e = [];
  for (var n in Object(t))
    BP.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
var zP = FP, HP = dS, VP = d1;
function UP(t) {
  return t != null && VP(t.length) && !HP(t);
}
var _S = UP, jP = _P, WP = zP, KP = _S;
function GP(t) {
  return KP(t) ? jP(t) : WP(t);
}
var AS = GP, qP = b$, YP = O$, JP = AS;
function XP(t) {
  return qP(t, JP, YP);
}
var ZP = XP, Ly = ZP, QP = 1, eL = Object.prototype, tL = eL.hasOwnProperty;
function nL(t, e, n, o, r, i) {
  var s = n & QP, a = Ly(t), l = a.length, c = Ly(e), u = c.length;
  if (l != u && !s)
    return !1;
  for (var d = l; d--; ) {
    var f = a[d];
    if (!(s ? f in e : tL.call(e, f)))
      return !1;
  }
  var p = i.get(t), m = i.get(e);
  if (p && m)
    return p == e && m == t;
  var g = !0;
  i.set(t, e), i.set(e, t);
  for (var v = s; ++d < l; ) {
    f = a[d];
    var y = t[f], w = e[f];
    if (o)
      var x = s ? o(w, y, f, e, t, i) : o(y, w, f, t, e, i);
    if (!(x === void 0 ? y === w || r(y, w, n, o, i) : x)) {
      g = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (g && !v) {
    var b = t.constructor, S = e.constructor;
    b != S && "constructor" in t && "constructor" in e && !(typeof b == "function" && b instanceof b && typeof S == "function" && S instanceof S) && (g = !1);
  }
  return i.delete(t), i.delete(e), g;
}
var oL = nL, rL = Ii, iL = go, sL = rL(iL, "DataView"), aL = sL, lL = Ii, cL = go, uL = lL(cL, "Promise"), dL = uL, fL = Ii, pL = go, hL = fL(pL, "Set"), mL = hL, gL = Ii, vL = go, yL = gL(vL, "WeakMap"), bL = yL, om = aL, rm = a1, im = dL, sm = mL, am = bL, TS = Hs, Ks = fS, Dy = "[object Map]", wL = "[object Object]", Ny = "[object Promise]", By = "[object Set]", Fy = "[object WeakMap]", zy = "[object DataView]", xL = Ks(om), CL = Ks(rm), SL = Ks(im), kL = Ks(sm), EL = Ks(am), ni = TS;
(om && ni(new om(new ArrayBuffer(1))) != zy || rm && ni(new rm()) != Dy || im && ni(im.resolve()) != Ny || sm && ni(new sm()) != By || am && ni(new am()) != Fy) && (ni = function(t) {
  var e = TS(t), n = e == wL ? t.constructor : void 0, o = n ? Ks(n) : "";
  if (o)
    switch (o) {
      case xL:
        return zy;
      case CL:
        return Dy;
      case SL:
        return Ny;
      case kL:
        return By;
      case EL:
        return Fy;
    }
  return e;
});
var _L = ni, Op = wS, AL = xS, TL = m$, OL = oL, Hy = _L, Vy = Go, Uy = CS, ML = ES, IL = 1, jy = "[object Arguments]", Wy = "[object Array]", Tc = "[object Object]", RL = Object.prototype, Ky = RL.hasOwnProperty;
function $L(t, e, n, o, r, i) {
  var s = Vy(t), a = Vy(e), l = s ? Wy : Hy(t), c = a ? Wy : Hy(e);
  l = l == jy ? Tc : l, c = c == jy ? Tc : c;
  var u = l == Tc, d = c == Tc, f = l == c;
  if (f && Uy(t)) {
    if (!Uy(e))
      return !1;
    s = !0, u = !1;
  }
  if (f && !u)
    return i || (i = new Op()), s || ML(t) ? AL(t, e, n, o, r, i) : TL(t, e, l, n, o, r, i);
  if (!(n & IL)) {
    var p = u && Ky.call(t, "__wrapped__"), m = d && Ky.call(e, "__wrapped__");
    if (p || m) {
      var g = p ? t.value() : t, v = m ? e.value() : e;
      return i || (i = new Op()), r(g, v, n, o, i);
    }
  }
  return f ? (i || (i = new Op()), OL(t, e, n, o, r, i)) : !1;
}
var PL = $L, LL = PL, Gy = Ri;
function OS(t, e, n, o, r) {
  return t === e ? !0 : t == null || e == null || !Gy(t) && !Gy(e) ? t !== t && e !== e : LL(t, e, n, o, OS, r);
}
var f1 = OS, DL = wS, NL = f1, BL = 1, FL = 2;
function zL(t, e, n, o) {
  var r = n.length, i = r, s = !o;
  if (t == null)
    return !i;
  for (t = Object(t); r--; ) {
    var a = n[r];
    if (s && a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++r < i; ) {
    a = n[r];
    var l = a[0], c = t[l], u = a[1];
    if (s && a[2]) {
      if (c === void 0 && !(l in t))
        return !1;
    } else {
      var d = new DL();
      if (o)
        var f = o(c, u, l, t, e, d);
      if (!(f === void 0 ? NL(u, c, BL | FL, o, d) : f))
        return !1;
    }
  }
  return !0;
}
var HL = zL, VL = Mi;
function UL(t) {
  return t === t && !VL(t);
}
var MS = UL, jL = MS, WL = AS;
function KL(t) {
  for (var e = WL(t), n = e.length; n--; ) {
    var o = e[n], r = t[o];
    e[n] = [o, r, jL(r)];
  }
  return e;
}
var GL = KL;
function qL(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
var IS = qL, YL = HL, JL = GL, XL = IS;
function ZL(t) {
  var e = JL(t);
  return e.length == 1 && e[0][2] ? XL(e[0][0], e[0][1]) : function(n) {
    return n === t || YL(n, t, e);
  };
}
var QL = ZL, eD = Hs, tD = Ri, nD = "[object Symbol]";
function oD(t) {
  return typeof t == "symbol" || tD(t) && eD(t) == nD;
}
var yf = oD, rD = Go, iD = yf, sD = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, aD = /^\w*$/;
function lD(t, e) {
  if (rD(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || iD(t) ? !0 : aD.test(t) || !sD.test(t) || e != null && t in Object(e);
}
var p1 = lD, RS = l1, cD = "Expected a function";
function h1(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(cD);
  var n = function() {
    var o = arguments, r = e ? e.apply(this, o) : o[0], i = n.cache;
    if (i.has(r))
      return i.get(r);
    var s = t.apply(this, o);
    return n.cache = i.set(r, s) || i, s;
  };
  return n.cache = new (h1.Cache || RS)(), n;
}
h1.Cache = RS;
var uD = h1, dD = uD, fD = 500;
function pD(t) {
  var e = dD(t, function(o) {
    return n.size === fD && n.clear(), o;
  }), n = e.cache;
  return e;
}
var hD = pD, mD = hD, gD = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, vD = /\\(\\)?/g, yD = mD(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(gD, function(n, o, r, i) {
    e.push(r ? i.replace(vD, "$1") : o || n);
  }), e;
}), bD = yD, qy = Gl, wD = mS, xD = Go, CD = yf, Yy = qy ? qy.prototype : void 0, Jy = Yy ? Yy.toString : void 0;
function $S(t) {
  if (typeof t == "string")
    return t;
  if (xD(t))
    return wD(t, $S) + "";
  if (CD(t))
    return Jy ? Jy.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var PS = $S, SD = PS;
function kD(t) {
  return t == null ? "" : SD(t);
}
var LS = kD, ED = Go, _D = p1, AD = bD, TD = LS;
function OD(t, e) {
  return ED(t) ? t : _D(t, e) ? [t] : AD(TD(t));
}
var DS = OD, MD = yf;
function ID(t) {
  if (typeof t == "string" || MD(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var bf = ID, RD = DS, $D = bf;
function PD(t, e) {
  e = RD(e, t);
  for (var n = 0, o = e.length; t != null && n < o; )
    t = t[$D(e[n++])];
  return n && n == o ? t : void 0;
}
var NS = PD, LD = NS;
function DD(t, e, n) {
  var o = t == null ? void 0 : LD(t, e);
  return o === void 0 ? n : o;
}
var ND = DD;
function BD(t, e) {
  return t != null && e in Object(t);
}
var FD = BD, zD = DS, HD = u1, VD = Go, UD = SS, jD = d1, WD = bf;
function KD(t, e, n) {
  e = zD(e, t);
  for (var o = -1, r = e.length, i = !1; ++o < r; ) {
    var s = WD(e[o]);
    if (!(i = t != null && n(t, s)))
      break;
    t = t[s];
  }
  return i || ++o != r ? i : (r = t == null ? 0 : t.length, !!r && jD(r) && UD(s, r) && (VD(t) || HD(t)));
}
var GD = KD, qD = FD, YD = GD;
function JD(t, e) {
  return t != null && YD(t, e, qD);
}
var XD = JD, ZD = f1, QD = ND, e9 = XD, t9 = p1, n9 = MS, o9 = IS, r9 = bf, i9 = 1, s9 = 2;
function a9(t, e) {
  return t9(t) && n9(e) ? o9(r9(t), e) : function(n) {
    var o = QD(n, t);
    return o === void 0 && o === e ? e9(n, t) : ZD(e, o, i9 | s9);
  };
}
var l9 = a9;
function c9(t) {
  return t;
}
var m1 = c9;
function u9(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
var BS = u9, d9 = NS;
function f9(t) {
  return function(e) {
    return d9(e, t);
  };
}
var p9 = f9, h9 = BS, m9 = p9, g9 = p1, v9 = bf;
function y9(t) {
  return g9(t) ? h9(v9(t)) : m9(t);
}
var b9 = y9, w9 = QL, x9 = l9, C9 = m1, S9 = Go, k9 = b9;
function E9(t) {
  return typeof t == "function" ? t : t == null ? C9 : typeof t == "object" ? S9(t) ? x9(t[0], t[1]) : w9(t) : k9(t);
}
var _9 = E9;
function A9(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
var T9 = A9, O9 = T9, Xy = Math.max;
function M9(t, e, n) {
  return e = Xy(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var o = arguments, r = -1, i = Xy(o.length - e, 0), s = Array(i); ++r < i; )
      s[r] = o[e + r];
    r = -1;
    for (var a = Array(e + 1); ++r < e; )
      a[r] = o[r];
    return a[e] = n(s), O9(t, this, a);
  };
}
var I9 = M9;
function R9(t) {
  return function() {
    return t;
  };
}
var $9 = R9, P9 = Ii, L9 = function() {
  try {
    var t = P9(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), D9 = L9, N9 = $9, Zy = D9, B9 = m1, F9 = Zy ? function(t, e) {
  return Zy(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: N9(e),
    writable: !0
  });
} : B9, z9 = F9, H9 = 800, V9 = 16, U9 = Date.now;
function j9(t) {
  var e = 0, n = 0;
  return function() {
    var o = U9(), r = V9 - (o - n);
    if (n = o, r > 0) {
      if (++e >= H9)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var W9 = j9, K9 = z9, G9 = W9, q9 = G9(K9), Y9 = q9, J9 = m1, X9 = I9, Z9 = Y9;
function Q9(t, e) {
  return Z9(X9(t, e, J9), t + "");
}
var eN = Q9, tN = _S, nN = Ri;
function oN(t) {
  return nN(t) && tN(t);
}
var rN = oN;
function iN(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var sN = iN, aN = Y7, lN = hR, cN = _9, uN = eN, Mp = rN, dN = sN, fN = uN(function(t, e) {
  var n = dN(e);
  return Mp(n) && (n = void 0), Mp(t) ? aN(t, lN(e, 1, Mp, !0), cN(n)) : [];
}), pN = fN;
const hN = /* @__PURE__ */ Kl(pN);
var mN = f1;
function gN(t, e) {
  return mN(t, e);
}
var vN = gN;
const yN = /* @__PURE__ */ Kl(vN);
var bN = go, wN = function() {
  return bN.Date.now();
}, xN = wN, CN = /\s/;
function SN(t) {
  for (var e = t.length; e-- && CN.test(t.charAt(e)); )
    ;
  return e;
}
var kN = SN, EN = kN, _N = /^\s+/;
function AN(t) {
  return t && t.slice(0, EN(t) + 1).replace(_N, "");
}
var TN = AN, ON = TN, Qy = Mi, MN = yf, eb = NaN, IN = /^[-+]0x[0-9a-f]+$/i, RN = /^0b[01]+$/i, $N = /^0o[0-7]+$/i, PN = parseInt;
function LN(t) {
  if (typeof t == "number")
    return t;
  if (MN(t))
    return eb;
  if (Qy(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Qy(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = ON(t);
  var n = RN.test(t);
  return n || $N.test(t) ? PN(t.slice(2), n ? 2 : 8) : IN.test(t) ? eb : +t;
}
var FS = LN, DN = Mi, Ip = xN, tb = FS, NN = "Expected a function", BN = Math.max, FN = Math.min;
function zN(t, e, n) {
  var o, r, i, s, a, l, c = 0, u = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(NN);
  e = tb(e) || 0, DN(n) && (u = !!n.leading, d = "maxWait" in n, i = d ? BN(tb(n.maxWait) || 0, e) : i, f = "trailing" in n ? !!n.trailing : f);
  function p(k) {
    var A = o, $ = r;
    return o = r = void 0, c = k, s = t.apply($, A), s;
  }
  function m(k) {
    return c = k, a = setTimeout(y, e), u ? p(k) : s;
  }
  function g(k) {
    var A = k - l, $ = k - c, O = e - A;
    return d ? FN(O, i - $) : O;
  }
  function v(k) {
    var A = k - l, $ = k - c;
    return l === void 0 || A >= e || A < 0 || d && $ >= i;
  }
  function y() {
    var k = Ip();
    if (v(k))
      return w(k);
    a = setTimeout(y, g(k));
  }
  function w(k) {
    return a = void 0, f && o ? p(k) : (o = r = void 0, s);
  }
  function x() {
    a !== void 0 && clearTimeout(a), c = 0, o = l = r = a = void 0;
  }
  function b() {
    return a === void 0 ? s : w(Ip());
  }
  function S() {
    var k = Ip(), A = v(k);
    if (o = arguments, r = this, l = k, A) {
      if (a === void 0)
        return m(l);
      if (d)
        return clearTimeout(a), a = setTimeout(y, e), p(l);
    }
    return a === void 0 && (a = setTimeout(y, e)), s;
  }
  return S.cancel = x, S.flush = b, S;
}
var zS = zN;
const HS = /* @__PURE__ */ Kl(zS);
var HN = zS, VN = Mi, UN = "Expected a function";
function jN(t, e, n) {
  var o = !0, r = !0;
  if (typeof t != "function")
    throw new TypeError(UN);
  return VN(n) && (o = "leading" in n ? !!n.leading : o, r = "trailing" in n ? !!n.trailing : r), HN(t, e, {
    leading: o,
    maxWait: e,
    trailing: r
  });
}
var WN = jN;
const Yu = /* @__PURE__ */ Kl(WN);
function KN(t, e, n) {
  var o = -1, r = t.length;
  e < 0 && (e = -e > r ? 0 : r + e), n = n > r ? r : n, n < 0 && (n += r), r = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var i = Array(r); ++o < r; )
    i[o] = t[o + e];
  return i;
}
var GN = KN, qN = GN;
function YN(t, e, n) {
  var o = t.length;
  return n = n === void 0 ? o : n, !e && n >= o ? t : qN(t, e, n);
}
var JN = YN, XN = "\\ud800-\\udfff", ZN = "\\u0300-\\u036f", QN = "\\ufe20-\\ufe2f", eB = "\\u20d0-\\u20ff", tB = ZN + QN + eB, nB = "\\ufe0e\\ufe0f", oB = "\\u200d", rB = RegExp("[" + oB + XN + tB + nB + "]");
function iB(t) {
  return rB.test(t);
}
var g1 = iB, sB = Hs, aB = Ri, lB = "[object RegExp]";
function cB(t) {
  return aB(t) && sB(t) == lB;
}
var uB = cB, dB = uB, fB = c1, nb = kS, ob = nb && nb.isRegExp, pB = ob ? fB(ob) : dB, hB = pB, mB = BS, gB = mB("length"), vB = gB, VS = "\\ud800-\\udfff", yB = "\\u0300-\\u036f", bB = "\\ufe20-\\ufe2f", wB = "\\u20d0-\\u20ff", xB = yB + bB + wB, CB = "\\ufe0e\\ufe0f", SB = "[" + VS + "]", lm = "[" + xB + "]", cm = "\\ud83c[\\udffb-\\udfff]", kB = "(?:" + lm + "|" + cm + ")", US = "[^" + VS + "]", jS = "(?:\\ud83c[\\udde6-\\uddff]){2}", WS = "[\\ud800-\\udbff][\\udc00-\\udfff]", EB = "\\u200d", KS = kB + "?", GS = "[" + CB + "]?", _B = "(?:" + EB + "(?:" + [US, jS, WS].join("|") + ")" + GS + KS + ")*", AB = GS + KS + _B, TB = "(?:" + [US + lm + "?", lm, jS, WS, SB].join("|") + ")", rb = RegExp(cm + "(?=" + cm + ")|" + TB + AB, "g");
function OB(t) {
  for (var e = rb.lastIndex = 0; rb.test(t); )
    ++e;
  return e;
}
var MB = OB, IB = vB, RB = g1, $B = MB;
function PB(t) {
  return RB(t) ? $B(t) : IB(t);
}
var LB = PB;
function DB(t) {
  return t.split("");
}
var NB = DB, qS = "\\ud800-\\udfff", BB = "\\u0300-\\u036f", FB = "\\ufe20-\\ufe2f", zB = "\\u20d0-\\u20ff", HB = BB + FB + zB, VB = "\\ufe0e\\ufe0f", UB = "[" + qS + "]", um = "[" + HB + "]", dm = "\\ud83c[\\udffb-\\udfff]", jB = "(?:" + um + "|" + dm + ")", YS = "[^" + qS + "]", JS = "(?:\\ud83c[\\udde6-\\uddff]){2}", XS = "[\\ud800-\\udbff][\\udc00-\\udfff]", WB = "\\u200d", ZS = jB + "?", QS = "[" + VB + "]?", KB = "(?:" + WB + "(?:" + [YS, JS, XS].join("|") + ")" + QS + ZS + ")*", GB = QS + ZS + KB, qB = "(?:" + [YS + um + "?", um, JS, XS, UB].join("|") + ")", YB = RegExp(dm + "(?=" + dm + ")|" + qB + GB, "g");
function JB(t) {
  return t.match(YB) || [];
}
var XB = JB, ZB = NB, QB = g1, eF = XB;
function tF(t) {
  return QB(t) ? eF(t) : ZB(t);
}
var nF = tF, oF = FS, rF = 1 / 0, iF = 17976931348623157e292;
function sF(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = oF(t), t === rF || t === -1 / 0) {
    var e = t < 0 ? -1 : 1;
    return e * iF;
  }
  return t === t ? t : 0;
}
var aF = sF, lF = aF;
function cF(t) {
  var e = lF(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
var uF = cF, ib = PS, dF = JN, fF = g1, pF = Mi, hF = hB, mF = LB, gF = nF, vF = uF, sb = LS, yF = 30, bF = "...", wF = /\w*$/;
function xF(t, e) {
  var n = yF, o = bF;
  if (pF(e)) {
    var r = "separator" in e ? e.separator : r;
    n = "length" in e ? vF(e.length) : n, o = "omission" in e ? ib(e.omission) : o;
  }
  t = sb(t);
  var i = t.length;
  if (fF(t)) {
    var s = gF(t);
    i = s.length;
  }
  if (n >= i)
    return t;
  var a = n - mF(o);
  if (a < 1)
    return o;
  var l = s ? dF(s, 0, a).join("") : t.slice(0, a);
  if (r === void 0)
    return l + o;
  if (s && (a += l.length - a), hF(r)) {
    if (t.slice(a).search(r)) {
      var c, u = l;
      for (r.global || (r = RegExp(r.source, sb(wF.exec(r)) + "g")), r.lastIndex = 0; c = r.exec(u); )
        var d = c.index;
      l = l.slice(0, d === void 0 ? a : d);
    }
  } else if (t.indexOf(ib(r), a) != a) {
    var f = l.lastIndexOf(r);
    f > -1 && (l = l.slice(0, f));
  }
  return l + o;
}
var CF = xF;
const SF = /* @__PURE__ */ Kl(CF), fu = (t, e = "px") => {
  if (!t) return t;
  const n = fm(t) ? String(t) : t, o = parseFloat(n), r = n.match(/[a-zA-Z%]+$/), i = r ? r[0] : e;
  return isNaN(o) ? t : o + i;
};
function kF(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
const fm = (t) => typeof t == "number", EF = (t) => typeof t == "function";
function Fe(t, e) {
  const { extensions: n = [] } = t.extensionManager ?? {};
  return !!n.find((r) => r.name === e);
}
const _F = {
  "editor.remove": "删除",
  "editor.copy": "复制",
  "editor.words": "单词",
  "editor.characters": "字符",
  "editor.default": "默认",
  "editor.recent": "最近使用",
  "editor.moremark": "更多文本样式",
  "editor.nofill": "无填充色",
  "editor.format": "格式刷",
  "editor.close": "关闭",
  "editor.modify": "修改",
  "editor.preview.tooltip": "预览",
  "editor.draghandle.tooltip": "可拖拽和点击",
  "editor.copyToClipboard": "复制到剪切板",
  "editor.importWord.tooltip": "导入Word",
  "editor.importWord.success": "导入成功",
  "editor.importWord.fileTooLarge": "文件大小超出限制",
  "editor.importWord.error": "导入失败,文件不支持",
  "editor.slash": "输入 '/' 唤起更多",
  "editor.slash.empty": "暂无搜索结果",
  "editor.slash.format": "格式",
  "editor.slash.insert": "插入",
  "editor.slash.embed": "嵌入第三方服务",
  "editor.content": "请输入正文",
  "editor.size.small.tooltip": "小尺寸",
  "editor.size.medium.tooltip": "中等尺寸",
  "editor.size.large.tooltip": "铺满",
  "editor.bold.tooltip": "粗体",
  "editor.italic.tooltip": "斜体",
  "editor.underline.tooltip": "下划线",
  "editor.strike.tooltip": "删除线",
  "editor.color.tooltip": "文本颜色",
  "editor.color.more": "更多颜色",
  "editor.lineheight.tooltip": "行高",
  "editor.highlight.tooltip": "文本高亮",
  "editor.heading.tooltip": "正文与标题",
  "editor.heading.h1.tooltip": "标题 1",
  "editor.heading.h2.tooltip": "标题 2",
  "editor.heading.h3.tooltip": "标题 3",
  "editor.heading.h4.tooltip": "标题 4",
  "editor.heading.h5.tooltip": "标题 5",
  "editor.heading.h6.tooltip": "标题 6",
  "editor.paragraph.tooltip": "正文",
  "editor.textalign.tooltip": "对齐方式",
  "editor.textalign.left.tooltip": "左对齐",
  "editor.textalign.center.tooltip": "居中对齐",
  "editor.textalign.right.tooltip": "右对齐",
  "editor.textalign.justify.tooltip": "两端对齐",
  "editor.fontFamily.tooltip": "字体",
  "editor.fontFamily.default": "默认字体",
  "editor.fontSize.tooltip": "字号调整",
  "editor.fontSize.default.tooltip": "默认字号",
  "editor.superscript.tooltip": "上标",
  "editor.subscript.tooltip": "下标",
  "editor.bulletlist.tooltip": "无序列表",
  "editor.bulletlist.disc.tooltip": "默认",
  "editor.bulletlist.circle.tooltip": "空心圆",
  "editor.bulletlist.square.tooltip": "方形",
  "editor.orderedlist.tooltip": "有序列表",
  "editor.orderedlist.decimal.tooltip": "默认",
  "editor.orderedlist.decimalLeadingZero.tooltip": "补零数字",
  "editor.orderedlist.lowerRoman.tooltip": "小写罗马数字",
  "editor.orderedlist.upperRoman.tooltip": "大写罗马数字",
  "editor.orderedlist.lowerLatin.tooltip": "小写英文编号",
  "editor.orderedlist.upperLatin.tooltip": "大写英文编号",
  "editor.orderedlist.tradChineseInformal.tooltip": "中文编号",
  "editor.orderedlist.simpChineseFormal.tooltip": "大写中文编号",
  "editor.tasklist.tooltip": "任务列表",
  "editor.indent": "缩进调整",
  "editor.indent.tooltip": "增加缩进",
  "editor.outdent.tooltip": "减少缩进",
  "editor.columns.tooltip": "分栏",
  "editor.link.tooltip": "链接",
  "editor.link.unlink.tooltip": "取消链接",
  "editor.link.open.tooltip": "打开链接",
  "editor.link.edit.tooltip": "编辑链接",
  "editor.link.dialog.title": "插入链接",
  "editor.link.dialog.link": "链接",
  "editor.link.dialog.text": "文本",
  "editor.link.dialog.openInNewTab": "是否在新窗口打开",
  "editor.link.dialog.link.placeholder": "链接地址",
  "editor.link.dialog.text.placeholder": "添加描述",
  "editor.link.dialog.button.apply": "应用",
  "editor.image.tooltip": "图片",
  "editor.image.menu.flipX": "水平翻转",
  "editor.image.menu.flipY": "垂直翻转",
  "editor.image.menu.size": "宽高",
  "editor.image.menu.size.width": "宽度",
  "editor.image.menu.size.height": "高度",
  "editor.image.dragger.tooltip": "点击或者拖动图片到该区域来上传",
  "editor.image.float.left.tooltip": "左浮动",
  "editor.image.float.none.tooltip": "无浮动",
  "editor.image.float.right.tooltip": "右浮动",
  "editor.image.dialog.title": "插入图片",
  "editor.image.dialog.tab.url": "网络图片",
  "editor.image.dialog.tab.upload": "上传",
  "editor.image.dialog.uploading": "正在上传",
  "editor.image.dialog.form.link": "链接",
  "editor.image.dialog.placeholder": "请输入图片链接",
  "editor.image.dialog.form.alt": "说明",
  "editor.image.dialog.form.aspectRatio": "锁定原有长宽比",
  "editor.image.dialog.form.file": "文件",
  "editor.image.dialog.button.apply": "应用",
  "editor.video.tooltip": "视频",
  "editor.video.dialog.tab.upload": "上传",
  "editor.video.dialog.uploading": "正在上传",
  "editor.video.dialog.title": "插入视频",
  "editor.video.dialog.link": "网络链接",
  "editor.video.dialog.placeholder": "请输入链接地址",
  "editor.video.dialog.button.apply": "应用",
  "editor.table.tooltip": "表格",
  "editor.table.menu.insert_table": "插入表格",
  "editor.table.menu.insert_table.with_header_row": "带标题行",
  "editor.table.menu.insertColumnBefore": "向左插入一列",
  "editor.table.menu.insertColumnAfter": "向右插入一列",
  "editor.table.menu.deleteColumn": "删除列",
  "editor.table.menu.insertRowAbove": "向上插入一行",
  "editor.table.menu.insertRowBelow": "向下插入一行",
  "editor.table.menu.deleteRow": "删除行",
  "editor.table.menu.mergeCells": "合并单元格",
  "editor.table.menu.splitCells": "拆分单元格",
  "editor.table.menu.deleteTable": "删除表格",
  "editor.table.menu.setCellsBgColor": "单元格背景颜色",
  "editor.blockquote.tooltip": "引用",
  "editor.horizontalrule.tooltip": "分隔线",
  "editor.code.tooltip": "代码",
  "editor.codeblock.tooltip": "代码块",
  "editor.clear.tooltip": "清除格式",
  "editor.undo.tooltip": "撤销",
  "editor.redo.tooltip": "重做",
  "editor.fullscreen.tooltip.fullscreen": "全屏",
  "editor.fullscreen.tooltip.exit": "退出全屏",
  "editor.imageUpload.fileTypeNotSupported": "图片类型不支持",
  "editor.imageUpload.fileSizeTooBig": "图片大小不支持, 最大",
  "editor.AI.placeholder": "向智能助手提问 ...",
  "editor.AI.generating": "正在生成",
  "editor.AI.insert": "插入选区下方",
  "editor.AI.replace": "替换选中内容",
  "editor.AI.regenerate": "重新生成",
  "editor.AI.close": "关闭",
  "editor.AI.stop": "停止",
  "editor.AI.ask": "智能助手",
  "editor.AI.error": "AI 错误",
  "editor.AI.editorNotFound": "未找到编辑器",
  "editor.AI.noSelection": "请先选择一些文本",
  "editor.AI.unknownError": "发生未知错误",
  "editor.AI.noCachedPrompt": "未找到缓存的提示",
  "editor.AI.regenerateError": "重新生成失败",
  "editor.AI.shortcutError": "快捷操作执行失败",
  "editor.menubar.file": "文件",
  "editor.menubar.edit": "编辑",
  "editor.menubar.view": "视图",
  "editor.menubar.insert": "插入",
  "editor.menubar.format": "格式",
  "editor.menubar.menu.newDoc": "新的文档",
  "editor.menubar.menu.restoreLastDraft": "恢复上一次的草稿",
  "editor.menubar.menu.print": "打印",
  "editor.menubar.menu.cut": "剪切",
  "editor.menubar.menu.copy": "复制",
  "editor.menubar.menu.paste": "黏贴",
  "editor.menubar.menu.pasteAsText": "纯文本黏贴",
  "editor.menubar.menu.selectAll": "全选",
  "editor.menubar.menu.preview": "预览",
  "editor.menubar.menu.spellCheck": "拼写检查",
  "editor.findAndReplace.tooltip": "查找和替换",
  "editor.findAndReplace.find": "查找",
  "editor.findAndReplace.replace": "替换",
  "editor.findAndReplace.replaceAll": "全部替换",
  "editor.findAndReplace.caseSensitive": "区分大小写",
  "editor.printer.tooltip": "打印",
  "editor.AI.shortcuts.generate.title": "从选中内容生成",
  "editor.AI.shortcuts.generate.improve": "改进写作",
  "editor.AI.shortcuts.generate.shorter": "精简内容",
  "editor.AI.shortcuts.generate.longer": "扩展内容",
  "editor.AI.shortcuts.generate.summarize": "总结内容",
  "editor.AI.shortcuts.generate.continue": "继续写作",
  "editor.AI.shortcuts.tone.title": "改变语气",
  "editor.AI.shortcuts.tone.professional": "专业的",
  "editor.AI.shortcuts.tone.casual": "随意的",
  "editor.AI.shortcuts.tone.direct": "直接的",
  "editor.AI.shortcuts.tone.confident": "自信的",
  "editor.AI.shortcuts.tone.friendly": "友好的",
  "editor.AI.shortcuts.translate.title": "翻译",
  "editor.AI.shortcuts.translate.english": "英语",
  "editor.AI.shortcuts.translate.chinese": "简体中文",
  "editor.AI.shortcuts.translate.spanish": "西班牙语",
  "editor.AI.shortcuts.translate.german": "德语",
  "editor.AI.shortcuts.translate.french": "法语",
  "editor.AI.shortcuts.translate.portuguese": "葡萄牙语",
  "editor.AI.shortcuts.translate.korean": "韩语",
  "editor.AI.shortcuts.translate.japanese": "日语",
  "editor.AI.shortcuts.translate.hindi": "印地语",
  "editor.AI.shortcuts.translate.russian": "俄语",
  "editor.AI.shortcuts.translate.arabic": "阿拉伯语",
  "editor.AI.shortcuts.style.title": "改变风格",
  "editor.AI.shortcuts.style.business": "商务",
  "editor.AI.shortcuts.style.legal": "法律",
  "editor.AI.shortcuts.style.journalism": "新闻",
  "editor.AI.shortcuts.style.medical": "医疗",
  "editor.AI.shortcuts.style.poetic": "诗意的",
  "editor.codeblock.selectLang": "选择语言",
  "editor.codeblock.copy": "复制代码",
  "editor.codeblock.lineNumbers": "显示/隐藏行号",
  "editor.codeblock.wordWrap": "自动换行",
  "editor.codeblock.tabSize": "缩进大小"
}, AF = {
  "editor.remove": "Remove",
  "editor.copy": "Copy",
  "editor.words": "WORDS",
  "editor.characters": "CHARACTERS",
  "editor.default": "Default",
  "editor.recent": "Recently Used",
  "editor.nofill": "Remove Color",
  "editor.format": "Format Painter",
  "editor.close": "Close",
  "editor.modify": "Modify",
  "editor.preview.tooltip": "Preview",
  "editor.draghandle.tooltip": "Click And Drag",
  "editor.copyToClipboard": "CopyToClipboard",
  "editor.importWord.tooltip": "Import from Word",
  "editor.importWord.success": "Import Success",
  "editor.importWord.fileTooLarge": "File is Too large",
  "editor.importWord.error": "Import Failed, File not supported",
  "editor.slash": "Press '/' for commands",
  "editor.slash.empty": "No Result",
  "editor.slash.format": "Format",
  "editor.slash.insert": "Insert",
  "editor.slash.embed": "Embed Services",
  "editor.content": "Please input content",
  "editor.moremark": "More Text Styles",
  "editor.size.small.tooltip": "Small",
  "editor.size.medium.tooltip": "Medium",
  "editor.size.large.tooltip": "Cover",
  "editor.bold.tooltip": "Bold",
  "editor.italic.tooltip": "Italic",
  "editor.underline.tooltip": "Underline",
  "editor.strike.tooltip": "Strike",
  "editor.color.tooltip": "Color",
  "editor.color.more": "Color Picker",
  "editor.highlight.tooltip": "Highlight",
  "editor.lineheight.tooltip": "Line Height",
  "editor.heading.tooltip": "Headings",
  "editor.heading.h1.tooltip": "Heading 1",
  "editor.heading.h2.tooltip": "Heading 2",
  "editor.heading.h3.tooltip": "Heading 3",
  "editor.heading.h4.tooltip": "Heading 4",
  "editor.heading.h5.tooltip": "Heading 5",
  "editor.heading.h6.tooltip": "Heading 6",
  "editor.paragraph.tooltip": "Paragraph",
  "editor.textalign.tooltip": "Align",
  "editor.textalign.left.tooltip": "Left",
  "editor.textalign.center.tooltip": "Center",
  "editor.textalign.right.tooltip": "Right",
  "editor.textalign.justify.tooltip": "Justify",
  "editor.indent": "Indent",
  "editor.indent.indent": "Increase Indent",
  "editor.indent.outdent": "Decrease Indent",
  "editor.fontFamily.tooltip": "Font family",
  "editor.fontFamily.default": "Default",
  "editor.fontSize.tooltip": "Font size",
  "editor.fontSize.default.tooltip": "Default",
  "editor.superscript.tooltip": "Superscript",
  "editor.subscript.tooltip": "Subscript",
  "editor.bulletlist.tooltip": "Bullet List",
  "editor.bulletlist.disc.tooltip": "Disc",
  "editor.bulletlist.circle.tooltip": "Circle",
  "editor.bulletlist.square.tooltip": "Square",
  "editor.orderedlist.tooltip": "Ordered List",
  "editor.orderedlist.decimal.tooltip": "Decimal",
  "editor.orderedlist.decimalLeadingZero.tooltip": "Decimal with leading zero",
  "editor.orderedlist.lowerRoman.tooltip": "Lower Roman",
  "editor.orderedlist.upperRoman.tooltip": "Upper Roman",
  "editor.orderedlist.lowerLatin.tooltip": "Lower Latin",
  "editor.orderedlist.upperLatin.tooltip": "Upper Latin",
  "editor.orderedlist.tradChineseInformal.tooltip": "Trad Chinese Informal",
  "editor.orderedlist.simpChineseFormal.tooltip": "Simp Chinese Informal",
  "editor.tasklist.tooltip": "Task List",
  "editor.indent.tooltip": "Indent",
  "editor.outdent.tooltip": "Outdent",
  "editor.columns.tooltip": "Columns",
  "editor.link.tooltip": "Link",
  "editor.link.unlink.tooltip": "UnLink",
  "editor.link.open.tooltip": "Open Link",
  "editor.link.edit.tooltip": "Edit Link",
  "editor.link.dialog.title": "Insert Link",
  "editor.link.dialog.link": "Link",
  "editor.link.dialog.text": "Text",
  "editor.link.dialog.openInNewTab": "Open In New Tab",
  "editor.link.dialog.link.placeholder": "Link Address",
  "editor.link.dialog.text.placeholder": "Add Description",
  "editor.link.dialog.button.apply": "Apply",
  "editor.image.tooltip": "Image",
  "editor.image.menu.flipX": "Flip vertical",
  "editor.image.menu.flipY": "Flip horizontal",
  "editor.image.menu.size": "Set Size",
  "editor.image.menu.size.width": "Width",
  "editor.image.menu.size.height": "Height",
  "editor.image.dragger.tooltip": "Click or drag the image to the area to upload",
  "editor.image.float.left.tooltip": "Float left",
  "editor.image.float.none.tooltip": "Float none",
  "editor.image.float.right.tooltip": "Float right",
  "editor.image.dialog.title": "Add an image",
  "editor.image.dialog.tab.url": "Url",
  "editor.image.dialog.tab.upload": "Upload",
  "editor.image.dialog.uploading": "Uploading",
  "editor.image.dialog.form.link": "Link",
  "editor.image.dialog.placeholder": "Link",
  "editor.image.dialog.form.alt": "Alt",
  "editor.image.dialog.form.aspectRatio": "Lock original aspect ratio",
  "editor.image.dialog.form.file": "File",
  "editor.image.dialog.button.apply": "apply",
  "editor.video.tooltip": "Video",
  "editor.video.dialog.tab.upload": "Upload",
  "editor.video.dialog.uploading": "Uploading",
  "editor.video.dialog.title": "Embed or upload a video",
  "editor.video.dialog.link": "link",
  "editor.video.dialog.placeholder": "Link",
  "editor.video.dialog.button.apply": "apply",
  "editor.table.tooltip": "Table",
  "editor.table.menu.insert_table": "Insert Table",
  "editor.table.menu.insert_table.with_header_row": "With header row",
  "editor.table.menu.insertColumnBefore": "Insert Column Before",
  "editor.table.menu.insertColumnAfter": "Insert Column After",
  "editor.table.menu.deleteColumn": "Delete Column",
  "editor.table.menu.insertRowAbove": "Insert Row Above",
  "editor.table.menu.insertRowBelow": "Insert Row Below",
  "editor.table.menu.deleteRow": "Delete Row",
  "editor.table.menu.mergeCells": "Merge Cells",
  "editor.table.menu.splitCells": "Split Cells",
  "editor.table.menu.deleteTable": "Delete Table",
  "editor.table.menu.setCellsBgColor": "Cell Background Color",
  "editor.blockquote.tooltip": "Blockquote",
  "editor.horizontalrule.tooltip": "Horizontal Rule",
  "editor.code.tooltip": "Code",
  "editor.codeblock.tooltip": "Code Block",
  "editor.clear.tooltip": "Clear Format",
  "editor.undo.tooltip": "Undo",
  "editor.redo.tooltip": "Redo",
  "editor.fullscreen.tooltip.fullscreen": "Fullscreen",
  "editor.fullscreen.tooltip.exit": "Fullscreen Exit",
  "editor.imageUpload.fileTypeNotSupported": "File type not supported",
  "editor.imageUpload.fileSizeTooBig": "File size too big, Maximum size is",
  "editor.AI.placeholder": "Ask AI ...",
  "editor.AI.generating": "Generating",
  "editor.AI.insert": "Insert below selection",
  "editor.AI.replace": "Replace selected content",
  "editor.AI.regenerate": "Regenerate",
  "editor.AI.close": "Close",
  "editor.AI.stop": "Stop",
  "editor.AI.ask": "Ask AI",
  "editor.AI.error": "AI Error",
  "editor.AI.editorNotFound": "Editor not found",
  "editor.AI.noSelection": "Please select some text first",
  "editor.AI.unknownError": "An unknown error occurred",
  "editor.AI.noCachedPrompt": "No cached prompt found",
  "editor.AI.regenerateError": "Failed to regenerate response",
  "editor.AI.shortcutError": "Failed to execute shortcut",
  "editor.menubar.file": "File",
  "editor.menubar.edit": "Edit",
  "editor.menubar.view": "View",
  "editor.menubar.insert": "Insert",
  "editor.menubar.format": "Format",
  "editor.menubar.menu.newDoc": "New Document",
  "editor.menubar.menu.restoreLastDraft": "Restore last draft",
  "editor.menubar.menu.print": "Print",
  "editor.menubar.menu.cut": "Cut",
  "editor.menubar.menu.copy": "Copy",
  "editor.menubar.menu.paste": "Paste",
  "editor.menubar.menu.pasteAsText": "Paste as text",
  "editor.menubar.menu.selectAll": "Select all",
  "editor.menubar.menu.preview": "Preview",
  "editor.menubar.menu.spellCheck": "Spell check",
  "editor.findAndReplace.tooltip": "Find and replace",
  "editor.findAndReplace.find": "Find",
  "editor.findAndReplace.replace": "Replace",
  "editor.findAndReplace.replaceAll": "Replace All",
  "editor.findAndReplace.caseSensitive": "Case Sensitive",
  "editor.printer.tooltip": "Print",
  "editor.AI.shortcuts.generate.title": "Generate from selection",
  "editor.AI.shortcuts.generate.improve": "Improve writing",
  "editor.AI.shortcuts.generate.shorter": "Make shorter",
  "editor.AI.shortcuts.generate.longer": "Make longer",
  "editor.AI.shortcuts.generate.summarize": "Summarize",
  "editor.AI.shortcuts.generate.continue": "Continue",
  "editor.AI.shortcuts.tone.title": "Change Tone",
  "editor.AI.shortcuts.tone.professional": "Professional",
  "editor.AI.shortcuts.tone.casual": "Casual",
  "editor.AI.shortcuts.tone.direct": "Direct",
  "editor.AI.shortcuts.tone.confident": "Confident",
  "editor.AI.shortcuts.tone.friendly": "Friendly",
  "editor.AI.shortcuts.translate.title": "Translate",
  "editor.AI.shortcuts.translate.english": "English",
  "editor.AI.shortcuts.translate.chinese": "Simplified Chinese",
  "editor.AI.shortcuts.translate.spanish": "Spanish",
  "editor.AI.shortcuts.translate.german": "German",
  "editor.AI.shortcuts.translate.french": "French",
  "editor.AI.shortcuts.translate.portuguese": "Portuguese",
  "editor.AI.shortcuts.translate.korean": "Korean",
  "editor.AI.shortcuts.translate.japanese": "Japanese",
  "editor.AI.shortcuts.translate.hindi": "Hindi",
  "editor.AI.shortcuts.translate.russian": "Russian",
  "editor.AI.shortcuts.translate.arabic": "Arabic",
  "editor.AI.shortcuts.style.title": "Change Style",
  "editor.AI.shortcuts.style.business": "Business",
  "editor.AI.shortcuts.style.legal": "Legal",
  "editor.AI.shortcuts.style.journalism": "Journalism",
  "editor.AI.shortcuts.style.medical": "Medical",
  "editor.AI.shortcuts.style.poetic": "Poetic",
  "editor.codeblock.selectLang": "Select Language",
  "editor.codeblock.copy": "Copy Code",
  "editor.codeblock.lineNumbers": "Toggle Line Numbers",
  "editor.codeblock.wordWrap": "Toggle Word Wrap",
  "editor.codeblock.tabSize": "Tab Size"
};
function TF(t) {
  return t = t || /* @__PURE__ */ new Map(), {
    /**
     * A Map of event names to registered handler functions.
     */
    all: t,
    /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on(e, n) {
      const o = t.get(e);
      o ? o.push(n) : t.set(e, [n]);
    },
    /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */
    off(e, n) {
      const o = t.get(e);
      o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : t.set(e, []));
    },
    /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit(e, n) {
      let o = t.get(e);
      o && o.slice().map((r) => {
        r(n);
      }), o = t.get("*"), o && o.slice().map((r) => {
        r(e, n);
      });
    }
  };
}
const es = {
  lang: aS,
  message: {
    zhHans: _F,
    en: AF
  }
};
class OF {
  constructor() {
    fa(this, "emitter");
    this.emitter = TF();
  }
  get lang() {
    return es.lang;
  }
  set lang(e) {
    if (!this.isLangSupported(e)) {
      console.warn(`Can't find the current language "${e}", Using language "${es.lang}" by default`);
      return;
    }
    es.lang = e, this.emitter.emit("lang", e);
  }
  get message() {
    return es.message;
  }
  set message(e) {
    es.message = e;
  }
  loadLangMessage(e) {
    return this.message[e];
  }
  isLangSupported(e) {
    return Object.keys(this.message).includes(e);
  }
  setLang(e) {
    this.lang = e;
  }
  registerWatchLang(e) {
    return this.emitter.on("lang", e), {
      unsubscribe: () => {
        this.emitter.off("lang", e);
      }
    };
  }
  setMessage(e, n) {
    this.message[e] = n;
  }
  buildLocalesHandler(e) {
    e || (e = this.lang);
    const n = this.loadLangMessage(e);
    return function(r) {
      return n[r] || r;
    };
  }
}
const ab = new OF(), Ge = () => {
  const t = R(es.lang), e = L(() => ab.buildLocalesHandler(h(t)));
  return Ve((n) => {
    const o = ab.registerWatchLang((r) => {
      t.value = r;
    });
    n(() => {
      o.unsubscribe();
    });
  }), {
    lang: t,
    t: e
  };
}, MF = hn({
  extensions: []
});
function IF() {
  return {
    state: MF
  };
}
function Gs(t) {
  return Cg() ? (Sg(t), !0) : !1;
}
function RF() {
  const t = /* @__PURE__ */ new Set(), e = (r) => {
    t.delete(r);
  };
  return {
    on: (r) => {
      t.add(r);
      const i = () => e(r);
      return Gs(i), {
        off: i
      };
    },
    off: e,
    trigger: (...r) => Promise.all(Array.from(t).map((i) => i(...r)))
  };
}
function $F(t) {
  let e = !1, n;
  const o = xg(!0);
  return (...r) => (e || (n = o.run(() => t(...r)), e = !0), n);
}
function qs(t) {
  return typeof t == "function" ? t() : h(t);
}
const v1 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const PF = (t) => typeof t < "u", e4 = (t) => t != null, LF = Object.prototype.toString, DF = (t) => LF.call(t) === "[object Object]", Cr = () => {
}, NF = (t, e) => Object.prototype.hasOwnProperty.call(t, e), BF = /* @__PURE__ */ FF();
function FF() {
  var t, e;
  return v1 && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function zF(t, e) {
  function n(...o) {
    return new Promise((r, i) => {
      Promise.resolve(t(() => e.apply(this, o), { fn: e, thisArg: this, args: o })).then(r).catch(i);
    });
  }
  return n;
}
const t4 = (t) => t();
function HF(t = t4) {
  const e = R(!0);
  function n() {
    e.value = !1;
  }
  function o() {
    e.value = !0;
  }
  const r = (...i) => {
    e.value && t(...i);
  };
  return { isActive: Bs(e), pause: n, resume: o, eventFilter: r };
}
function VF(t) {
  return qn();
}
function UF(...t) {
  if (t.length !== 1)
    return W2(...t);
  const e = t[0];
  return typeof e == "function" ? Bs(wg(() => ({ get: e, set: Cr }))) : R(e);
}
function jF(t, e, n = {}) {
  const {
    eventFilter: o = t4,
    ...r
  } = n;
  return le(
    t,
    zF(
      o,
      e
    ),
    r
  );
}
function WF(t, e, n = {}) {
  const {
    eventFilter: o,
    ...r
  } = n, { eventFilter: i, pause: s, resume: a, isActive: l } = HF(o);
  return { stop: jF(
    t,
    e,
    {
      ...r,
      eventFilter: i
    }
  ), pause: s, resume: a, isActive: l };
}
function y1(t, e = !0, n) {
  VF() ? be(t, n) : e ? t() : ze(t);
}
function Ut(t) {
  var e;
  const n = qs(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const Mn = v1 ? window : void 0, KF = v1 ? window.document : void 0;
function zo(...t) {
  let e, n, o, r;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, o, r] = t, e = Mn) : [e, n, o, r] = t, !e)
    return Cr;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const i = [], s = () => {
    i.forEach((u) => u()), i.length = 0;
  }, a = (u, d, f, p) => (u.addEventListener(d, f, p), () => u.removeEventListener(d, f, p)), l = le(
    () => [Ut(e), qs(r)],
    ([u, d]) => {
      if (s(), !u)
        return;
      const f = DF(d) ? { ...d } : d;
      i.push(
        ...n.flatMap((p) => o.map((m) => a(u, p, m, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), s();
  };
  return Gs(c), c;
}
let lb = !1;
function GF(t, e, n = {}) {
  const { window: o = Mn, ignore: r = [], capture: i = !0, detectIframe: s = !1 } = n;
  if (!o)
    return Cr;
  BF && !lb && (lb = !0, Array.from(o.document.body.children).forEach((f) => f.addEventListener("click", Cr)), o.document.documentElement.addEventListener("click", Cr));
  let a = !0;
  const l = (f) => r.some((p) => {
    if (typeof p == "string")
      return Array.from(o.document.querySelectorAll(p)).some((m) => m === f.target || f.composedPath().includes(m));
    {
      const m = Ut(p);
      return m && (f.target === m || f.composedPath().includes(m));
    }
  }), u = [
    zo(o, "click", (f) => {
      const p = Ut(t);
      if (!(!p || p === f.target || f.composedPath().includes(p))) {
        if (f.detail === 0 && (a = !l(f)), !a) {
          a = !0;
          return;
        }
        e(f);
      }
    }, { passive: !0, capture: i }),
    zo(o, "pointerdown", (f) => {
      const p = Ut(t);
      a = !l(f) && !!(p && !f.composedPath().includes(p));
    }, { passive: !0 }),
    s && zo(o, "blur", (f) => {
      setTimeout(() => {
        var p;
        const m = Ut(t);
        ((p = o.document.activeElement) == null ? void 0 : p.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && e(f);
      }, 0);
    })
  ].filter(Boolean);
  return () => u.forEach((f) => f());
}
function qF() {
  const t = R(!1), e = qn();
  return e && be(() => {
    t.value = !0;
  }, e), t;
}
function wf(t) {
  const e = qF();
  return L(() => (e.value, !!t()));
}
function YF(t, e, n = {}) {
  const { window: o = Mn, ...r } = n;
  let i;
  const s = wf(() => o && "MutationObserver" in o), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = L(() => {
    const f = qs(t), p = (Array.isArray(f) ? f : [f]).map(Ut).filter(e4);
    return new Set(p);
  }), c = le(
    () => l.value,
    (f) => {
      a(), s.value && f.size && (i = new MutationObserver(e), f.forEach((p) => i.observe(p, r)));
    },
    { immediate: !0, flush: "post" }
  ), u = () => i == null ? void 0 : i.takeRecords(), d = () => {
    a(), c();
  };
  return Gs(d), {
    isSupported: s,
    stop: d,
    takeRecords: u
  };
}
function JF(t, e = {}) {
  const { window: n = Mn } = e, o = wf(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let r;
  const i = R(!1), s = (c) => {
    i.value = c.matches;
  }, a = () => {
    r && ("removeEventListener" in r ? r.removeEventListener("change", s) : r.removeListener(s));
  }, l = Ve(() => {
    o.value && (a(), r = n.matchMedia(qs(t)), "addEventListener" in r ? r.addEventListener("change", s) : r.addListener(s), i.value = r.matches);
  });
  return Gs(() => {
    l(), a(), r = void 0;
  }), i;
}
function XF(t) {
  return JSON.parse(JSON.stringify(t));
}
const Oc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Mc = "__vueuse_ssr_handlers__", ZF = /* @__PURE__ */ QF();
function QF() {
  return Mc in Oc || (Oc[Mc] = Oc[Mc] || {}), Oc[Mc];
}
function n4(t, e) {
  return ZF[t] || e;
}
function ez(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
const tz = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, cb = "vueuse-storage";
function o4(t, e, n, o = {}) {
  var r;
  const {
    flush: i = "pre",
    deep: s = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: c = !1,
    shallow: u,
    window: d = Mn,
    eventFilter: f,
    onError: p = (M) => {
      console.error(M);
    },
    initOnMounted: m
  } = o, g = (u ? Oi : R)(typeof e == "function" ? e() : e);
  if (!n)
    try {
      n = n4("getDefaultStorage", () => {
        var M;
        return (M = Mn) == null ? void 0 : M.localStorage;
      })();
    } catch (M) {
      p(M);
    }
  if (!n)
    return g;
  const v = qs(e), y = ez(v), w = (r = o.serializer) != null ? r : tz[y], { pause: x, resume: b } = WF(
    g,
    () => k(g.value),
    { flush: i, deep: s, eventFilter: f }
  );
  d && a && y1(() => {
    zo(d, "storage", $), zo(d, cb, O), m && $();
  }), m || $();
  function S(M, P) {
    d && d.dispatchEvent(new CustomEvent(cb, {
      detail: {
        key: t,
        oldValue: M,
        newValue: P,
        storageArea: n
      }
    }));
  }
  function k(M) {
    try {
      const P = n.getItem(t);
      if (M == null)
        S(P, null), n.removeItem(t);
      else {
        const F = w.write(M);
        P !== F && (n.setItem(t, F), S(P, F));
      }
    } catch (P) {
      p(P);
    }
  }
  function A(M) {
    const P = M ? M.newValue : n.getItem(t);
    if (P == null)
      return l && v != null && n.setItem(t, w.write(v)), v;
    if (!M && c) {
      const F = w.read(P);
      return typeof c == "function" ? c(F, v) : y === "object" && !Array.isArray(F) ? { ...v, ...F } : F;
    } else return typeof P != "string" ? P : w.read(P);
  }
  function $(M) {
    if (!(M && M.storageArea !== n)) {
      if (M && M.key == null) {
        g.value = v;
        return;
      }
      if (!(M && M.key !== t)) {
        x();
        try {
          (M == null ? void 0 : M.newValue) !== w.write(g.value) && (g.value = A(M));
        } catch (P) {
          p(P);
        } finally {
          M ? ze(b) : b();
        }
      }
    }
  }
  function O(M) {
    $(M.detail);
  }
  return g;
}
function r4(t) {
  return JF("(prefers-color-scheme: dark)", t);
}
function nz(t = {}) {
  const {
    selector: e = "html",
    attribute: n = "class",
    initialValue: o = "auto",
    window: r = Mn,
    storage: i,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: a = !0,
    storageRef: l,
    emitAuto: c,
    disableTransition: u = !0
  } = t, d = {
    auto: "",
    light: "light",
    dark: "dark",
    ...t.modes || {}
  }, f = r4({ window: r }), p = L(() => f.value ? "dark" : "light"), m = l || (s == null ? UF(o) : o4(s, o, i, { window: r, listenToStorageChanges: a })), g = L(() => m.value === "auto" ? p.value : m.value), v = n4(
    "updateHTMLAttrs",
    (b, S, k) => {
      const A = typeof b == "string" ? r == null ? void 0 : r.document.querySelector(b) : Ut(b);
      if (!A)
        return;
      let $;
      if (u && ($ = r.document.createElement("style"), $.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), r.document.head.appendChild($)), S === "class") {
        const O = k.split(/\s/g);
        Object.values(d).flatMap((M) => (M || "").split(/\s/g)).filter(Boolean).forEach((M) => {
          O.includes(M) ? A.classList.add(M) : A.classList.remove(M);
        });
      } else
        A.setAttribute(S, k);
      u && (r.getComputedStyle($).opacity, document.head.removeChild($));
    }
  );
  function y(b) {
    var S;
    v(e, n, (S = d[b]) != null ? S : b);
  }
  function w(b) {
    t.onChanged ? t.onChanged(b, y) : y(b);
  }
  le(g, w, { flush: "post", immediate: !0 }), y1(() => w(g.value));
  const x = L({
    get() {
      return c ? m.value : g.value;
    },
    set(b) {
      m.value = b;
    }
  });
  try {
    return Object.assign(x, { store: m, system: p, state: g });
  } catch {
    return x;
  }
}
function oz(t = {}) {
  const {
    valueDark: e = "dark",
    valueLight: n = "",
    window: o = Mn
  } = t, r = nz({
    ...t,
    onChanged: (a, l) => {
      var c;
      t.onChanged ? (c = t.onChanged) == null || c.call(t, a === "dark", l, a) : l(a);
    },
    modes: {
      dark: e,
      light: n
    }
  }), i = L(() => r.system ? r.system.value : r4({ window: o }).value ? "dark" : "light");
  return L({
    get() {
      return r.value === "dark";
    },
    set(a) {
      const l = a ? "dark" : "light";
      i.value === l ? r.value = "auto" : r.value = l;
    }
  });
}
function rz(t, e, n = {}) {
  const { window: o = Mn, ...r } = n;
  let i;
  const s = wf(() => o && "ResizeObserver" in o), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = L(() => Array.isArray(t) ? t.map((d) => Ut(d)) : [Ut(t)]), c = le(
    l,
    (d) => {
      if (a(), s.value && o) {
        i = new ResizeObserver(e);
        for (const f of d)
          f && i.observe(f, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    a(), c();
  };
  return Gs(u), {
    isSupported: s,
    stop: u
  };
}
function iz(t, e = {}) {
  const {
    reset: n = !0,
    windowResize: o = !0,
    windowScroll: r = !0,
    immediate: i = !0
  } = e, s = R(0), a = R(0), l = R(0), c = R(0), u = R(0), d = R(0), f = R(0), p = R(0);
  function m() {
    const g = Ut(t);
    if (!g) {
      n && (s.value = 0, a.value = 0, l.value = 0, c.value = 0, u.value = 0, d.value = 0, f.value = 0, p.value = 0);
      return;
    }
    const v = g.getBoundingClientRect();
    s.value = v.height, a.value = v.bottom, l.value = v.left, c.value = v.right, u.value = v.top, d.value = v.width, f.value = v.x, p.value = v.y;
  }
  return rz(t, m), le(() => Ut(t), (g) => !g && m()), YF(t, m, {
    attributeFilter: ["style", "class"]
  }), r && zo("scroll", m, { capture: !0, passive: !0 }), o && zo("resize", m, { passive: !0 }), y1(() => {
    i && m();
  }), {
    height: s,
    bottom: a,
    left: l,
    right: c,
    top: u,
    width: d,
    x: f,
    y: p,
    update: m
  };
}
function sz(t, e, n = {}) {
  const {
    root: o,
    rootMargin: r = "0px",
    threshold: i = 0.1,
    window: s = Mn,
    immediate: a = !0
  } = n, l = wf(() => s && "IntersectionObserver" in s), c = L(() => {
    const m = qs(t);
    return (Array.isArray(m) ? m : [m]).map(Ut).filter(e4);
  });
  let u = Cr;
  const d = R(a), f = l.value ? le(
    () => [c.value, Ut(o), d.value],
    ([m, g]) => {
      if (u(), !d.value || !m.length)
        return;
      const v = new IntersectionObserver(
        e,
        {
          root: Ut(g),
          rootMargin: r,
          threshold: i
        }
      );
      m.forEach((y) => y && v.observe(y)), u = () => {
        v.disconnect(), u = Cr;
      };
    },
    { immediate: a, flush: "post" }
  ) : Cr, p = () => {
    u(), f(), d.value = !1;
  };
  return Gs(p), {
    isSupported: l,
    isActive: d,
    pause() {
      u(), d.value = !1;
    },
    resume() {
      d.value = !0;
    },
    stop: p
  };
}
function az(t, e = {}) {
  const { window: n = Mn, scrollTarget: o, threshold: r = 0 } = e, i = R(!1);
  return sz(
    t,
    (s) => {
      let a = i.value, l = 0;
      for (const c of s)
        c.time >= l && (l = c.time, a = c.isIntersecting);
      i.value = a;
    },
    {
      root: o,
      window: n,
      threshold: r
    }
  ), i;
}
const lz = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function cz(t = {}) {
  const {
    document: e = KF
  } = t, n = R(null), { on: o, trigger: r } = RF();
  let i;
  e && (i = e.createElement("input"), i.type = "file", i.onchange = (l) => {
    const c = l.target;
    n.value = c.files, r(n.value);
  });
  const s = () => {
    n.value = null, i && i.value && (i.value = "", r(null));
  }, a = (l) => {
    if (!i)
      return;
    const c = {
      ...lz,
      ...t,
      ...l
    };
    i.multiple = c.multiple, i.accept = c.accept, i.webkitdirectory = c.directory, NF(c, "capture") && (i.capture = c.capture), c.reset && s(), i.click();
  };
  return {
    files: Bs(n),
    open: a,
    reset: s,
    onChange: o
  };
}
function b1(t, e = {}) {
  const { initialValue: n = !1, focusVisible: o = !1, preventScroll: r = !1 } = e, i = R(!1), s = L(() => Ut(t));
  zo(s, "focus", (l) => {
    var c, u;
    (!o || (u = (c = l.target).matches) != null && u.call(c, ":focus-visible")) && (i.value = !0);
  }), zo(s, "blur", () => i.value = !1);
  const a = L({
    get: () => i.value,
    set(l) {
      var c, u;
      !l && i.value ? (c = s.value) == null || c.blur() : l && !i.value && ((u = s.value) == null || u.focus({ preventScroll: r }));
    }
  });
  return le(
    s,
    () => {
      a.value = n;
    },
    { immediate: !0, flush: "post" }
  ), { focused: a };
}
function uz(t, e, n = {}) {
  const { window: o = Mn } = n;
  return o4(t, e, o == null ? void 0 : o.localStorage, n);
}
function dz(t, e, n, o = {}) {
  var r, i, s;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: c,
    deep: u = !1,
    defaultValue: d,
    shouldEmit: f
  } = o, p = qn(), m = n || (p == null ? void 0 : p.emit) || ((r = p == null ? void 0 : p.$emit) == null ? void 0 : r.bind(p)) || ((s = (i = p == null ? void 0 : p.proxy) == null ? void 0 : i.$emit) == null ? void 0 : s.bind(p == null ? void 0 : p.proxy));
  let g = c;
  g = g || `update:${e.toString()}`;
  const v = (x) => a ? typeof a == "function" ? a(x) : XF(x) : x, y = () => PF(t[e]) ? v(t[e]) : d, w = (x) => {
    f ? f(x) && m(g, x) : m(g, x);
  };
  if (l) {
    const x = y(), b = R(x);
    let S = !1;
    return le(
      () => t[e],
      (k) => {
        S || (S = !0, b.value = v(k), ze(() => S = !1));
      }
    ), le(
      b,
      (k) => {
        !S && (k !== t[e] || u) && w(k);
      },
      { deep: u }
    ), b;
  } else
    return L({
      get() {
        return y();
      },
      set(x) {
        w(x);
      }
    });
}
const vn = $F(() => {
  const { state: t } = IF(), e = hn({
    extensions: t.extensions ?? [],
    defaultLang: aS,
    isFullscreen: !1,
    color: void 0,
    highlight: void 0,
    AIMenu: !1,
    showPreview: !1,
    spellCheck: !1,
    findAndReplace: !1,
    printer: !1
  }), n = L(() => e.isFullscreen);
  function o() {
    e.isFullscreen = !e.isFullscreen;
  }
  function r() {
    e.showPreview = !e.showPreview;
  }
  function i() {
    e.spellCheck = !e.spellCheck;
  }
  function s() {
    e.findAndReplace = !e.findAndReplace;
  }
  function a() {
    e.printer = !e.printer;
  }
  return Ve(() => {
    e.extensions = t.extensions, e.defaultLang = t.defaultLang;
  }), {
    state: e,
    isFullscreen: n,
    toggleFullscreen: o,
    togglePreview: r,
    toggleSpellCheck: i,
    toggleFindAndReplace: s,
    togglePrinter: a
  };
}), Rp = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function $p(t, e, n, o) {
  t.addEventListener ? t.addEventListener(e, n, o) : t.attachEvent && t.attachEvent("on".concat(e), n);
}
function va(t, e, n, o) {
  t.removeEventListener ? t.removeEventListener(e, n, o) : t.detachEvent && t.detachEvent("on".concat(e), n);
}
function i4(t, e) {
  const n = e.slice(0, e.length - 1);
  for (let o = 0; o < n.length; o++) n[o] = t[n[o].toLowerCase()];
  return n;
}
function s4(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  const e = t.split(",");
  let n = e.lastIndexOf("");
  for (; n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
function fz(t, e) {
  const n = t.length >= e.length ? t : e, o = t.length >= e.length ? e : t;
  let r = !0;
  for (let i = 0; i < n.length; i++)
    o.indexOf(n[i]) === -1 && (r = !1);
  return r;
}
const hl = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": Rp ? 173 : 189,
  "=": Rp ? 61 : 187,
  ";": Rp ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, po = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, pu = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, _t = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, at = {};
for (let t = 1; t < 20; t++)
  hl["f".concat(t)] = 111 + t;
let it = [], Va = null, a4 = "all";
const Mo = /* @__PURE__ */ new Map(), ql = (t) => hl[t.toLowerCase()] || po[t.toLowerCase()] || t.toUpperCase().charCodeAt(0), pz = (t) => Object.keys(hl).find((e) => hl[e] === t), hz = (t) => Object.keys(po).find((e) => po[e] === t);
function l4(t) {
  a4 = t || "all";
}
function ml() {
  return a4 || "all";
}
function mz() {
  return it.slice(0);
}
function gz() {
  return it.map((t) => pz(t) || hz(t) || String.fromCharCode(t));
}
function vz() {
  const t = [];
  return Object.keys(at).forEach((e) => {
    at[e].forEach((n) => {
      let {
        key: o,
        scope: r,
        mods: i,
        shortcut: s
      } = n;
      t.push({
        scope: r,
        shortcut: s,
        mods: i,
        keys: o.split("+").map((a) => ql(a))
      });
    });
  }), t;
}
function yz(t) {
  const e = t.target || t.srcElement, {
    tagName: n
  } = e;
  let o = !0;
  const r = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(e.type);
  return (e.isContentEditable || (r || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (o = !1), o;
}
function bz(t) {
  return typeof t == "string" && (t = ql(t)), it.indexOf(t) !== -1;
}
function wz(t, e) {
  let n, o;
  t || (t = ml());
  for (const r in at)
    if (Object.prototype.hasOwnProperty.call(at, r))
      for (n = at[r], o = 0; o < n.length; )
        n[o].scope === t ? n.splice(o, 1).forEach((s) => {
          let {
            element: a
          } = s;
          return w1(a);
        }) : o++;
  ml() === t && l4(e || "all");
}
function xz(t) {
  let e = t.keyCode || t.which || t.charCode;
  const n = it.indexOf(e);
  if (n >= 0 && it.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && it.splice(0, it.length), (e === 93 || e === 224) && (e = 91), e in _t) {
    _t[e] = !1;
    for (const o in po) po[o] === e && (Un[o] = !1);
  }
}
function c4(t) {
  if (typeof t > "u")
    Object.keys(at).forEach((r) => {
      Array.isArray(at[r]) && at[r].forEach((i) => Ic(i)), delete at[r];
    }), w1(null);
  else if (Array.isArray(t))
    t.forEach((r) => {
      r.key && Ic(r);
    });
  else if (typeof t == "object")
    t.key && Ic(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++)
      n[o - 1] = arguments[o];
    let [r, i] = n;
    typeof r == "function" && (i = r, r = ""), Ic({
      key: t,
      scope: r,
      method: i,
      splitKey: "+"
    });
  }
}
const Ic = (t) => {
  let {
    key: e,
    scope: n,
    method: o,
    splitKey: r = "+"
  } = t;
  s4(e).forEach((s) => {
    const a = s.split(r), l = a.length, c = a[l - 1], u = c === "*" ? "*" : ql(c);
    if (!at[u]) return;
    n || (n = ml());
    const d = l > 1 ? i4(po, a) : [], f = [];
    at[u] = at[u].filter((p) => {
      const g = (o ? p.method === o : !0) && p.scope === n && fz(p.mods, d);
      return g && f.push(p.element), !g;
    }), f.forEach((p) => w1(p));
  });
};
function ub(t, e, n, o) {
  if (e.element !== o)
    return;
  let r;
  if (e.scope === n || e.scope === "all") {
    r = e.mods.length > 0;
    for (const i in _t)
      Object.prototype.hasOwnProperty.call(_t, i) && (!_t[i] && e.mods.indexOf(+i) > -1 || _t[i] && e.mods.indexOf(+i) === -1) && (r = !1);
    (e.mods.length === 0 && !_t[16] && !_t[18] && !_t[17] && !_t[91] || r || e.shortcut === "*") && (e.keys = [], e.keys = e.keys.concat(it), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)));
  }
}
function db(t, e) {
  const n = at["*"];
  let o = t.keyCode || t.which || t.charCode;
  if (!Un.filter.call(this, t)) return;
  if ((o === 93 || o === 224) && (o = 91), it.indexOf(o) === -1 && o !== 229 && it.push(o), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((a) => {
    const l = pu[a];
    t[a] && it.indexOf(l) === -1 ? it.push(l) : !t[a] && it.indexOf(l) > -1 ? it.splice(it.indexOf(l), 1) : a === "metaKey" && t[a] && (it = it.filter((c) => c in pu || c === o));
  }), o in _t) {
    _t[o] = !0;
    for (const a in po)
      po[a] === o && (Un[a] = !0);
    if (!n) return;
  }
  for (const a in _t)
    Object.prototype.hasOwnProperty.call(_t, a) && (_t[a] = t[pu[a]]);
  t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (it.indexOf(17) === -1 && it.push(17), it.indexOf(18) === -1 && it.push(18), _t[17] = !0, _t[18] = !0);
  const r = ml();
  if (n)
    for (let a = 0; a < n.length; a++)
      n[a].scope === r && (t.type === "keydown" && n[a].keydown || t.type === "keyup" && n[a].keyup) && ub(t, n[a], r, e);
  if (!(o in at)) return;
  const i = at[o], s = i.length;
  for (let a = 0; a < s; a++)
    if ((t.type === "keydown" && i[a].keydown || t.type === "keyup" && i[a].keyup) && i[a].key) {
      const l = i[a], {
        splitKey: c
      } = l, u = l.key.split(c), d = [];
      for (let f = 0; f < u.length; f++)
        d.push(ql(u[f]));
      d.sort().join("") === it.sort().join("") && ub(t, l, r, e);
    }
}
function Un(t, e, n) {
  it = [];
  const o = s4(t);
  let r = [], i = "all", s = document, a = 0, l = !1, c = !0, u = "+", d = !1, f = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (i = e.scope), e.element && (s = e.element), e.keyup && (l = e.keyup), e.keydown !== void 0 && (c = e.keydown), e.capture !== void 0 && (d = e.capture), typeof e.splitKey == "string" && (u = e.splitKey), e.single === !0 && (f = !0)), typeof e == "string" && (i = e), f && c4(t, i); a < o.length; a++)
    t = o[a].split(u), r = [], t.length > 1 && (r = i4(po, t)), t = t[t.length - 1], t = t === "*" ? "*" : ql(t), t in at || (at[t] = []), at[t].push({
      keyup: l,
      keydown: c,
      scope: i,
      mods: r,
      shortcut: o[a],
      method: n,
      key: o[a],
      splitKey: u,
      element: s
    });
  if (typeof s < "u" && window) {
    if (!Mo.has(s)) {
      const p = function() {
        let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return db(g, s);
      }, m = function() {
        let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        db(g, s), xz(g);
      };
      Mo.set(s, {
        keydownListener: p,
        keyupListenr: m,
        capture: d
      }), $p(s, "keydown", p, d), $p(s, "keyup", m, d);
    }
    if (!Va) {
      const p = () => {
        it = [];
      };
      Va = {
        listener: p,
        capture: d
      }, $p(window, "focus", p, d);
    }
  }
}
function Cz(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(at).forEach((n) => {
    at[n].filter((r) => r.scope === e && r.shortcut === t).forEach((r) => {
      r && r.method && r.method();
    });
  });
}
function w1(t) {
  const e = Object.values(at).flat();
  if (e.findIndex((o) => {
    let {
      element: r
    } = o;
    return r === t;
  }) < 0) {
    const {
      keydownListener: o,
      keyupListenr: r,
      capture: i
    } = Mo.get(t) || {};
    o && r && (va(t, "keyup", r, i), va(t, "keydown", o, i), Mo.delete(t));
  }
  if ((e.length <= 0 || Mo.size <= 0) && (Object.keys(Mo).forEach((r) => {
    const {
      keydownListener: i,
      keyupListenr: s,
      capture: a
    } = Mo.get(r) || {};
    i && s && (va(r, "keyup", s, a), va(r, "keydown", i, a), Mo.delete(r));
  }), Mo.clear(), Object.keys(at).forEach((r) => delete at[r]), Va)) {
    const {
      listener: r,
      capture: i
    } = Va;
    va(window, "focus", r, i), Va = null;
  }
}
const Pp = {
  getPressedKeyString: gz,
  setScope: l4,
  getScope: ml,
  deleteScope: wz,
  getPressedKeyCodes: mz,
  getAllKeyCodes: vz,
  isPressed: bz,
  filter: yz,
  trigger: Cz,
  unbind: c4,
  keyMap: hl,
  modifier: po,
  modifierMap: pu
};
for (const t in Pp)
  Object.prototype.hasOwnProperty.call(Pp, t) && (Un[t] = Pp[t]);
if (typeof window < "u") {
  const t = window.hotkeys;
  Un.noConflict = (e) => (e && window.hotkeys === Un && (window.hotkeys = t), Un), window.hotkeys = Un;
}
const x1 = (t, e) => {
  Un.filter = () => !0;
  const n = () => {
    Un(t, (r) => (r.preventDefault(), e(), !1));
  }, o = () => {
    Un.unbind(t);
  };
  return mo(() => {
    o();
  }), { bind: n, unbind: o };
};
function Sz({ editor: t, wait: e = 250 }) {
  const n = R(!!(t != null && t.isFocused)), o = HS((r) => {
    n.value = r;
  }, e);
  return t && (t.on("focus", () => {
    n.value = !0, o.cancel();
  }), t.on("blur", () => {
    o(!1);
  })), Nt(() => {
    o.cancel();
  }), {
    isFocused: n
  };
}
function u4(t) {
  var e, n, o = "";
  if (typeof t == "string" || typeof t == "number") o += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var r = t.length;
    for (e = 0; e < r; e++) t[e] && (n = u4(t[e])) && (o && (o += " "), o += n);
  } else for (n in t) t[n] && (o && (o += " "), o += n);
  return o;
}
function C1() {
  for (var t, e, n = 0, o = "", r = arguments.length; n < r; n++) (t = arguments[n]) && (e = u4(t)) && (o && (o += " "), o += e);
  return o;
}
const S1 = "-", kz = (t) => {
  const e = _z(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: o
  } = t;
  return {
    getClassGroupId: (s) => {
      const a = s.split(S1);
      return a[0] === "" && a.length !== 1 && a.shift(), d4(a, e) || Ez(s);
    },
    getConflictingClassGroupIds: (s, a) => {
      const l = n[s] || [];
      return a && o[s] ? [...l, ...o[s]] : l;
    }
  };
}, d4 = (t, e) => {
  var s;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], o = e.nextPart.get(n), r = o ? d4(t.slice(1), o) : void 0;
  if (r)
    return r;
  if (e.validators.length === 0)
    return;
  const i = t.join(S1);
  return (s = e.validators.find(({
    validator: a
  }) => a(i))) == null ? void 0 : s.classGroupId;
}, fb = /^\[(.+)\]$/, Ez = (t) => {
  if (fb.test(t)) {
    const e = fb.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, _z = (t) => {
  const {
    theme: e,
    prefix: n
  } = t, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Tz(Object.entries(t.classGroups), n).forEach(([i, s]) => {
    pm(s, o, i, e);
  }), o;
}, pm = (t, e, n, o) => {
  t.forEach((r) => {
    if (typeof r == "string") {
      const i = r === "" ? e : pb(e, r);
      i.classGroupId = n;
      return;
    }
    if (typeof r == "function") {
      if (Az(r)) {
        pm(r(o), e, n, o);
        return;
      }
      e.validators.push({
        validator: r,
        classGroupId: n
      });
      return;
    }
    Object.entries(r).forEach(([i, s]) => {
      pm(s, pb(e, i), n, o);
    });
  });
}, pb = (t, e) => {
  let n = t;
  return e.split(S1).forEach((o) => {
    n.nextPart.has(o) || n.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(o);
  }), n;
}, Az = (t) => t.isThemeGetter, Tz = (t, e) => e ? t.map(([n, o]) => {
  const r = o.map((i) => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([s, a]) => [e + s, a])) : i);
  return [n, r];
}) : t, Oz = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  const r = (i, s) => {
    n.set(i, s), e++, e > t && (e = 0, o = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let s = n.get(i);
      if (s !== void 0)
        return s;
      if ((s = o.get(i)) !== void 0)
        return r(i, s), s;
    },
    set(i, s) {
      n.has(i) ? n.set(i, s) : r(i, s);
    }
  };
}, f4 = "!", Mz = (t) => {
  const {
    separator: e,
    experimentalParseClassName: n
  } = t, o = e.length === 1, r = e[0], i = e.length, s = (a) => {
    const l = [];
    let c = 0, u = 0, d;
    for (let v = 0; v < a.length; v++) {
      let y = a[v];
      if (c === 0) {
        if (y === r && (o || a.slice(v, v + i) === e)) {
          l.push(a.slice(u, v)), u = v + i;
          continue;
        }
        if (y === "/") {
          d = v;
          continue;
        }
      }
      y === "[" ? c++ : y === "]" && c--;
    }
    const f = l.length === 0 ? a : a.substring(u), p = f.startsWith(f4), m = p ? f.substring(1) : f, g = d && d > u ? d - u : void 0;
    return {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: m,
      maybePostfixModifierPosition: g
    };
  };
  return n ? (a) => n({
    className: a,
    parseClassName: s
  }) : s;
}, Iz = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((o) => {
    o[0] === "[" ? (e.push(...n.sort(), o), n = []) : n.push(o);
  }), e.push(...n.sort()), e;
}, Rz = (t) => ({
  cache: Oz(t.cacheSize),
  parseClassName: Mz(t),
  ...kz(t)
}), $z = /\s+/, Pz = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: o,
    getConflictingClassGroupIds: r
  } = e, i = [], s = t.trim().split($z);
  let a = "";
  for (let l = s.length - 1; l >= 0; l -= 1) {
    const c = s[l], {
      modifiers: u,
      hasImportantModifier: d,
      baseClassName: f,
      maybePostfixModifierPosition: p
    } = n(c);
    let m = !!p, g = o(m ? f.substring(0, p) : f);
    if (!g) {
      if (!m) {
        a = c + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (g = o(f), !g) {
        a = c + (a.length > 0 ? " " + a : a);
        continue;
      }
      m = !1;
    }
    const v = Iz(u).join(":"), y = d ? v + f4 : v, w = y + g;
    if (i.includes(w))
      continue;
    i.push(w);
    const x = r(g, m);
    for (let b = 0; b < x.length; ++b) {
      const S = x[b];
      i.push(y + S);
    }
    a = c + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function Lz() {
  let t = 0, e, n, o = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = p4(e)) && (o && (o += " "), o += n);
  return o;
}
const p4 = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let o = 0; o < t.length; o++)
    t[o] && (e = p4(t[o])) && (n && (n += " "), n += e);
  return n;
};
function Dz(t, ...e) {
  let n, o, r, i = s;
  function s(l) {
    const c = e.reduce((u, d) => d(u), t());
    return n = Rz(c), o = n.cache.get, r = n.cache.set, i = a, a(l);
  }
  function a(l) {
    const c = o(l);
    if (c)
      return c;
    const u = Pz(l, n);
    return r(l, u), u;
  }
  return function() {
    return i(Lz.apply(null, arguments));
  };
}
const Qe = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, h4 = /^\[(?:([a-z-]+):)?(.+)\]$/i, Nz = /^\d+\/\d+$/, Bz = /* @__PURE__ */ new Set(["px", "full", "screen"]), Fz = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, zz = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Hz = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Vz = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Uz = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Co = (t) => ps(t) || Bz.has(t) || Nz.test(t), Zo = (t) => Ys(t, "length", Xz), ps = (t) => !!t && !Number.isNaN(Number(t)), Lp = (t) => Ys(t, "number", ps), ya = (t) => !!t && Number.isInteger(Number(t)), jz = (t) => t.endsWith("%") && ps(t.slice(0, -1)), xe = (t) => h4.test(t), Qo = (t) => Fz.test(t), Wz = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Kz = (t) => Ys(t, Wz, m4), Gz = (t) => Ys(t, "position", m4), qz = /* @__PURE__ */ new Set(["image", "url"]), Yz = (t) => Ys(t, qz, Qz), Jz = (t) => Ys(t, "", Zz), ba = () => !0, Ys = (t, e, n) => {
  const o = h4.exec(t);
  return o ? o[1] ? typeof e == "string" ? o[1] === e : e.has(o[1]) : n(o[2]) : !1;
}, Xz = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  zz.test(t) && !Hz.test(t)
), m4 = () => !1, Zz = (t) => Vz.test(t), Qz = (t) => Uz.test(t), eH = () => {
  const t = Qe("colors"), e = Qe("spacing"), n = Qe("blur"), o = Qe("brightness"), r = Qe("borderColor"), i = Qe("borderRadius"), s = Qe("borderSpacing"), a = Qe("borderWidth"), l = Qe("contrast"), c = Qe("grayscale"), u = Qe("hueRotate"), d = Qe("invert"), f = Qe("gap"), p = Qe("gradientColorStops"), m = Qe("gradientColorStopPositions"), g = Qe("inset"), v = Qe("margin"), y = Qe("opacity"), w = Qe("padding"), x = Qe("saturate"), b = Qe("scale"), S = Qe("sepia"), k = Qe("skew"), A = Qe("space"), $ = Qe("translate"), O = () => ["auto", "contain", "none"], M = () => ["auto", "hidden", "clip", "visible", "scroll"], P = () => ["auto", xe, e], F = () => [xe, e], J = () => ["", Co, Zo], Q = () => ["auto", ps, xe], G = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], V = () => ["solid", "dashed", "dotted", "double", "none"], B = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], q = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], z = () => ["", "0", xe], H = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Z = () => [ps, xe];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [ba],
      spacing: [Co, Zo],
      blur: ["none", "", Qo, xe],
      brightness: Z(),
      borderColor: [t],
      borderRadius: ["none", "", "full", Qo, xe],
      borderSpacing: F(),
      borderWidth: J(),
      contrast: Z(),
      grayscale: z(),
      hueRotate: Z(),
      invert: z(),
      gap: F(),
      gradientColorStops: [t],
      gradientColorStopPositions: [jz, Zo],
      inset: P(),
      margin: P(),
      opacity: Z(),
      padding: F(),
      saturate: Z(),
      scale: Z(),
      sepia: z(),
      skew: Z(),
      space: F(),
      translate: F()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", xe]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Qo]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": H()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": H()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...G(), xe]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: M()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": M()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": M()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: O()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": O()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": O()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ya, xe]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: P()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", xe]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: z()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: z()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ya, xe]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [ba]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ya, xe]
        }, xe]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Q()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Q()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [ba]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ya, xe]
        }, xe]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Q()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Q()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", xe]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", xe]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...q()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...q(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...q(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [w]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [w]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [w]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [w]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [w]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [w]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [w]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [w]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [w]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [v]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [v]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [v]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [v]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [v]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [v]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [v]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [v]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [v]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [A]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [A]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", xe, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [xe, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [xe, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [Qo]
        }, Qo]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [xe, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [xe, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [xe, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [xe, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Qo, Zo]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Lp]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [ba]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", xe]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ps, Lp]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Co, xe]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", xe]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", xe]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [y]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [y]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...V(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Co, Zo]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Co, xe]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: F()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", xe]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", xe]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [y]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...G(), Gz]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Kz]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Yz]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [m]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [p]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [y]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...V(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [y]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: V()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [r]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [r]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [r]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [r]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [r]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [r]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [r]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [r]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [r]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [r]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...V()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Co, xe]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Co, Zo]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: J()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [y]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Co, Zo]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Qo, Jz]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [ba]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [y]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...B(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": B()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Qo, xe]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [y]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", xe]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Z()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", xe]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Z()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", xe]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [b]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [b]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [b]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ya, xe]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [$]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [$]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [k]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [k]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", xe]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", xe]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": F()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": F()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": F()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": F()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": F()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": F()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": F()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": F()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": F()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": F()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": F()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": F()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": F()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": F()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": F()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": F()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": F()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": F()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", xe]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Co, Zo, Lp]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, g4 = /* @__PURE__ */ Dz(eH);
function ve(...t) {
  return g4(C1(t));
}
const tH = ["top", "right", "bottom", "left"], _r = Math.min, ln = Math.max, Ju = Math.round, Rc = Math.floor, so = (t) => ({
  x: t,
  y: t
}), nH = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oH = {
  start: "end",
  end: "start"
};
function hm(t, e, n) {
  return ln(t, _r(e, n));
}
function Uo(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function jo(t) {
  return t.split("-")[0];
}
function Js(t) {
  return t.split("-")[1];
}
function k1(t) {
  return t === "x" ? "y" : "x";
}
function E1(t) {
  return t === "y" ? "height" : "width";
}
function Ar(t) {
  return ["top", "bottom"].includes(jo(t)) ? "y" : "x";
}
function _1(t) {
  return k1(Ar(t));
}
function rH(t, e, n) {
  n === void 0 && (n = !1);
  const o = Js(t), r = _1(t), i = E1(r);
  let s = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = Xu(s)), [s, Xu(s)];
}
function iH(t) {
  const e = Xu(t);
  return [mm(t), e, mm(e)];
}
function mm(t) {
  return t.replace(/start|end/g, (e) => oH[e]);
}
function sH(t, e, n) {
  const o = ["left", "right"], r = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? r : o : e ? o : r;
    case "left":
    case "right":
      return e ? i : s;
    default:
      return [];
  }
}
function aH(t, e, n, o) {
  const r = Js(t);
  let i = sH(jo(t), n === "start", o);
  return r && (i = i.map((s) => s + "-" + r), e && (i = i.concat(i.map(mm)))), i;
}
function Xu(t) {
  return t.replace(/left|right|bottom|top/g, (e) => nH[e]);
}
function lH(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function v4(t) {
  return typeof t != "number" ? lH(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Zu(t) {
  const {
    x: e,
    y: n,
    width: o,
    height: r
  } = t;
  return {
    width: o,
    height: r,
    top: n,
    left: e,
    right: e + o,
    bottom: n + r,
    x: e,
    y: n
  };
}
function hb(t, e, n) {
  let {
    reference: o,
    floating: r
  } = t;
  const i = Ar(e), s = _1(e), a = E1(s), l = jo(e), c = i === "y", u = o.x + o.width / 2 - r.width / 2, d = o.y + o.height / 2 - r.height / 2, f = o[a] / 2 - r[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: u,
        y: o.y - r.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: o.y + o.height
      };
      break;
    case "right":
      p = {
        x: o.x + o.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: o.x - r.width,
        y: d
      };
      break;
    default:
      p = {
        x: o.x,
        y: o.y
      };
  }
  switch (Js(e)) {
    case "start":
      p[s] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      p[s] += f * (n && c ? -1 : 1);
      break;
  }
  return p;
}
const cH = async (t, e, n) => {
  const {
    placement: o = "bottom",
    strategy: r = "absolute",
    middleware: i = [],
    platform: s
  } = n, a = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: r
  }), {
    x: u,
    y: d
  } = hb(c, o, l), f = o, p = {}, m = 0;
  for (let g = 0; g < a.length; g++) {
    const {
      name: v,
      fn: y
    } = a[g], {
      x: w,
      y: x,
      data: b,
      reset: S
    } = await y({
      x: u,
      y: d,
      initialPlacement: o,
      placement: f,
      strategy: r,
      middlewareData: p,
      rects: c,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = w ?? u, d = x ?? d, p = {
      ...p,
      [v]: {
        ...p[v],
        ...b
      }
    }, S && m <= 50 && (m++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: r
    }) : S.rects), {
      x: u,
      y: d
    } = hb(c, f, l)), g = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: r,
    middlewareData: p
  };
};
async function gl(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: o,
    y: r,
    platform: i,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: p = 0
  } = Uo(e, t), m = v4(p), v = a[f ? d === "floating" ? "reference" : "floating" : d], y = Zu(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), w = d === "floating" ? {
    x: o,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, x = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), b = await (i.isElement == null ? void 0 : i.isElement(x)) ? await (i.getScale == null ? void 0 : i.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Zu(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: w,
    offsetParent: x,
    strategy: l
  }) : w);
  return {
    top: (y.top - S.top + m.top) / b.y,
    bottom: (S.bottom - y.bottom + m.bottom) / b.y,
    left: (y.left - S.left + m.left) / b.x,
    right: (S.right - y.right + m.right) / b.x
  };
}
const uH = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: o,
      placement: r,
      rects: i,
      platform: s,
      elements: a,
      middlewareData: l
    } = e, {
      element: c,
      padding: u = 0
    } = Uo(t, e) || {};
    if (c == null)
      return {};
    const d = v4(u), f = {
      x: n,
      y: o
    }, p = _1(r), m = E1(p), g = await s.getDimensions(c), v = p === "y", y = v ? "top" : "left", w = v ? "bottom" : "right", x = v ? "clientHeight" : "clientWidth", b = i.reference[m] + i.reference[p] - f[p] - i.floating[m], S = f[p] - i.reference[p], k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let A = k ? k[x] : 0;
    (!A || !await (s.isElement == null ? void 0 : s.isElement(k))) && (A = a.floating[x] || i.floating[m]);
    const $ = b / 2 - S / 2, O = A / 2 - g[m] / 2 - 1, M = _r(d[y], O), P = _r(d[w], O), F = M, J = A - g[m] - P, Q = A / 2 - g[m] / 2 + $, G = hm(F, Q, J), V = !l.arrow && Js(r) != null && Q !== G && i.reference[m] / 2 - (Q < F ? M : P) - g[m] / 2 < 0, B = V ? Q < F ? Q - F : Q - J : 0;
    return {
      [p]: f[p] + B,
      data: {
        [p]: G,
        centerOffset: Q - G - B,
        ...V && {
          alignmentOffset: B
        }
      },
      reset: V
    };
  }
}), dH = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, o;
      const {
        placement: r,
        middlewareData: i,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...v
      } = Uo(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const y = jo(r), w = Ar(a), x = jo(a) === a, b = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), S = f || (x || !g ? [Xu(a)] : iH(a)), k = m !== "none";
      !f && k && S.push(...aH(a, g, m, b));
      const A = [a, ...S], $ = await gl(e, v), O = [];
      let M = ((o = i.flip) == null ? void 0 : o.overflows) || [];
      if (u && O.push($[y]), d) {
        const Q = rH(r, s, b);
        O.push($[Q[0]], $[Q[1]]);
      }
      if (M = [...M, {
        placement: r,
        overflows: O
      }], !O.every((Q) => Q <= 0)) {
        var P, F;
        const Q = (((P = i.flip) == null ? void 0 : P.index) || 0) + 1, G = A[Q];
        if (G)
          return {
            data: {
              index: Q,
              overflows: M
            },
            reset: {
              placement: G
            }
          };
        let V = (F = M.filter((B) => B.overflows[0] <= 0).sort((B, q) => B.overflows[1] - q.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!V)
          switch (p) {
            case "bestFit": {
              var J;
              const B = (J = M.filter((q) => {
                if (k) {
                  const z = Ar(q.placement);
                  return z === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  z === "y";
                }
                return !0;
              }).map((q) => [q.placement, q.overflows.filter((z) => z > 0).reduce((z, H) => z + H, 0)]).sort((q, z) => q[1] - z[1])[0]) == null ? void 0 : J[0];
              B && (V = B);
              break;
            }
            case "initialPlacement":
              V = a;
              break;
          }
        if (r !== V)
          return {
            reset: {
              placement: V
            }
          };
      }
      return {};
    }
  };
};
function mb(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function gb(t) {
  return tH.some((e) => t[e] >= 0);
}
const fH = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: o = "referenceHidden",
        ...r
      } = Uo(t, e);
      switch (o) {
        case "referenceHidden": {
          const i = await gl(e, {
            ...r,
            elementContext: "reference"
          }), s = mb(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: gb(s)
            }
          };
        }
        case "escaped": {
          const i = await gl(e, {
            ...r,
            altBoundary: !0
          }), s = mb(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: gb(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function pH(t, e) {
  const {
    placement: n,
    platform: o,
    elements: r
  } = t, i = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), s = jo(n), a = Js(n), l = Ar(n) === "y", c = ["left", "top"].includes(s) ? -1 : 1, u = i && l ? -1 : 1, d = Uo(e, t);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof m == "number" && (p = a === "end" ? m * -1 : m), l ? {
    x: p * u,
    y: f * c
  } : {
    x: f * c,
    y: p * u
  };
}
const hH = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, o;
      const {
        x: r,
        y: i,
        placement: s,
        middlewareData: a
      } = e, l = await pH(e, t);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (o = a.arrow) != null && o.alignmentOffset ? {} : {
        x: r + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, mH = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: o,
        placement: r
      } = e, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (v) => {
            let {
              x: y,
              y: w
            } = v;
            return {
              x: y,
              y: w
            };
          }
        },
        ...l
      } = Uo(t, e), c = {
        x: n,
        y: o
      }, u = await gl(e, l), d = Ar(jo(r)), f = k1(d);
      let p = c[f], m = c[d];
      if (i) {
        const v = f === "y" ? "top" : "left", y = f === "y" ? "bottom" : "right", w = p + u[v], x = p - u[y];
        p = hm(w, p, x);
      }
      if (s) {
        const v = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", w = m + u[v], x = m - u[y];
        m = hm(w, m, x);
      }
      const g = a.fn({
        ...e,
        [f]: p,
        [d]: m
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - o,
          enabled: {
            [f]: i,
            [d]: s
          }
        }
      };
    }
  };
}, gH = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: o,
        placement: r,
        rects: i,
        middlewareData: s
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = Uo(t, e), u = {
        x: n,
        y: o
      }, d = Ar(r), f = k1(d);
      let p = u[f], m = u[d];
      const g = Uo(a, e), v = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (l) {
        const x = f === "y" ? "height" : "width", b = i.reference[f] - i.floating[x] + v.mainAxis, S = i.reference[f] + i.reference[x] - v.mainAxis;
        p < b ? p = b : p > S && (p = S);
      }
      if (c) {
        var y, w;
        const x = f === "y" ? "width" : "height", b = ["top", "left"].includes(jo(r)), S = i.reference[d] - i.floating[x] + (b && ((y = s.offset) == null ? void 0 : y[d]) || 0) + (b ? 0 : v.crossAxis), k = i.reference[d] + i.reference[x] + (b ? 0 : ((w = s.offset) == null ? void 0 : w[d]) || 0) - (b ? v.crossAxis : 0);
        m < S ? m = S : m > k && (m = k);
      }
      return {
        [f]: p,
        [d]: m
      };
    }
  };
}, vH = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, o;
      const {
        placement: r,
        rects: i,
        platform: s,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...c
      } = Uo(t, e), u = await gl(e, c), d = jo(r), f = Js(r), p = Ar(r) === "y", {
        width: m,
        height: g
      } = i.floating;
      let v, y;
      d === "top" || d === "bottom" ? (v = d, y = f === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (y = d, v = f === "end" ? "top" : "bottom");
      const w = g - u.top - u.bottom, x = m - u.left - u.right, b = _r(g - u[v], w), S = _r(m - u[y], x), k = !e.middlewareData.shift;
      let A = b, $ = S;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && ($ = x), (o = e.middlewareData.shift) != null && o.enabled.y && (A = w), k && !f) {
        const M = ln(u.left, 0), P = ln(u.right, 0), F = ln(u.top, 0), J = ln(u.bottom, 0);
        p ? $ = m - 2 * (M !== 0 || P !== 0 ? M + P : ln(u.left, u.right)) : A = g - 2 * (F !== 0 || J !== 0 ? F + J : ln(u.top, u.bottom));
      }
      await l({
        ...e,
        availableWidth: $,
        availableHeight: A
      });
      const O = await s.getDimensions(a.floating);
      return m !== O.width || g !== O.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function xf() {
  return typeof window < "u";
}
function $i(t) {
  return A1(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function pn(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function vo(t) {
  var e;
  return (e = (A1(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function A1(t) {
  return xf() ? t instanceof Node || t instanceof pn(t).Node : !1;
}
function Kn(t) {
  return xf() ? t instanceof Element || t instanceof pn(t).Element : !1;
}
function ho(t) {
  return xf() ? t instanceof HTMLElement || t instanceof pn(t).HTMLElement : !1;
}
function vb(t) {
  return !xf() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof pn(t).ShadowRoot;
}
function Yl(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: o,
    display: r
  } = Gn(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + o + n) && !["inline", "contents"].includes(r);
}
function yH(t) {
  return ["table", "td", "th"].includes($i(t));
}
function Cf(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function T1(t) {
  const e = O1(), n = Kn(t) ? Gn(t) : t;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function bH(t) {
  let e = Tr(t);
  for (; ho(e) && !As(e); ) {
    if (T1(e))
      return e;
    if (Cf(e))
      return null;
    e = Tr(e);
  }
  return null;
}
function O1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function As(t) {
  return ["html", "body", "#document"].includes($i(t));
}
function Gn(t) {
  return pn(t).getComputedStyle(t);
}
function Sf(t) {
  return Kn(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Tr(t) {
  if ($i(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    vb(t) && t.host || // Fallback.
    vo(t)
  );
  return vb(e) ? e.host : e;
}
function y4(t) {
  const e = Tr(t);
  return As(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ho(e) && Yl(e) ? e : y4(e);
}
function vl(t, e, n) {
  var o;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const r = y4(t), i = r === ((o = t.ownerDocument) == null ? void 0 : o.body), s = pn(r);
  if (i) {
    const a = gm(s);
    return e.concat(s, s.visualViewport || [], Yl(r) ? r : [], a && n ? vl(a) : []);
  }
  return e.concat(r, vl(r, [], n));
}
function gm(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function b4(t) {
  const e = Gn(t);
  let n = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const r = ho(t), i = r ? t.offsetWidth : n, s = r ? t.offsetHeight : o, a = Ju(n) !== i || Ju(o) !== s;
  return a && (n = i, o = s), {
    width: n,
    height: o,
    $: a
  };
}
function M1(t) {
  return Kn(t) ? t : t.contextElement;
}
function hs(t) {
  const e = M1(t);
  if (!ho(e))
    return so(1);
  const n = e.getBoundingClientRect(), {
    width: o,
    height: r,
    $: i
  } = b4(e);
  let s = (i ? Ju(n.width) : n.width) / o, a = (i ? Ju(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const wH = /* @__PURE__ */ so(0);
function w4(t) {
  const e = pn(t);
  return !O1() || !e.visualViewport ? wH : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function xH(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== pn(t) ? !1 : e;
}
function ki(t, e, n, o) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), i = M1(t);
  let s = so(1);
  e && (o ? Kn(o) && (s = hs(o)) : s = hs(t));
  const a = xH(i, n, o) ? w4(i) : so(0);
  let l = (r.left + a.x) / s.x, c = (r.top + a.y) / s.y, u = r.width / s.x, d = r.height / s.y;
  if (i) {
    const f = pn(i), p = o && Kn(o) ? pn(o) : o;
    let m = f, g = gm(m);
    for (; g && o && p !== m; ) {
      const v = hs(g), y = g.getBoundingClientRect(), w = Gn(g), x = y.left + (g.clientLeft + parseFloat(w.paddingLeft)) * v.x, b = y.top + (g.clientTop + parseFloat(w.paddingTop)) * v.y;
      l *= v.x, c *= v.y, u *= v.x, d *= v.y, l += x, c += b, m = pn(g), g = gm(m);
    }
  }
  return Zu({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function I1(t, e) {
  const n = Sf(t).scrollLeft;
  return e ? e.left + n : ki(vo(t)).left + n;
}
function x4(t, e, n) {
  n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), r = o.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    I1(t, o)
  )), i = o.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function CH(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: o,
    strategy: r
  } = t;
  const i = r === "fixed", s = vo(o), a = e ? Cf(e.floating) : !1;
  if (o === s || a && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = so(1);
  const u = so(0), d = ho(o);
  if ((d || !d && !i) && (($i(o) !== "body" || Yl(s)) && (l = Sf(o)), ho(o))) {
    const p = ki(o);
    c = hs(o), u.x = p.x + o.clientLeft, u.y = p.y + o.clientTop;
  }
  const f = s && !d && !i ? x4(s, l, !0) : so(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function SH(t) {
  return Array.from(t.getClientRects());
}
function kH(t) {
  const e = vo(t), n = Sf(t), o = t.ownerDocument.body, r = ln(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), i = ln(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let s = -n.scrollLeft + I1(t);
  const a = -n.scrollTop;
  return Gn(o).direction === "rtl" && (s += ln(e.clientWidth, o.clientWidth) - r), {
    width: r,
    height: i,
    x: s,
    y: a
  };
}
function EH(t, e) {
  const n = pn(t), o = vo(t), r = n.visualViewport;
  let i = o.clientWidth, s = o.clientHeight, a = 0, l = 0;
  if (r) {
    i = r.width, s = r.height;
    const c = O1();
    (!c || c && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: a,
    y: l
  };
}
function _H(t, e) {
  const n = ki(t, !0, e === "fixed"), o = n.top + t.clientTop, r = n.left + t.clientLeft, i = ho(t) ? hs(t) : so(1), s = t.clientWidth * i.x, a = t.clientHeight * i.y, l = r * i.x, c = o * i.y;
  return {
    width: s,
    height: a,
    x: l,
    y: c
  };
}
function yb(t, e, n) {
  let o;
  if (e === "viewport")
    o = EH(t, n);
  else if (e === "document")
    o = kH(vo(t));
  else if (Kn(e))
    o = _H(e, n);
  else {
    const r = w4(t);
    o = {
      x: e.x - r.x,
      y: e.y - r.y,
      width: e.width,
      height: e.height
    };
  }
  return Zu(o);
}
function C4(t, e) {
  const n = Tr(t);
  return n === e || !Kn(n) || As(n) ? !1 : Gn(n).position === "fixed" || C4(n, e);
}
function AH(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let o = vl(t, [], !1).filter((a) => Kn(a) && $i(a) !== "body"), r = null;
  const i = Gn(t).position === "fixed";
  let s = i ? Tr(t) : t;
  for (; Kn(s) && !As(s); ) {
    const a = Gn(s), l = T1(s);
    !l && a.position === "fixed" && (r = null), (i ? !l && !r : !l && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || Yl(s) && !l && C4(t, s)) ? o = o.filter((u) => u !== s) : r = a, s = Tr(s);
  }
  return e.set(t, o), o;
}
function TH(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: r
  } = t;
  const s = [...n === "clippingAncestors" ? Cf(e) ? [] : AH(e, this._c) : [].concat(n), o], a = s[0], l = s.reduce((c, u) => {
    const d = yb(e, u, r);
    return c.top = ln(d.top, c.top), c.right = _r(d.right, c.right), c.bottom = _r(d.bottom, c.bottom), c.left = ln(d.left, c.left), c;
  }, yb(e, a, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function OH(t) {
  const {
    width: e,
    height: n
  } = b4(t);
  return {
    width: e,
    height: n
  };
}
function MH(t, e, n) {
  const o = ho(e), r = vo(e), i = n === "fixed", s = ki(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = so(0);
  if (o || !o && !i)
    if (($i(e) !== "body" || Yl(r)) && (a = Sf(e)), o) {
      const f = ki(e, !0, i, e);
      l.x = f.x + e.clientLeft, l.y = f.y + e.clientTop;
    } else r && (l.x = I1(r));
  const c = r && !o && !i ? x4(r, a) : so(0), u = s.left + a.scrollLeft - l.x - c.x, d = s.top + a.scrollTop - l.y - c.y;
  return {
    x: u,
    y: d,
    width: s.width,
    height: s.height
  };
}
function Dp(t) {
  return Gn(t).position === "static";
}
function bb(t, e) {
  if (!ho(t) || Gn(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return vo(t) === n && (n = n.ownerDocument.body), n;
}
function S4(t, e) {
  const n = pn(t);
  if (Cf(t))
    return n;
  if (!ho(t)) {
    let r = Tr(t);
    for (; r && !As(r); ) {
      if (Kn(r) && !Dp(r))
        return r;
      r = Tr(r);
    }
    return n;
  }
  let o = bb(t, e);
  for (; o && yH(o) && Dp(o); )
    o = bb(o, e);
  return o && As(o) && Dp(o) && !T1(o) ? n : o || bH(t) || n;
}
const IH = async function(t) {
  const e = this.getOffsetParent || S4, n = this.getDimensions, o = await n(t.floating);
  return {
    reference: MH(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function RH(t) {
  return Gn(t).direction === "rtl";
}
const $H = {
  convertOffsetParentRelativeRectToViewportRelativeRect: CH,
  getDocumentElement: vo,
  getClippingRect: TH,
  getOffsetParent: S4,
  getElementRects: IH,
  getClientRects: SH,
  getDimensions: OH,
  getScale: hs,
  isElement: Kn,
  isRTL: RH
};
function k4(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function PH(t, e) {
  let n = null, o;
  const r = vo(t);
  function i() {
    var a;
    clearTimeout(o), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i();
    const c = t.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: p
    } = c;
    if (a || e(), !f || !p)
      return;
    const m = Rc(d), g = Rc(r.clientWidth - (u + f)), v = Rc(r.clientHeight - (d + p)), y = Rc(u), x = {
      rootMargin: -m + "px " + -g + "px " + -v + "px " + -y + "px",
      threshold: ln(0, _r(1, l)) || 1
    };
    let b = !0;
    function S(k) {
      const A = k[0].intersectionRatio;
      if (A !== l) {
        if (!b)
          return s();
        A ? s(!1, A) : o = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      A === 1 && !k4(c, t.getBoundingClientRect()) && s(), b = !1;
    }
    try {
      n = new IntersectionObserver(S, {
        ...x,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, x);
    }
    n.observe(t);
  }
  return s(!0), i;
}
function LH(t, e, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = o, c = M1(t), u = r || i ? [...c ? vl(c) : [], ...vl(e)] : [];
  u.forEach((y) => {
    r && y.addEventListener("scroll", n, {
      passive: !0
    }), i && y.addEventListener("resize", n);
  });
  const d = c && a ? PH(c, n) : null;
  let f = -1, p = null;
  s && (p = new ResizeObserver((y) => {
    let [w] = y;
    w && w.target === c && p && (p.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var x;
      (x = p) == null || x.observe(e);
    })), n();
  }), c && !l && p.observe(c), p.observe(e));
  let m, g = l ? ki(t) : null;
  l && v();
  function v() {
    const y = ki(t);
    g && !k4(g, y) && n(), g = y, m = requestAnimationFrame(v);
  }
  return n(), () => {
    var y;
    u.forEach((w) => {
      r && w.removeEventListener("scroll", n), i && w.removeEventListener("resize", n);
    }), d == null || d(), (y = p) == null || y.disconnect(), p = null, l && cancelAnimationFrame(m);
  };
}
const DH = hH, NH = mH, wb = dH, BH = vH, FH = fH, zH = uH, HH = gH, VH = (t, e, n) => {
  const o = /* @__PURE__ */ new Map(), r = {
    platform: $H,
    ...n
  }, i = {
    ...r.platform,
    _c: o
  };
  return cH(t, e, {
    ...r,
    platform: i
  });
};
function UH(t) {
  return t != null && typeof t == "object" && "$el" in t;
}
function vm(t) {
  if (UH(t)) {
    const e = t.$el;
    return A1(e) && $i(e) === "#comment" ? null : e;
  }
  return t;
}
function ts(t) {
  return typeof t == "function" ? t() : h(t);
}
function jH(t) {
  return {
    name: "arrow",
    options: t,
    fn(e) {
      const n = vm(ts(t.element));
      return n == null ? {} : zH({
        element: n,
        padding: t.padding
      }).fn(e);
    }
  };
}
function E4(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function xb(t, e) {
  const n = E4(t);
  return Math.round(e * n) / n;
}
function WH(t, e, n) {
  n === void 0 && (n = {});
  const o = n.whileElementsMounted, r = L(() => {
    var A;
    return (A = ts(n.open)) != null ? A : !0;
  }), i = L(() => ts(n.middleware)), s = L(() => {
    var A;
    return (A = ts(n.placement)) != null ? A : "bottom";
  }), a = L(() => {
    var A;
    return (A = ts(n.strategy)) != null ? A : "absolute";
  }), l = L(() => {
    var A;
    return (A = ts(n.transform)) != null ? A : !0;
  }), c = L(() => vm(t.value)), u = L(() => vm(e.value)), d = R(0), f = R(0), p = R(a.value), m = R(s.value), g = Oi({}), v = R(!1), y = L(() => {
    const A = {
      position: p.value,
      left: "0",
      top: "0"
    };
    if (!u.value)
      return A;
    const $ = xb(u.value, d.value), O = xb(u.value, f.value);
    return l.value ? {
      ...A,
      transform: "translate(" + $ + "px, " + O + "px)",
      ...E4(u.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: p.value,
      left: $ + "px",
      top: O + "px"
    };
  });
  let w;
  function x() {
    if (c.value == null || u.value == null)
      return;
    const A = r.value;
    VH(c.value, u.value, {
      middleware: i.value,
      placement: s.value,
      strategy: a.value
    }).then(($) => {
      d.value = $.x, f.value = $.y, p.value = $.strategy, m.value = $.placement, g.value = $.middlewareData, v.value = A !== !1;
    });
  }
  function b() {
    typeof w == "function" && (w(), w = void 0);
  }
  function S() {
    if (b(), o === void 0) {
      x();
      return;
    }
    if (c.value != null && u.value != null) {
      w = o(c.value, u.value, x);
      return;
    }
  }
  function k() {
    r.value || (v.value = !1);
  }
  return le([i, s, a, r], x, {
    flush: "sync"
  }), le([c, u], S, {
    flush: "sync"
  }), le(r, k, {
    flush: "sync"
  }), Cg() && Sg(b), {
    x: Vi(d),
    y: Vi(f),
    strategy: Vi(p),
    placement: Vi(m),
    middlewareData: Vi(g),
    isPositioned: Vi(v),
    floatingStyles: y,
    update: x
  };
}
function R1(t) {
  return t ? t.flatMap((e) => e.type === me ? R1(e.children) : [e]) : [];
}
const ym = I({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(t, { attrs: e, slots: n }) {
    return () => {
      var l, c;
      if (!n.default)
        return null;
      const o = R1(n.default()), r = o.findIndex((u) => u.type !== K2);
      if (r === -1)
        return o;
      const i = o[r];
      (l = i.props) == null || delete l.ref;
      const s = i.props ? j(e, i.props) : e;
      e.class && ((c = i.props) != null && c.class) && delete i.props.class;
      const a = t_(i, s);
      for (const u in s)
        u.startsWith("on") && (a.props || (a.props = {}), a.props[u] = s[u]);
      return o.length === 1 ? a : (o[r] = a, o);
    };
  }
}), KH = ["area", "img", "input"], ae = I({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(t, { attrs: e, slots: n }) {
    const o = t.asChild ? "template" : t.as;
    return typeof o == "string" && KH.includes(o) ? () => Ot(o, e) : o !== "template" ? () => Ot(t.as, e, { default: n.default }) : () => Ot(ym, e, { default: n.default });
  }
}), Jl = /* @__PURE__ */ I({
  __name: "VisuallyHidden",
  props: {
    feature: { default: "focusable" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    return (e, n) => (E(), T(h(ae), {
      as: e.as,
      "as-child": e.asChild,
      "aria-hidden": e.feature === "focusable" ? "true" : void 0,
      "data-hidden": e.feature === "fully-hidden" ? "" : void 0,
      tabindex: e.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    }, {
      default: C(() => [
        D(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"]));
  }
});
function GH(t, e) {
  var n;
  const o = Oi();
  return Ve(() => {
    o.value = t();
  }, {
    ...e,
    flush: (n = void 0) != null ? n : "sync"
  }), Bs(o);
}
function Pi(t) {
  return Cg() ? (Sg(t), !0) : !1;
}
function qH() {
  const t = /* @__PURE__ */ new Set(), e = (i) => {
    t.delete(i);
  };
  return {
    on: (i) => {
      t.add(i);
      const s = () => e(i);
      return Pi(s), {
        off: s
      };
    },
    off: e,
    trigger: (...i) => Promise.all(Array.from(t).map((s) => s(...i))),
    clear: () => {
      t.clear();
    }
  };
}
function YH(t) {
  let e = !1, n;
  const o = xg(!0);
  return (...r) => (e || (n = o.run(() => t(...r)), e = !0), n);
}
function _4(t) {
  let e = 0, n, o;
  const r = () => {
    e -= 1, o && e <= 0 && (o.stop(), n = void 0, o = void 0);
  };
  return (...i) => (e += 1, o || (o = xg(!0), n = o.run(() => t(...i))), Pi(r), n);
}
function JH(t) {
  if (!No(t))
    return hn(t);
  const e = new Proxy({}, {
    get(n, o, r) {
      return h(Reflect.get(t.value, o, r));
    },
    set(n, o, r) {
      return No(t.value[o]) && !No(r) ? t.value[o].value = r : t.value[o] = r, !0;
    },
    deleteProperty(n, o) {
      return Reflect.deleteProperty(t.value, o);
    },
    has(n, o) {
      return Reflect.has(t.value, o);
    },
    ownKeys() {
      return Object.keys(t.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return hn(e);
}
function XH(t) {
  return JH(L(t));
}
function ZH(t, ...e) {
  const n = e.flat(), o = n[0];
  return XH(() => Object.fromEntries(typeof o == "function" ? Object.entries(st(t)).filter(([r, i]) => !o(jt(i), r)) : Object.entries(st(t)).filter((r) => !n.includes(r[0]))));
}
const yo = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const QH = (t) => typeof t < "u", eV = Object.prototype.toString, tV = (t) => eV.call(t) === "[object Object]", bm = () => {
}, Cb = /* @__PURE__ */ nV();
function nV() {
  var t, e;
  return yo && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function oV(t, e) {
  function n(...o) {
    return new Promise((r, i) => {
      Promise.resolve(t(() => e.apply(this, o), { fn: e, thisArg: this, args: o })).then(r).catch(i);
    });
  }
  return n;
}
function rV(t, e = {}) {
  let n, o, r = bm;
  const i = (l) => {
    clearTimeout(l), r(), r = bm;
  };
  let s;
  return (l) => {
    const c = jt(t), u = jt(e.maxWait);
    return n && i(n), c <= 0 || u !== void 0 && u <= 0 ? (o && (i(o), o = null), Promise.resolve(l())) : new Promise((d, f) => {
      r = e.rejectOnCancel ? f : d, s = l, u && !o && (o = setTimeout(() => {
        n && i(n), o = null, d(s());
      }, u)), n = setTimeout(() => {
        o && i(o), o = null, d(l());
      }, c);
    });
  };
}
function iV(t) {
  return qn();
}
function Np(t) {
  return Array.isArray(t) ? t : [t];
}
function A4(t, e = 1e4) {
  return wg((n, o) => {
    let r = jt(t), i;
    const s = () => setTimeout(() => {
      r = jt(t), o();
    }, jt(e));
    return Pi(() => {
      clearTimeout(i);
    }), {
      get() {
        return n(), r;
      },
      set(a) {
        r = a, o(), clearTimeout(i), i = s();
      }
    };
  });
}
function T4(t, e = 200, n = {}) {
  return oV(
    rV(e, n),
    t
  );
}
const sV = jt;
function aV(t, e) {
  iV() && mo(t, e);
}
function $1(t, e, n = {}) {
  const {
    immediate: o = !0,
    immediateCallback: r = !1
  } = n, i = Oi(!1);
  let s = null;
  function a() {
    s && (clearTimeout(s), s = null);
  }
  function l() {
    i.value = !1, a();
  }
  function c(...u) {
    r && t(), a(), i.value = !0, s = setTimeout(() => {
      i.value = !1, s = null, t(...u);
    }, jt(e));
  }
  return o && (i.value = !0, yo && c()), Pi(l), {
    isPending: Bs(i),
    start: c,
    stop: l
  };
}
function lV(t = 1e3, e = {}) {
  const {
    controls: n = !1,
    callback: o
  } = e, r = $1(
    o ?? bm,
    t,
    e
  ), i = L(() => !r.isPending.value);
  return n ? {
    ready: i,
    ...r
  } : i;
}
function cV(t, e, n) {
  return le(
    t,
    e,
    {
      ...n,
      immediate: !0
    }
  );
}
function uV(t, e, n) {
  const o = le(t, (...r) => (ze(() => o()), e(...r)), n);
  return o;
}
const Xl = yo ? window : void 0;
function In(t) {
  var e;
  const n = jt(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
function Ts(...t) {
  const e = [], n = () => {
    e.forEach((a) => a()), e.length = 0;
  }, o = (a, l, c, u) => (a.addEventListener(l, c, u), () => a.removeEventListener(l, c, u)), r = L(() => {
    const a = Np(jt(t[0])).filter((l) => l != null);
    return a.every((l) => typeof l != "string") ? a : void 0;
  }), i = cV(
    () => {
      var a, l;
      return [
        (l = (a = r.value) == null ? void 0 : a.map((c) => In(c))) != null ? l : [Xl].filter((c) => c != null),
        Np(jt(r.value ? t[1] : t[0])),
        Np(h(r.value ? t[2] : t[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        jt(r.value ? t[3] : t[2])
      ];
    },
    ([a, l, c, u]) => {
      if (n(), !(a != null && a.length) || !(l != null && l.length) || !(c != null && c.length))
        return;
      const d = tV(u) ? { ...u } : u;
      e.push(
        ...a.flatMap(
          (f) => l.flatMap(
            (p) => c.map((m) => o(f, p, m, d))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    i(), n();
  };
  return Pi(n), s;
}
function O4() {
  const t = Oi(!1), e = qn();
  return e && be(() => {
    t.value = !0;
  }, e), t;
}
function dV(t) {
  const e = O4();
  return L(() => (e.value, !!t()));
}
function fV(t) {
  return typeof t == "function" ? t : typeof t == "string" ? (e) => e.key === t : Array.isArray(t) ? (e) => t.includes(e.key) : () => !0;
}
function P1(...t) {
  let e, n, o = {};
  t.length === 3 ? (e = t[0], n = t[1], o = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = !0, n = t[0], o = t[1]) : (e = t[0], n = t[1]) : (e = !0, n = t[0]);
  const {
    target: r = Xl,
    eventName: i = "keydown",
    passive: s = !1,
    dedupe: a = !1
  } = o, l = fV(e);
  return Ts(r, i, (u) => {
    u.repeat && jt(a) || l(u) && n(u);
  }, s);
}
function M4(t, e = {}) {
  const {
    immediate: n = !0,
    fpsLimit: o = void 0,
    window: r = Xl,
    once: i = !1
  } = e, s = Oi(!1), a = L(() => o ? 1e3 / jt(o) : null);
  let l = 0, c = null;
  function u(p) {
    if (!s.value || !r)
      return;
    l || (l = p);
    const m = p - l;
    if (a.value && m < a.value) {
      c = r.requestAnimationFrame(u);
      return;
    }
    if (l = p, t({ delta: m, timestamp: p }), i) {
      s.value = !1, c = null;
      return;
    }
    c = r.requestAnimationFrame(u);
  }
  function d() {
    !s.value && r && (s.value = !0, l = 0, c = r.requestAnimationFrame(u));
  }
  function f() {
    s.value = !1, c != null && r && (r.cancelAnimationFrame(c), c = null);
  }
  return n && d(), Pi(f), {
    isActive: Bs(s),
    pause: f,
    resume: d
  };
}
function pV(t) {
  return JSON.parse(JSON.stringify(t));
}
function Ei(t, e, n = {}) {
  const { window: o = Xl, ...r } = n;
  let i;
  const s = dV(() => o && "ResizeObserver" in o), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = L(() => {
    const d = jt(t);
    return Array.isArray(d) ? d.map((f) => In(f)) : [In(d)];
  }), c = le(
    l,
    (d) => {
      if (a(), s.value && o) {
        i = new ResizeObserver(e);
        for (const f of d)
          f && i.observe(f, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    a(), c();
  };
  return Pi(u), {
    isSupported: s,
    stop: u
  };
}
function It(t, e, n, o = {}) {
  var r, i, s;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: c,
    deep: u = !1,
    defaultValue: d,
    shouldEmit: f
  } = o, p = qn(), m = n || (p == null ? void 0 : p.emit) || ((r = p == null ? void 0 : p.$emit) == null ? void 0 : r.bind(p)) || ((s = (i = p == null ? void 0 : p.proxy) == null ? void 0 : i.$emit) == null ? void 0 : s.bind(p == null ? void 0 : p.proxy));
  let g = c;
  e || (e = "modelValue"), g = g || `update:${e.toString()}`;
  const v = (x) => a ? typeof a == "function" ? a(x) : pV(x) : x, y = () => QH(t[e]) ? v(t[e]) : d, w = (x) => {
    f ? f(x) && m(g, x) : m(g, x);
  };
  if (l) {
    const x = y(), b = R(x);
    let S = !1;
    return le(
      () => t[e],
      (k) => {
        S || (S = !0, b.value = v(k), ze(() => S = !1));
      }
    ), le(
      b,
      (k) => {
        !S && (k !== t[e] || u) && w(k);
      },
      { deep: u }
    ), b;
  } else
    return L({
      get() {
        return y();
      },
      set(x) {
        w(x);
      }
    });
}
function je(t, e) {
  const n = typeof t == "string" && !e ? `${t}Context` : e, o = Symbol(n);
  return [(s) => {
    const a = kg(o, s);
    if (a || a === null)
      return a;
    throw new Error(
      `Injection \`${o.toString()}\` not found. Component must be used within ${Array.isArray(t) ? `one of the following components: ${t.join(
        ", "
      )}` : `\`${t}\``}`
    );
  }, (s) => (el(o, s), s)];
}
function Sb(t) {
  return typeof t == "string" ? `'${t}'` : new hV().serialize(t);
}
const hV = /* @__PURE__ */ function() {
  var e;
  class t {
    constructor() {
      Hv(this, e, /* @__PURE__ */ new Map());
    }
    compare(o, r) {
      const i = typeof o, s = typeof r;
      return i === "string" && s === "string" ? o.localeCompare(r) : i === "number" && s === "number" ? o - r : String.prototype.localeCompare.call(this.serialize(o, !0), this.serialize(r, !0));
    }
    serialize(o, r) {
      if (o === null) return "null";
      switch (typeof o) {
        case "string":
          return r ? o : `'${o}'`;
        case "bigint":
          return `${o}n`;
        case "object":
          return this.$object(o);
        case "function":
          return this.$function(o);
      }
      return String(o);
    }
    serializeObject(o) {
      const r = Object.prototype.toString.call(o);
      if (r !== "[object Object]") return this.serializeBuiltInType(r.length < 10 ? `unknown:${r}` : r.slice(8, -1), o);
      const i = o.constructor, s = i === Object || i === void 0 ? "" : i.name;
      if (s !== "" && globalThis[s] === i) return this.serializeBuiltInType(s, o);
      if (typeof o.toJSON == "function") {
        const a = o.toJSON();
        return s + (a !== null && typeof a == "object" ? this.$object(a) : `(${this.serialize(a)})`);
      }
      return this.serializeObjectEntries(s, Object.entries(o));
    }
    serializeBuiltInType(o, r) {
      const i = this["$" + o];
      if (i) return i.call(this, r);
      if (typeof (r == null ? void 0 : r.entries) == "function") return this.serializeObjectEntries(o, r.entries());
      throw new Error(`Cannot serialize ${o}`);
    }
    serializeObjectEntries(o, r) {
      const i = Array.from(r).sort((a, l) => this.compare(a[0], l[0]));
      let s = `${o}{`;
      for (let a = 0; a < i.length; a++) {
        const [l, c] = i[a];
        s += `${this.serialize(l, !0)}:${this.serialize(c)}`, a < i.length - 1 && (s += ",");
      }
      return s + "}";
    }
    $object(o) {
      let r = pa(this, e).get(o);
      return r === void 0 && (pa(this, e).set(o, `#${pa(this, e).size}`), r = this.serializeObject(o), pa(this, e).set(o, r)), r;
    }
    $function(o) {
      const r = Function.prototype.toString.call(o);
      return r.slice(-15) === "[native code] }" ? `${o.name || ""}()[native]` : `${o.name}(${o.length})${r.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(o) {
      let r = "[";
      for (let i = 0; i < o.length; i++) r += this.serialize(o[i]), i < o.length - 1 && (r += ",");
      return r + "]";
    }
    $Date(o) {
      try {
        return `Date(${o.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(o) {
      return `ArrayBuffer[${new Uint8Array(o).join(",")}]`;
    }
    $Set(o) {
      return `Set${this.$Array(Array.from(o).sort((r, i) => this.compare(r, i)))}`;
    }
    $Map(o) {
      return this.serializeObjectEntries("Map", o.entries());
    }
  }
  e = new WeakMap();
  for (const n of ["Error", "RegExp", "URL"]) t.prototype["$" + n] = function(o) {
    return `${n}(${o})`;
  };
  for (const n of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) t.prototype["$" + n] = function(o) {
    return `${n}[${o.join(",")}]`;
  };
  for (const n of ["BigInt64Array", "BigUint64Array"]) t.prototype["$" + n] = function(o) {
    return `${n}[${o.join("n,")}${o.length > 0 ? "n" : ""}]`;
  };
  return t;
}();
function Os(t, e) {
  return t === e || Sb(t) === Sb(e);
}
function yl(t) {
  return t == null;
}
function Qu(t, e) {
  return yl(t) ? !1 : Array.isArray(t) ? t.some((n) => Os(n, e)) : Os(t, e);
}
function mV({ type: t, defaultValue: e, modelValue: n }) {
  const o = n || e;
  return n !== void 0 || e !== void 0 ? Array.isArray(o) ? "multiple" : "single" : t ?? "single";
}
function gV({ type: t, defaultValue: e, modelValue: n }) {
  return t || mV({ type: t, defaultValue: e, modelValue: n });
}
function vV({ type: t, defaultValue: e }) {
  return e !== void 0 ? e : t === "single" ? void 0 : [];
}
function yV(t, e) {
  const n = L(() => gV(t)), o = It(t, "modelValue", e, {
    defaultValue: vV(t),
    passive: t.modelValue === void 0,
    deep: !0
  });
  function r(s) {
    if (n.value === "single")
      o.value = Os(s, o.value) ? void 0 : s;
    else {
      const a = Array.isArray(o.value) ? [...o.value || []] : [o.value].filter(Boolean);
      if (Qu(a, s)) {
        const l = a.findIndex((c) => Os(c, s));
        a.splice(l, 1);
      } else
        a.push(s);
      o.value = a;
    }
  }
  const i = L(() => n.value === "single");
  return {
    modelValue: o,
    changeModelValue: r,
    isSingle: i
  };
}
const [kf, sre] = je("ConfigProvider");
function qo(t) {
  const e = kf({
    dir: R("ltr")
  });
  return L(() => {
    var n;
    return (t == null ? void 0 : t.value) || ((n = e.dir) == null ? void 0 : n.value) || "ltr";
  });
}
function ee() {
  const t = qn(), e = R(), n = L(() => {
    var s, a;
    return ["#text", "#comment"].includes((s = e.value) == null ? void 0 : s.$el.nodeName) ? (a = e.value) == null ? void 0 : a.$el.nextElementSibling : In(e);
  }), o = Object.assign({}, t.exposed), r = {};
  for (const s in t.props)
    Object.defineProperty(r, s, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[s]
    });
  if (Object.keys(o).length > 0)
    for (const s in o)
      Object.defineProperty(r, s, {
        enumerable: !0,
        configurable: !0,
        get: () => o[s]
      });
  Object.defineProperty(r, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => t.vnode.el
  }), t.exposed = r;
  function i(s) {
    e.value = s, s && (Object.defineProperty(r, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), t.exposed = r);
  }
  return { forwardRef: i, currentRef: e, currentElement: n };
}
const bV = ["INPUT", "TEXTAREA"];
function wV(t, e, n, o = {}) {
  if (!e || o.enableIgnoredElement && bV.includes(e.nodeName))
    return null;
  const {
    arrowKeyOptions: r = "both",
    attributeName: i = "[data-reka-collection-item]",
    itemsArray: s = [],
    loop: a = !0,
    dir: l = "ltr",
    preventScroll: c = !0,
    focus: u = !1
  } = o, [d, f, p, m, g, v] = [
    t.key === "ArrowRight",
    t.key === "ArrowLeft",
    t.key === "ArrowUp",
    t.key === "ArrowDown",
    t.key === "Home",
    t.key === "End"
  ], y = p || m, w = d || f;
  if (!g && !v && (!y && !w || r === "vertical" && w || r === "horizontal" && y))
    return null;
  const x = n ? Array.from(n.querySelectorAll(i)) : s;
  if (!x.length)
    return null;
  c && t.preventDefault();
  let b = null;
  return w || y ? b = I4(x, e, {
    goForward: y ? m : l === "ltr" ? d : f,
    loop: a
  }) : g ? b = x.at(0) || null : v && (b = x.at(-1) || null), u && (b == null || b.focus()), b;
}
function I4(t, e, n, o = t.length) {
  if (--o === 0)
    return null;
  const r = t.indexOf(e), i = n.goForward ? r + 1 : r - 1;
  if (!n.loop && (i < 0 || i >= t.length))
    return null;
  const s = (i + t.length) % t.length, a = t[s];
  return a ? a.hasAttribute("disabled") && a.getAttribute("disabled") !== "false" ? I4(
    t,
    a,
    n,
    o
  ) : a : null;
}
let xV = 0;
function St(t, e = "reka") {
  if (t)
    return t;
  const n = kf({ useId: void 0 });
  return Vv.useId ? `${e}-${Vv.useId()}` : n.useId ? `${e}-${n.useId()}` : `${e}-${++xV}`;
}
function R4(t, e) {
  const n = R(t);
  function o(i) {
    return e[n.value][i] ?? n.value;
  }
  return {
    state: n,
    dispatch: (i) => {
      n.value = o(i);
    }
  };
}
function CV(t, e) {
  var v;
  const n = R({}), o = R("none"), r = R(t), i = t.value ? "mounted" : "unmounted";
  let s;
  const a = ((v = e.value) == null ? void 0 : v.ownerDocument.defaultView) ?? Xl, { state: l, dispatch: c } = R4(i, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  }), u = (y) => {
    var w;
    if (yo) {
      const x = new CustomEvent(y, { bubbles: !1, cancelable: !1 });
      (w = e.value) == null || w.dispatchEvent(x);
    }
  };
  le(
    t,
    async (y, w) => {
      var b;
      const x = w !== y;
      if (await ze(), x) {
        const S = o.value, k = $c(e.value);
        y ? (c("MOUNT"), u("enter"), k === "none" && u("after-enter")) : k === "none" || k === "undefined" || ((b = n.value) == null ? void 0 : b.display) === "none" ? (c("UNMOUNT"), u("leave"), u("after-leave")) : w && S !== k ? (c("ANIMATION_OUT"), u("leave")) : (c("UNMOUNT"), u("after-leave"));
      }
    },
    { immediate: !0 }
  );
  const d = (y) => {
    const w = $c(e.value), x = w.includes(
      y.animationName
    ), b = l.value === "mounted" ? "enter" : "leave";
    if (y.target === e.value && x && (u(`after-${b}`), c("ANIMATION_END"), !r.value)) {
      const S = e.value.style.animationFillMode;
      e.value.style.animationFillMode = "forwards", s = a == null ? void 0 : a.setTimeout(() => {
        var k;
        ((k = e.value) == null ? void 0 : k.style.animationFillMode) === "forwards" && (e.value.style.animationFillMode = S);
      });
    }
    y.target === e.value && w === "none" && c("ANIMATION_END");
  }, f = (y) => {
    y.target === e.value && (o.value = $c(e.value));
  }, p = le(
    e,
    (y, w) => {
      y ? (n.value = getComputedStyle(y), y.addEventListener("animationstart", f), y.addEventListener("animationcancel", d), y.addEventListener("animationend", d)) : (c("ANIMATION_END"), s !== void 0 && (a == null || a.clearTimeout(s)), w == null || w.removeEventListener("animationstart", f), w == null || w.removeEventListener("animationcancel", d), w == null || w.removeEventListener("animationend", d));
    },
    { immediate: !0 }
  ), m = le(l, () => {
    const y = $c(e.value);
    o.value = l.value === "mounted" ? y : "none";
  });
  return Nt(() => {
    p(), m();
  }), {
    isPresent: L(
      () => ["mounted", "unmountSuspended"].includes(l.value)
    )
  };
}
function $c(t) {
  return t && getComputedStyle(t).animationName || "none";
}
const rn = I({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(t, { slots: e, expose: n }) {
    var c;
    const { present: o, forceMount: r } = st(t), i = R(), { isPresent: s } = CV(o, i);
    n({ present: s });
    let a = e.default({ present: s.value });
    a = R1(a || []);
    const l = qn();
    if (a && (a == null ? void 0 : a.length) > 1) {
      const u = (c = l == null ? void 0 : l.parent) != null && c.type.name ? `<${l.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${u}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((d) => `  - ${d}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => r.value || o.value || s.value ? Ot(e.default({ present: s.value })[0], {
      ref: (u) => {
        const d = In(u);
        return typeof (d == null ? void 0 : d.hasAttribute) > "u" || (d != null && d.hasAttribute("data-reka-popper-content-wrapper") ? i.value = d.firstElementChild : i.value = d), d;
      }
    }) : null;
  }
});
function zr(t) {
  const e = qn(), n = e == null ? void 0 : e.type.emits, o = {};
  return n != null && n.length || console.warn(
    `No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`
  ), n == null || n.forEach((r) => {
    o[n_(G2(r))] = (...i) => t(r, ...i);
  }), o;
}
function vt(t) {
  const e = qn(), n = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((r, i) => {
    const s = (e == null ? void 0 : e.type.props[i]).default;
    return s !== void 0 && (r[i] = s), r;
  }, {}), o = W2(t);
  return L(() => {
    const r = {}, i = (e == null ? void 0 : e.vnode.props) ?? {};
    return Object.keys(i).forEach((s) => {
      r[G2(s)] = i[s];
    }), Object.keys({ ...n, ...r }).reduce((s, a) => (o.value[a] !== void 0 && (s[a] = o.value[a]), s), {});
  });
}
function Ie(t, e) {
  const n = vt(t), o = e ? zr(e) : {};
  return L(() => ({
    ...n.value,
    ...o
  }));
}
const [Hr, SV] = je("DialogRoot"), kV = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, r = It(n, "open", e, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = R(), s = R(), { modal: a } = st(n);
    return SV({
      open: r,
      modal: a,
      openModal: () => {
        r.value = !0;
      },
      onOpenChange: (l) => {
        r.value = l;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: i,
      contentElement: s
    }), (l, c) => D(l.$slots, "default", { open: h(r) });
  }
}), Zl = /* @__PURE__ */ I({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = O4();
    return (n, o) => h(e) || n.forceMount ? (E(), T(qd, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [
      D(n.$slots, "default")
    ], 8, ["to", "disabled", "defer"])) : oe("", !0);
  }
});
function L1(t, e, n) {
  const o = n.originalEvent.target, r = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && o.addEventListener(t, e, { once: !0 }), o.dispatchEvent(r);
}
const EV = "dismissableLayer.pointerDownOutside", _V = "dismissableLayer.focusOutside";
function $4(t, e) {
  const n = e.closest(
    "[data-dismissable-layer]"
  ), o = t.dataset.dismissableLayer === "" ? t : t.querySelector(
    "[data-dismissable-layer]"
  ), r = Array.from(
    t.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(n && o === n || r.indexOf(o) < r.indexOf(n));
}
function AV(t, e) {
  var i;
  const n = ((i = e == null ? void 0 : e.value) == null ? void 0 : i.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = R(!1), r = R(() => {
  });
  return Ve((s) => {
    if (!yo)
      return;
    const a = async (c) => {
      const u = c.target;
      if (e != null && e.value) {
        if ($4(e.value, u)) {
          o.value = !1;
          return;
        }
        if (c.target && !o.value) {
          let d = function() {
            L1(
              EV,
              t,
              f
            );
          };
          const f = { originalEvent: c };
          c.pointerType === "touch" ? (n.removeEventListener("click", r.value), r.value = d, n.addEventListener("click", r.value, {
            once: !0
          })) : d();
        } else
          n.removeEventListener("click", r.value);
        o.value = !1;
      }
    }, l = window.setTimeout(() => {
      n.addEventListener("pointerdown", a);
    }, 0);
    s(() => {
      window.clearTimeout(l), n.removeEventListener("pointerdown", a), n.removeEventListener("click", r.value);
    });
  }), {
    onPointerDownCapture: () => o.value = !0
  };
}
function TV(t, e) {
  var r;
  const n = ((r = e == null ? void 0 : e.value) == null ? void 0 : r.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = R(!1);
  return Ve((i) => {
    if (!yo)
      return;
    const s = async (a) => {
      e != null && e.value && (await ze(), await ze(), !(!e.value || $4(e.value, a.target)) && a.target && !o.value && L1(
        _V,
        t,
        { originalEvent: a }
      ));
    };
    n.addEventListener("focusin", s), i(() => n.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => o.value = !0,
    onBlurCapture: () => o.value = !1
  };
}
const Pn = hn({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Ql = /* @__PURE__ */ I({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = ee(), s = L(
      () => {
        var m;
        return ((m = i.value) == null ? void 0 : m.ownerDocument) ?? globalThis.document;
      }
    ), a = L(() => Pn.layersRoot), l = L(() => i.value ? Array.from(a.value).indexOf(i.value) : -1), c = L(() => Pn.layersWithOutsidePointerEventsDisabled.size > 0), u = L(() => {
      const m = Array.from(a.value), [g] = [...Pn.layersWithOutsidePointerEventsDisabled].slice(-1), v = m.indexOf(g);
      return l.value >= v;
    }), d = AV(async (m) => {
      const g = [...Pn.branches].some(
        (v) => v == null ? void 0 : v.contains(m.target)
      );
      !u.value || g || (o("pointerDownOutside", m), o("interactOutside", m), await ze(), m.defaultPrevented || o("dismiss"));
    }, i), f = TV((m) => {
      [...Pn.branches].some(
        (v) => v == null ? void 0 : v.contains(m.target)
      ) || (o("focusOutside", m), o("interactOutside", m), m.defaultPrevented || o("dismiss"));
    }, i);
    P1("Escape", (m) => {
      l.value === a.value.size - 1 && (o("escapeKeyDown", m), m.defaultPrevented || o("dismiss"));
    });
    let p;
    return Ve((m) => {
      i.value && (n.disableOutsidePointerEvents && (Pn.layersWithOutsidePointerEventsDisabled.size === 0 && (p = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), Pn.layersWithOutsidePointerEventsDisabled.add(i.value)), a.value.add(i.value), m(() => {
        n.disableOutsidePointerEvents && Pn.layersWithOutsidePointerEventsDisabled.size === 1 && (s.value.body.style.pointerEvents = p);
      }));
    }), Ve((m) => {
      m(() => {
        i.value && (a.value.delete(i.value), Pn.layersWithOutsidePointerEventsDisabled.delete(i.value));
      });
    }), (m, g) => (E(), T(h(ae), {
      ref: h(r),
      "as-child": m.asChild,
      as: m.as,
      "data-dismissable-layer": "",
      style: pt({
        pointerEvents: c.value ? u.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: h(f).onFocusCapture,
      onBlurCapture: h(f).onBlurCapture,
      onPointerdownCapture: h(d).onPointerDownCapture
    }, {
      default: C(() => [
        D(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
});
function gt() {
  let t = document.activeElement;
  if (t == null)
    return null;
  for (; t != null && t.shadowRoot != null && t.shadowRoot.activeElement != null; )
    t = t.shadowRoot.activeElement;
  return t;
}
const OV = "menu.itemSelect", wm = ["Enter", " "], MV = ["ArrowDown", "PageUp", "Home"], P4 = ["ArrowUp", "PageDown", "End"], IV = [...MV, ...P4], RV = {
  ltr: [...wm, "ArrowRight"],
  rtl: [...wm, "ArrowLeft"]
}, $V = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function D1(t) {
  return t ? "open" : "closed";
}
function ed(t) {
  return t === "indeterminate";
}
function L4(t) {
  return ed(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function xm(t) {
  const e = gt();
  for (const n of t)
    if (n === e || (n.focus(), gt() !== e))
      return;
}
function PV(t, e) {
  const { x: n, y: o } = t;
  let r = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const a = e[i].x, l = e[i].y, c = e[s].x, u = e[s].y;
    l > o != u > o && n < (c - a) * (o - l) / (u - l) + a && (r = !r);
  }
  return r;
}
function LV(t, e) {
  if (!e)
    return !1;
  const n = { x: t.clientX, y: t.clientY };
  return PV(n, e);
}
function bl(t) {
  return t.pointerType === "mouse";
}
const DV = "DialogTitle", NV = "DialogContent";
function BV({
  titleName: t = DV,
  contentName: e = NV,
  componentLink: n = "dialog.html#title",
  titleId: o,
  descriptionId: r,
  contentElement: i
}) {
  const s = `Warning: \`${e}\` requires a \`${t}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${n}`, a = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${e}.`;
  be(() => {
    var u;
    document.getElementById(o) || console.warn(s);
    const c = (u = i.value) == null ? void 0 : u.getAttribute("aria-describedby");
    r && c && (document.getElementById(r) || console.warn(a));
  });
}
const Bp = "focusScope.autoFocusOnMount", Fp = "focusScope.autoFocusOnUnmount", kb = { bubbles: !1, cancelable: !0 };
function hu(t, { select: e = !1 } = {}) {
  const n = gt();
  for (const o of t)
    if (ir(o, { select: e }), gt() !== n)
      return !0;
}
function FV(t) {
  const e = N1(t), n = Eb(e, t), o = Eb(e.reverse(), t);
  return [n, o];
}
function N1(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const r = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || r ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function Eb(t, e) {
  for (const n of t)
    if (!zV(n, { upTo: e }))
      return n;
}
function zV(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e !== void 0 && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function HV(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function ir(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = gt();
    t.focus({ preventScroll: !0 }), t !== n && HV(t) && e && t.select();
  }
}
const VV = YH(() => R([]));
function UV() {
  const t = VV();
  return {
    add(e) {
      const n = t.value[0];
      e !== n && (n == null || n.pause()), t.value = _b(t.value, e), t.value.unshift(e);
    },
    remove(e) {
      var n;
      t.value = _b(t.value, e), (n = t.value[0]) == null || n.resume();
    }
  };
}
function _b(t, e) {
  const n = [...t], o = n.indexOf(e);
  return o !== -1 && n.splice(o, 1), n;
}
function jV(t) {
  return t.filter((e) => e.tagName !== "A");
}
const Ef = /* @__PURE__ */ I({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, { currentRef: r, currentElement: i } = ee(), s = R(null), a = UV(), l = hn({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Ve((u) => {
      if (!yo)
        return;
      const d = i.value;
      if (!n.trapped)
        return;
      function f(v) {
        if (l.paused || !d)
          return;
        const y = v.target;
        d.contains(y) ? s.value = y : ir(s.value, { select: !0 });
      }
      function p(v) {
        if (l.paused || !d)
          return;
        const y = v.relatedTarget;
        y !== null && (d.contains(y) || ir(s.value, { select: !0 }));
      }
      function m(v) {
        d.contains(s.value) || ir(d);
      }
      document.addEventListener("focusin", f), document.addEventListener("focusout", p);
      const g = new MutationObserver(m);
      d && g.observe(d, { childList: !0, subtree: !0 }), u(() => {
        document.removeEventListener("focusin", f), document.removeEventListener("focusout", p), g.disconnect();
      });
    }), Ve(async (u) => {
      const d = i.value;
      if (await ze(), !d)
        return;
      a.add(l);
      const f = gt();
      if (!d.contains(f)) {
        const m = new CustomEvent(Bp, kb);
        d.addEventListener(Bp, (g) => o("mountAutoFocus", g)), d.dispatchEvent(m), m.defaultPrevented || (hu(jV(N1(d)), {
          select: !0
        }), gt() === f && ir(d));
      }
      u(() => {
        d.removeEventListener(Bp, (v) => o("mountAutoFocus", v));
        const m = new CustomEvent(Fp, kb), g = (v) => {
          o("unmountAutoFocus", v);
        };
        d.addEventListener(Fp, g), d.dispatchEvent(m), setTimeout(() => {
          m.defaultPrevented || ir(f ?? document.body, { select: !0 }), d.removeEventListener(Fp, g), a.remove(l);
        }, 0);
      });
    });
    function c(u) {
      if (!n.loop && !n.trapped || l.paused)
        return;
      const d = u.key === "Tab" && !u.altKey && !u.ctrlKey && !u.metaKey, f = gt();
      if (d && f) {
        const p = u.currentTarget, [m, g] = FV(p);
        m && g ? !u.shiftKey && f === g ? (u.preventDefault(), n.loop && ir(m, { select: !0 })) : u.shiftKey && f === m && (u.preventDefault(), n.loop && ir(g, { select: !0 })) : f === p && u.preventDefault();
      }
    }
    return (u, d) => (E(), T(h(ae), {
      ref_key: "currentRef",
      ref: r,
      tabindex: "-1",
      "as-child": u.asChild,
      as: u.as,
      onKeydown: c
    }, {
      default: C(() => [
        D(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), D4 = /* @__PURE__ */ I({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hr(), { forwardRef: i, currentElement: s } = ee();
    return r.titleId || (r.titleId = St(void 0, "reka-dialog-title")), r.descriptionId || (r.descriptionId = St(void 0, "reka-dialog-description")), be(() => {
      r.contentElement = s, gt() !== document.body && (r.triggerElement.value = gt());
    }), process.env.NODE_ENV !== "production" && BV({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: r.titleId,
      descriptionId: r.descriptionId,
      contentElement: s
    }), (a, l) => (E(), T(h(Ef), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (c) => o("openAutoFocus", c)),
      onUnmountAutoFocus: l[6] || (l[6] = (c) => o("closeAutoFocus", c))
    }, {
      default: C(() => [
        _(h(Ql), j({
          id: h(r).contentId,
          ref: h(i),
          as: a.as,
          "as-child": a.asChild,
          "disable-outside-pointer-events": a.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": h(r).descriptionId,
          "aria-labelledby": h(r).titleId,
          "data-state": h(D1)(h(r).open.value)
        }, a.$attrs, {
          onDismiss: l[0] || (l[0] = (c) => h(r).onOpenChange(!1)),
          onEscapeKeyDown: l[1] || (l[1] = (c) => o("escapeKeyDown", c)),
          onFocusOutside: l[2] || (l[2] = (c) => o("focusOutside", c)),
          onInteractOutside: l[3] || (l[3] = (c) => o("interactOutside", c)),
          onPointerDownOutside: l[4] || (l[4] = (c) => o("pointerDownOutside", c))
        }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
});
var WV = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Gi = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap(), Lc = {}, zp = 0, N4 = function(t) {
  return t && (t.host || N4(t.parentNode));
}, KV = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var o = N4(n);
    return o && t.contains(o) ? o : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, GV = function(t, e, n, o) {
  var r = KV(e, Array.isArray(t) ? t : [t]);
  Lc[n] || (Lc[n] = /* @__PURE__ */ new WeakMap());
  var i = Lc[n], s = [], a = /* @__PURE__ */ new Set(), l = new Set(r), c = function(d) {
    !d || a.has(d) || (a.add(d), c(d.parentNode));
  };
  r.forEach(c);
  var u = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (a.has(f))
        u(f);
      else
        try {
          var p = f.getAttribute(o), m = p !== null && p !== "false", g = (Gi.get(f) || 0) + 1, v = (i.get(f) || 0) + 1;
          Gi.set(f, g), i.set(f, v), s.push(f), g === 1 && m && Pc.set(f, !0), v === 1 && f.setAttribute(n, "true"), m || f.setAttribute(o, "true");
        } catch (y) {
          console.error("aria-hidden: cannot operate on ", f, y);
        }
    });
  };
  return u(e), a.clear(), zp++, function() {
    s.forEach(function(d) {
      var f = Gi.get(d) - 1, p = i.get(d) - 1;
      Gi.set(d, f), i.set(d, p), f || (Pc.has(d) || d.removeAttribute(o), Pc.delete(d)), p || d.removeAttribute(n);
    }), zp--, zp || (Gi = /* @__PURE__ */ new WeakMap(), Gi = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap(), Lc = {});
  };
}, qV = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var o = Array.from(Array.isArray(t) ? t : [t]), r = WV(t);
  return r ? (o.push.apply(o, Array.from(r.querySelectorAll("[aria-live]"))), GV(o, r, n, "aria-hidden")) : function() {
    return null;
  };
};
function _f(t) {
  let e;
  le(() => In(t), (n) => {
    n ? e = qV(n) : e && e();
  }), Nt(() => {
    e && e();
  });
}
const YV = /* @__PURE__ */ I({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hr(), i = zr(o), { forwardRef: s, currentElement: a } = ee();
    return _f(a), (l, c) => (E(), T(D4, j({ ...n, ...h(i) }, {
      ref: h(s),
      "trap-focus": h(r).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: c[0] || (c[0] = (u) => {
        var d;
        u.defaultPrevented || (u.preventDefault(), (d = h(r).triggerElement.value) == null || d.focus());
      }),
      onPointerDownOutside: c[1] || (c[1] = (u) => {
        const d = u.detail.originalEvent, f = d.button === 0 && d.ctrlKey === !0;
        (d.button === 2 || f) && u.preventDefault();
      }),
      onFocusOutside: c[2] || (c[2] = (u) => {
        u.preventDefault();
      })
    }), {
      default: C(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), JV = /* @__PURE__ */ I({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, r = zr(e);
    ee();
    const i = Hr(), s = R(!1), a = R(!1);
    return (l, c) => (E(), T(D4, j({ ...n, ...h(r) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: c[0] || (c[0] = (u) => {
        var d;
        u.defaultPrevented || (s.value || (d = h(i).triggerElement.value) == null || d.focus(), u.preventDefault()), s.value = !1, a.value = !1;
      }),
      onInteractOutside: c[1] || (c[1] = (u) => {
        var p;
        u.defaultPrevented || (s.value = !0, u.detail.originalEvent.type === "pointerdown" && (a.value = !0));
        const d = u.target;
        ((p = h(i).triggerElement.value) == null ? void 0 : p.contains(d)) && u.preventDefault(), u.detail.originalEvent.type === "focusin" && a.value && u.preventDefault();
      })
    }), {
      default: C(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), XV = /* @__PURE__ */ I({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hr(), i = zr(o), { forwardRef: s } = ee();
    return (a, l) => (E(), T(h(rn), {
      present: a.forceMount || h(r).open.value
    }, {
      default: C(() => [
        h(r).modal.value ? (E(), T(YV, j({
          key: 0,
          ref: h(s)
        }, { ...n, ...h(i), ...a.$attrs }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)) : (E(), T(JV, j({
          key: 1,
          ref: h(s)
        }, { ...n, ...h(i), ...a.$attrs }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
function Hp(t) {
  if (t === null || typeof t != "object")
    return !1;
  const e = Object.getPrototypeOf(t);
  return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in t ? !1 : Symbol.toStringTag in t ? Object.prototype.toString.call(t) === "[object Module]" : !0;
}
function Cm(t, e, n = ".", o) {
  if (!Hp(e))
    return Cm(t, {}, n, o);
  const r = Object.assign({}, e);
  for (const i in t) {
    if (i === "__proto__" || i === "constructor")
      continue;
    const s = t[i];
    s != null && (o && o(r, i, s, n) || (Array.isArray(s) && Array.isArray(r[i]) ? r[i] = [...s, ...r[i]] : Hp(s) && Hp(r[i]) ? r[i] = Cm(
      s,
      r[i],
      (n ? `${n}.` : "") + i.toString(),
      o
    ) : r[i] = s));
  }
  return r;
}
function ZV(t) {
  return (...e) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    e.reduce((n, o) => Cm(n, o, "", t), {})
  );
}
const QV = ZV(), eU = _4(() => {
  const t = R(/* @__PURE__ */ new Map()), e = R(), n = L(() => {
    for (const s of t.value.values())
      if (s)
        return !0;
    return !1;
  }), o = kf({
    scrollBody: R(!0)
  });
  let r = null;
  const i = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = e.value ?? "", Cb && (r == null || r()), e.value = void 0;
  };
  return le(n, (s, a) => {
    var d;
    if (!yo)
      return;
    if (!s) {
      a && i();
      return;
    }
    e.value === void 0 && (e.value = document.body.style.overflow);
    const l = window.innerWidth - document.documentElement.clientWidth, c = { padding: l, margin: 0 }, u = (d = o.scrollBody) != null && d.value ? typeof o.scrollBody.value == "object" ? QV({
      padding: o.scrollBody.value.padding === !0 ? l : o.scrollBody.value.padding,
      margin: o.scrollBody.value.margin === !0 ? l : o.scrollBody.value.margin
    }, c) : c : { padding: 0, margin: 0 };
    l > 0 && (document.body.style.paddingRight = typeof u.padding == "number" ? `${u.padding}px` : String(u.padding), document.body.style.marginRight = typeof u.margin == "number" ? `${u.margin}px` : String(u.margin), document.body.style.setProperty("--scrollbar-width", `${l}px`), document.body.style.overflow = "hidden"), Cb && (r = Ts(
      document,
      "touchmove",
      (f) => tU(f),
      { passive: !1 }
    )), ze(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, { immediate: !0, flush: "sync" }), t;
});
function Af(t) {
  const e = Math.random().toString(36).substring(2, 7), n = eU();
  n.value.set(e, t ?? !1);
  const o = L({
    get: () => n.value.get(e) ?? !1,
    set: (r) => n.value.set(e, r)
  });
  return aV(() => {
    n.value.delete(e);
  }), o;
}
function B4(t) {
  const e = window.getComputedStyle(t);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight)
    return !0;
  {
    const n = t.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : B4(n);
  }
}
function tU(t) {
  const e = t || window.event, n = e.target;
  return n instanceof Element && B4(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.cancelable && e.preventDefault(), !1);
}
const nU = /* @__PURE__ */ I({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Hr();
    return Af(!0), ee(), (n, o) => (E(), T(h(ae), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": h(e).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
}), oU = /* @__PURE__ */ I({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Hr(), { forwardRef: n } = ee();
    return (o, r) => {
      var i;
      return (i = h(e)) != null && i.modal.value ? (E(), T(h(rn), {
        key: 0,
        present: o.forceMount || h(e).open.value
      }, {
        default: C(() => [
          _(nU, j(o.$attrs, {
            ref: h(n),
            as: o.as,
            "as-child": o.asChild
          }), {
            default: C(() => [
              D(o.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : oe("", !0);
    };
  }
}), rU = /* @__PURE__ */ I({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t;
    ee();
    const n = Hr();
    return (o, r) => (E(), T(h(ae), j(e, {
      type: o.as === "button" ? "button" : void 0,
      onClick: r[0] || (r[0] = (i) => h(n).onOpenChange(!1))
    }), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), iU = /* @__PURE__ */ I({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(t) {
    const e = t, n = Hr();
    return ee(), (o, r) => (E(), T(h(ae), j(e, {
      id: h(n).titleId
    }), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
});
function Sm() {
  const t = R(), e = L(() => {
    var n, o;
    return ["#text", "#comment"].includes((n = t.value) == null ? void 0 : n.$el.nodeName) ? (o = t.value) == null ? void 0 : o.$el.nextElementSibling : In(t);
  });
  return {
    primitiveElement: t,
    currentElement: e
  };
}
function Tf(t) {
  return L(() => {
    var e;
    return sV(t) ? !!((e = In(t)) != null && e.closest("form")) : !0;
  });
}
const sU = "rovingFocusGroup.onEntryFocus", aU = { bubbles: !1, cancelable: !0 }, lU = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function cU(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function uU(t, e, n) {
  const o = cU(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o)))
    return lU[o];
}
function F4(t, e = !1) {
  const n = gt();
  for (const o of t)
    if (o === n || (o.focus({ preventScroll: e }), gt() !== n))
      return;
}
function dU(t, e) {
  return t.map((n, o) => t[(e + o) % t.length]);
}
const Ab = "data-reka-collection-item";
function Yt(t = {}) {
  const { key: e = "", isProvider: n = !1 } = t, o = `${e}CollectionProvider`;
  let r;
  if (n) {
    const u = R(/* @__PURE__ */ new Map());
    r = {
      collectionRef: R(),
      itemMap: u
    }, el(o, r);
  } else
    r = kg(o);
  const i = (u = !1) => {
    const d = r.collectionRef.value;
    if (!d)
      return [];
    const f = Array.from(d.querySelectorAll(`[${Ab}]`)), m = Array.from(r.itemMap.value.values()).sort(
      (g, v) => f.indexOf(g.ref) - f.indexOf(v.ref)
    );
    return u ? m : m.filter((g) => g.ref.dataset.disabled !== "");
  }, s = I({
    name: "CollectionSlot",
    setup(u, { slots: d }) {
      const { primitiveElement: f, currentElement: p } = Sm();
      return le(p, () => {
        r.collectionRef.value = p.value;
      }), () => Ot(ym, { ref: f }, d);
    }
  }), a = I({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: {
      value: {
        // It accepts any value
        validator: () => !0
      }
    },
    setup(u, { slots: d, attrs: f }) {
      const { primitiveElement: p, currentElement: m } = Sm();
      return Ve((g) => {
        if (m.value) {
          const v = bg(m.value);
          r.itemMap.value.set(v, { ref: m.value, value: u.value }), g(() => r.itemMap.value.delete(v));
        }
      }), () => Ot(ym, { ...f, [Ab]: "", ref: p }, d);
    }
  }), l = L(() => Array.from(r.itemMap.value.values())), c = L(() => r.itemMap.value.size);
  return { getItems: i, reactiveItems: l, itemMapSize: c, CollectionSlot: s, CollectionItem: a };
}
const [fU, pU] = je("RovingFocusGroup"), Of = /* @__PURE__ */ I({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    preventScrollOnEntryFocus: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, { loop: i, orientation: s, dir: a } = st(o), l = qo(a), c = It(o, "currentTabStopId", r, {
      defaultValue: o.defaultCurrentTabStopId,
      passive: o.currentTabStopId === void 0
    }), u = R(!1), d = R(!1), f = R(0), { getItems: p, CollectionSlot: m } = Yt({ isProvider: !0 });
    function g(y) {
      const w = !d.value;
      if (y.currentTarget && y.target === y.currentTarget && w && !u.value) {
        const x = new CustomEvent(sU, aU);
        if (y.currentTarget.dispatchEvent(x), r("entryFocus", x), !x.defaultPrevented) {
          const b = p().map(($) => $.ref).filter(($) => $.dataset.disabled !== ""), S = b.find(($) => $.getAttribute("data-active") === ""), k = b.find(
            ($) => $.id === c.value
          ), A = [S, k, ...b].filter(
            Boolean
          );
          F4(A, o.preventScrollOnEntryFocus);
        }
      }
      d.value = !1;
    }
    function v() {
      setTimeout(() => {
        d.value = !1;
      }, 1);
    }
    return e({
      getItems: p
    }), pU({
      loop: i,
      dir: l,
      orientation: s,
      currentTabStopId: c,
      onItemFocus: (y) => {
        c.value = y;
      },
      onItemShiftTab: () => {
        u.value = !0;
      },
      onFocusableItemAdd: () => {
        f.value++;
      },
      onFocusableItemRemove: () => {
        f.value--;
      }
    }), (y, w) => (E(), T(h(m), null, {
      default: C(() => [
        _(h(ae), {
          tabindex: u.value || f.value === 0 ? -1 : 0,
          "data-orientation": h(s),
          as: y.as,
          "as-child": y.asChild,
          dir: h(l),
          style: { outline: "none" },
          onMousedown: w[0] || (w[0] = (x) => d.value = !0),
          onMouseup: v,
          onFocus: g,
          onBlur: w[1] || (w[1] = (x) => u.value = !1)
        }, {
          default: C(() => [
            D(y.$slots, "default")
          ]),
          _: 3
        }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), Tb = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {},
    value: {},
    checked: { type: Boolean, default: void 0 },
    required: { type: Boolean },
    disabled: { type: Boolean },
    feature: { default: "fully-hidden" }
  },
  setup(t) {
    const e = t, { primitiveElement: n, currentElement: o } = Sm(), r = L(() => e.checked ?? e.value);
    return le(r, (i, s) => {
      if (!o.value)
        return;
      const a = o.value, l = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(l, "value").set;
      if (u && i !== s) {
        const d = new Event("input", { bubbles: !0 }), f = new Event("change", { bubbles: !0 });
        u.call(a, i), a.dispatchEvent(d), a.dispatchEvent(f);
      }
    }), (i, s) => (E(), T(Jl, j({
      ref_key: "primitiveElement",
      ref: n
    }, { ...e, ...i.$attrs }, { as: "input" }), null, 16));
  }
}), B1 = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {},
    checked: { type: Boolean, default: void 0 },
    required: { type: Boolean },
    disabled: { type: Boolean },
    feature: { default: "fully-hidden" }
  },
  setup(t) {
    const e = t, n = L(
      () => typeof e.value == "object" && Array.isArray(e.value) && e.value.length === 0 && e.required
    ), o = L(() => typeof e.value == "string" || typeof e.value == "number" || typeof e.value == "boolean" ? [{ name: e.name, value: e.value }] : typeof e.value == "object" && Array.isArray(e.value) ? e.value.flatMap((r, i) => typeof r == "object" ? Object.entries(r).map(([s, a]) => ({ name: `[${e.name}][${i}][${s}]`, value: a })) : { name: `[${e.name}][${i}]`, value: r }) : e.value !== null && typeof e.value == "object" && !Array.isArray(e.value) ? Object.entries(e.value).map(([r, i]) => ({ name: `[${e.name}][${r}]`, value: i })) : []);
    return (r, i) => n.value ? (E(), T(Tb, j({ key: r.name }, { ...e, ...r.$attrs }, {
      name: r.name,
      value: r.value
    }), null, 16, ["name", "value"])) : (E(!0), W(me, { key: 1 }, Oe(o.value, (s) => (E(), T(Tb, j({
      key: s.name,
      ref_for: !0
    }, { ...e, ...r.$attrs }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"]))), 128));
  }
}), [hU, are] = je("CheckboxGroupRoot");
function td(t) {
  return t === "indeterminate";
}
function z4(t) {
  return td(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
const Mf = /* @__PURE__ */ I({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean },
    allowShiftKey: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, n = fU(), o = St(), r = L(() => e.tabStopId || o), i = L(
      () => n.currentTabStopId.value === r.value
    ), { getItems: s, CollectionItem: a } = Yt();
    be(() => {
      e.focusable && n.onFocusableItemAdd();
    }), Nt(() => {
      e.focusable && n.onFocusableItemRemove();
    });
    function l(c) {
      if (c.key === "Tab" && c.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (c.target !== c.currentTarget)
        return;
      const u = uU(
        c,
        n.orientation.value,
        n.dir.value
      );
      if (u !== void 0) {
        if (c.metaKey || c.ctrlKey || c.altKey || !e.allowShiftKey && c.shiftKey)
          return;
        c.preventDefault();
        let d = [...s().map((f) => f.ref).filter((f) => f.dataset.disabled !== "")];
        if (u === "last")
          d.reverse();
        else if (u === "prev" || u === "next") {
          u === "prev" && d.reverse();
          const f = d.indexOf(
            c.currentTarget
          );
          d = n.loop.value ? dU(d, f + 1) : d.slice(f + 1);
        }
        ze(() => F4(d));
      }
    }
    return (c, u) => (E(), T(h(a), null, {
      default: C(() => [
        _(h(ae), {
          tabindex: i.value ? 0 : -1,
          "data-orientation": h(n).orientation.value,
          "data-active": c.active ? "" : void 0,
          "data-disabled": c.focusable ? void 0 : "",
          as: c.as,
          "as-child": c.asChild,
          onMousedown: u[0] || (u[0] = (d) => {
            c.focusable ? h(n).onItemFocus(r.value) : d.preventDefault();
          }),
          onFocus: u[1] || (u[1] = (d) => h(n).onItemFocus(r.value)),
          onKeydown: l
        }, {
          default: C(() => [
            D(c.$slots, "default")
          ]),
          _: 3
        }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), [mU, gU] = je("CheckboxRoot"), vU = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null], default: void 0 },
    disabled: { type: Boolean },
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = ee(), s = hU(null), a = It(n, "modelValue", o, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), l = L(() => (s == null ? void 0 : s.disabled.value) || n.disabled), c = L(() => yl(s == null ? void 0 : s.modelValue.value) ? a.value === "indeterminate" ? "indeterminate" : a.value : Qu(s.modelValue.value, n.value));
    function u() {
      if (yl(s == null ? void 0 : s.modelValue.value))
        a.value = td(a.value) ? !0 : !a.value;
      else {
        const p = [...s.modelValue.value || []];
        if (Qu(p, n.value)) {
          const m = p.findIndex((g) => Os(g, n.value));
          p.splice(m, 1);
        } else
          p.push(n.value);
        s.modelValue.value = p;
      }
    }
    const d = Tf(i), f = L(() => {
      var p;
      return n.id && i.value ? (p = document.querySelector(`[for="${n.id}"]`)) == null ? void 0 : p.innerText : void 0;
    });
    return gU({
      disabled: l,
      state: c
    }), (p, m) => {
      var g, v;
      return E(), T(An((g = h(s)) != null && g.rovingFocus.value ? h(Mf) : h(ae)), j(p.$attrs, {
        id: p.id,
        ref: h(r),
        role: "checkbox",
        "as-child": p.asChild,
        as: p.as,
        type: p.as === "button" ? "button" : void 0,
        "aria-checked": h(td)(c.value) ? "mixed" : c.value,
        "aria-required": p.required,
        "aria-label": p.$attrs["aria-label"] || f.value,
        "data-state": h(z4)(c.value),
        "data-disabled": l.value ? "" : void 0,
        disabled: l.value,
        focusable: (v = h(s)) != null && v.rovingFocus.value ? !l.value : void 0,
        onKeydown: Sr(mt(() => {
        }, ["prevent"]), ["enter"]),
        onClick: u
      }), {
        default: C(() => [
          D(p.$slots, "default", {
            modelValue: h(a),
            state: c.value
          }),
          h(d) && p.name && !h(s) ? (E(), T(h(B1), {
            key: 0,
            type: "checkbox",
            checked: !!c.value,
            name: p.name,
            value: p.value,
            disabled: l.value,
            required: p.required
          }, null, 8, ["checked", "name", "value", "disabled", "required"])) : oe("", !0)
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-required", "aria-label", "data-state", "data-disabled", "disabled", "focusable", "onKeydown"]);
    };
  }
}), yU = /* @__PURE__ */ I({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const { forwardRef: e } = ee(), n = mU();
    return (o, r) => (E(), T(h(rn), {
      present: o.forceMount || h(td)(h(n).state.value) || h(n).state.value === !0
    }, {
      default: C(() => [
        _(h(ae), j({
          ref: h(e),
          "data-state": h(z4)(h(n).state.value),
          "data-disabled": h(n).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": o.asChild,
          as: o.as
        }, o.$attrs), {
          default: C(() => [
            D(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [H4, bU] = je("PopperRoot"), ec = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(t) {
    const e = R();
    return bU({
      anchor: e,
      onAnchorChange: (n) => e.value = n
    }), (n, o) => D(n.$slots, "default");
  }
});
function F1(t) {
  const e = A4("", 1e3);
  return {
    search: e,
    handleTypeaheadSearch: (r, i) => {
      e.value = e.value + r;
      {
        const s = gt(), a = i.map((f) => {
          var p, m;
          return {
            ...f,
            textValue: ((p = f.value) == null ? void 0 : p.textValue) ?? ((m = f.ref.textContent) == null ? void 0 : m.trim()) ?? ""
          };
        }), l = a.find((f) => f.ref === s), c = a.map((f) => f.textValue), u = wU(c, e.value, l == null ? void 0 : l.textValue), d = a.find((f) => f.textValue === u);
        return d && d.ref.focus(), d == null ? void 0 : d.ref;
      }
    },
    resetTypeahead: () => {
      e.value = "";
    }
  };
}
function V4(t, e) {
  return t.map((n, o) => t[(e + o) % t.length]);
}
function wU(t, e, n) {
  const r = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e, i = n ? t.indexOf(n) : -1;
  let s = V4(t, Math.max(i, 0));
  r.length === 1 && (s = s.filter((c) => c !== n));
  const l = s.find(
    (c) => c.toLowerCase().startsWith(r.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function xU(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
const If = /* @__PURE__ */ I({
  __name: "PopperAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n, currentElement: o } = ee(), r = H4();
    return q2(() => {
      r.onAnchorChange(e.reference ?? o.value);
    }), (i, s) => (E(), T(h(ae), {
      ref: h(n),
      as: i.as,
      "as-child": i.asChild
    }, {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function CU(t) {
  return t !== null;
}
function SU(t) {
  return {
    name: "transformOrigin",
    options: t,
    fn(e) {
      var v, y, w;
      const { placement: n, rects: o, middlewareData: r } = e, s = ((v = r.arrow) == null ? void 0 : v.centerOffset) !== 0, a = s ? 0 : t.arrowWidth, l = s ? 0 : t.arrowHeight, [c, u] = km(n), d = { start: "0%", center: "50%", end: "100%" }[u], f = (((y = r.arrow) == null ? void 0 : y.x) ?? 0) + a / 2, p = (((w = r.arrow) == null ? void 0 : w.y) ?? 0) + l / 2;
      let m = "", g = "";
      return c === "bottom" ? (m = s ? d : `${f}px`, g = `${-l}px`) : c === "top" ? (m = s ? d : `${f}px`, g = `${o.floating.height + l}px`) : c === "right" ? (m = `${-l}px`, g = s ? d : `${p}px`) : c === "left" && (m = `${o.floating.width + l}px`, g = s ? d : `${p}px`), { data: { x: m, y: g } };
    }
  };
}
function km(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
function kU(t) {
  const e = R(), n = L(() => {
    var r;
    return ((r = e.value) == null ? void 0 : r.width) ?? 0;
  }), o = L(() => {
    var r;
    return ((r = e.value) == null ? void 0 : r.height) ?? 0;
  });
  return be(() => {
    const r = In(t);
    if (r) {
      e.value = { width: r.offsetWidth, height: r.offsetHeight };
      const i = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const a = s[0];
        let l, c;
        if ("borderBoxSize" in a) {
          const u = a.borderBoxSize, d = Array.isArray(u) ? u[0] : u;
          l = d.inlineSize, c = d.blockSize;
        } else
          l = r.offsetWidth, c = r.offsetHeight;
        e.value = { width: l, height: c };
      });
      return i.observe(r, { box: "border-box" }), () => i.unobserve(r);
    } else
      e.value = void 0;
  }), {
    width: n,
    height: o
  };
}
const U4 = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [lre, EU] = je("PopperContent"), Rf = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ Y2({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...U4
  }),
  emits: ["placed"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = H4(), { forwardRef: i, currentElement: s } = ee(), a = R(), l = R(), { width: c, height: u } = kU(l), d = L(
      () => n.side + (n.align !== "center" ? `-${n.align}` : "")
    ), f = L(() => typeof n.collisionPadding == "number" ? n.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...n.collisionPadding }), p = L(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = L(() => ({
      padding: f.value,
      boundary: p.value.filter(CU),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: p.value.length > 0
    })), g = GH(() => [
      DH({
        mainAxis: n.sideOffset + u.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && wb({
        ...m.value
      }),
      n.avoidCollisions && NH({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? HH() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && wb({
        ...m.value
      }),
      BH({
        ...m.value,
        apply: ({ elements: P, rects: F, availableWidth: J, availableHeight: Q }) => {
          const { width: G, height: V } = F.reference, B = P.floating.style;
          B.setProperty(
            "--reka-popper-available-width",
            `${J}px`
          ), B.setProperty(
            "--reka-popper-available-height",
            `${Q}px`
          ), B.setProperty(
            "--reka-popper-anchor-width",
            `${G}px`
          ), B.setProperty(
            "--reka-popper-anchor-height",
            `${V}px`
          );
        }
      }),
      l.value && jH({ element: l.value, padding: n.arrowPadding }),
      SU({
        arrowWidth: c.value,
        arrowHeight: u.value
      }),
      n.hideWhenDetached && FH({ strategy: "referenceHidden", ...m.value })
    ]), v = L(() => n.reference ?? r.anchor.value), { floatingStyles: y, placement: w, isPositioned: x, middlewareData: b } = WH(
      v,
      a,
      {
        strategy: n.positionStrategy,
        placement: d,
        whileElementsMounted: (...P) => LH(...P, {
          layoutShift: !n.disableUpdateOnLayoutShift,
          animationFrame: n.updatePositionStrategy === "always"
        }),
        middleware: g
      }
    ), S = L(
      () => km(w.value)[0]
    ), k = L(
      () => km(w.value)[1]
    );
    q2(() => {
      x.value && o("placed");
    });
    const A = L(
      () => {
        var P;
        return ((P = b.value.arrow) == null ? void 0 : P.centerOffset) !== 0;
      }
    ), $ = R("");
    Ve(() => {
      s.value && ($.value = window.getComputedStyle(s.value).zIndex);
    });
    const O = L(() => {
      var P;
      return ((P = b.value.arrow) == null ? void 0 : P.x) ?? 0;
    }), M = L(() => {
      var P;
      return ((P = b.value.arrow) == null ? void 0 : P.y) ?? 0;
    });
    return EU({
      placedSide: S,
      onArrowChange: (P) => l.value = P,
      arrowX: O,
      arrowY: M,
      shouldHideArrow: A
    }), (P, F) => {
      var J, Q, G;
      return E(), W("div", {
        ref_key: "floatingRef",
        ref: a,
        "data-reka-popper-content-wrapper": "",
        style: pt({
          ...h(y),
          transform: h(x) ? h(y).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: $.value,
          "--reka-popper-transform-origin": [
            (J = h(b).transformOrigin) == null ? void 0 : J.x,
            (Q = h(b).transformOrigin) == null ? void 0 : Q.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((G = h(b).hide) == null ? void 0 : G.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        _(h(ae), j({ ref: h(i) }, P.$attrs, {
          "as-child": n.asChild,
          as: P.as,
          "data-side": S.value,
          "data-align": k.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: h(x) ? void 0 : "none"
          }
        }), {
          default: C(() => [
            D(P.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
});
function j4(t) {
  const e = kf({
    nonce: R()
  });
  return L(() => {
    var n;
    return (t == null ? void 0 : t.value) || ((n = e.nonce) == null ? void 0 : n.value);
  });
}
function _U() {
  const t = R(!1);
  return be(() => {
    Ts("keydown", () => {
      t.value = !0;
    }, { capture: !0, passive: !0 }), Ts(["pointerdown", "pointermove"], () => {
      t.value = !1;
    }, { capture: !0, passive: !0 });
  }), t;
}
const AU = _4(_U), [Li, W4] = je(["MenuRoot", "MenuSub"], "MenuContext"), [tc, TU] = je("MenuRoot"), K4 = /* @__PURE__ */ I({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { modal: r, dir: i } = st(n), s = qo(i), a = It(n, "open", o), l = R(), c = AU();
    return W4({
      open: a,
      onOpenChange: (u) => {
        a.value = u;
      },
      content: l,
      onContentChange: (u) => {
        l.value = u;
      }
    }), TU({
      onClose: () => {
        a.value = !1;
      },
      isUsingKeyboardRef: c,
      dir: s,
      modal: r
    }), (u, d) => (E(), T(h(ec), null, {
      default: C(() => [
        D(u.$slots, "default")
      ]),
      _: 3
    }));
  }
}), z1 = /* @__PURE__ */ I({
  __name: "MenuAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(If), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), G4 = /* @__PURE__ */ I({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Zl), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
let Vp = 0;
function H1() {
  Ve((t) => {
    if (!yo)
      return;
    const e = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      e[0] ?? Ob()
    ), document.body.insertAdjacentElement(
      "beforeend",
      e[1] ?? Ob()
    ), Vp++, t(() => {
      Vp === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), Vp--;
    });
  });
}
function Ob() {
  const t = document.createElement("span");
  return t.setAttribute("data-reka-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
const [V1, OU] = je("MenuContent"), U1 = /* @__PURE__ */ I({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ Y2({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...U4
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Li(), i = tc(), { trapFocus: s, disableOutsidePointerEvents: a, loop: l } = st(n);
    H1(), Af(a.value);
    const c = R(""), u = R(0), d = R(0), f = R(null), p = R("right"), m = R(0), g = R(null), v = R(), { forwardRef: y, currentElement: w } = ee(), { handleTypeaheadSearch: x } = F1();
    le(w, (O) => {
      r.onContentChange(O);
    }), Nt(() => {
      window.clearTimeout(u.value);
    });
    function b(O) {
      var P, F;
      return p.value === ((P = f.value) == null ? void 0 : P.side) && LV(O, (F = f.value) == null ? void 0 : F.area);
    }
    async function S(O) {
      var M;
      o("openAutoFocus", O), !O.defaultPrevented && (O.preventDefault(), (M = w.value) == null || M.focus({
        preventScroll: !0
      }));
    }
    function k(O) {
      var B;
      if (O.defaultPrevented)
        return;
      const P = O.target.closest("[data-reka-menu-content]") === O.currentTarget, F = O.ctrlKey || O.altKey || O.metaKey, J = O.key.length === 1, Q = wV(
        O,
        gt(),
        w.value,
        {
          loop: l.value,
          arrowKeyOptions: "vertical",
          dir: i == null ? void 0 : i.dir.value,
          focus: !0,
          attributeName: "[data-reka-collection-item]:not([data-disabled])"
        }
      );
      if (Q)
        return Q == null ? void 0 : Q.focus();
      if (O.code === "Space")
        return;
      const G = ((B = v.value) == null ? void 0 : B.getItems()) ?? [];
      if (P && (O.key === "Tab" && O.preventDefault(), !F && J && x(O.key, G)), O.target !== w.value || !IV.includes(O.key))
        return;
      O.preventDefault();
      const V = [...G.map((q) => q.ref)];
      P4.includes(O.key) && V.reverse(), xm(V);
    }
    function A(O) {
      var M, P;
      (P = (M = O == null ? void 0 : O.currentTarget) == null ? void 0 : M.contains) != null && P.call(M, O.target) || (window.clearTimeout(u.value), c.value = "");
    }
    function $(O) {
      var F;
      if (!bl(O))
        return;
      const M = O.target, P = m.value !== O.clientX;
      if ((F = O == null ? void 0 : O.currentTarget) != null && F.contains(M) && P) {
        const J = O.clientX > m.value ? "right" : "left";
        p.value = J, m.value = O.clientX;
      }
    }
    return OU({
      onItemEnter: (O) => !!b(O),
      onItemLeave: (O) => {
        var M;
        b(O) || ((M = w.value) == null || M.focus(), g.value = null);
      },
      onTriggerLeave: (O) => !!b(O),
      searchRef: c,
      pointerGraceTimerRef: d,
      onPointerGraceIntentChange: (O) => {
        f.value = O;
      }
    }), (O, M) => (E(), T(h(Ef), {
      "as-child": "",
      trapped: h(s),
      onMountAutoFocus: S,
      onUnmountAutoFocus: M[7] || (M[7] = (P) => o("closeAutoFocus", P))
    }, {
      default: C(() => [
        _(h(Ql), {
          "as-child": "",
          "disable-outside-pointer-events": h(a),
          onEscapeKeyDown: M[2] || (M[2] = (P) => o("escapeKeyDown", P)),
          onPointerDownOutside: M[3] || (M[3] = (P) => o("pointerDownOutside", P)),
          onFocusOutside: M[4] || (M[4] = (P) => o("focusOutside", P)),
          onInteractOutside: M[5] || (M[5] = (P) => o("interactOutside", P)),
          onDismiss: M[6] || (M[6] = (P) => o("dismiss"))
        }, {
          default: C(() => [
            _(h(Of), {
              ref_key: "rovingFocusGroupRef",
              ref: v,
              "current-tab-stop-id": g.value,
              "onUpdate:currentTabStopId": M[0] || (M[0] = (P) => g.value = P),
              "as-child": "",
              orientation: "vertical",
              dir: h(i).dir.value,
              loop: h(l),
              onEntryFocus: M[1] || (M[1] = (P) => {
                o("entryFocus", P), h(i).isUsingKeyboardRef.value || P.preventDefault();
              })
            }, {
              default: C(() => [
                _(h(Rf), {
                  ref: h(y),
                  role: "menu",
                  as: O.as,
                  "as-child": O.asChild,
                  "aria-orientation": "vertical",
                  "data-reka-menu-content": "",
                  "data-state": h(D1)(h(r).open.value),
                  dir: h(i).dir.value,
                  side: O.side,
                  "side-offset": O.sideOffset,
                  align: O.align,
                  "align-offset": O.alignOffset,
                  "avoid-collisions": O.avoidCollisions,
                  "collision-boundary": O.collisionBoundary,
                  "collision-padding": O.collisionPadding,
                  "arrow-padding": O.arrowPadding,
                  "prioritize-position": O.prioritizePosition,
                  "position-strategy": O.positionStrategy,
                  "update-position-strategy": O.updatePositionStrategy,
                  sticky: O.sticky,
                  "hide-when-detached": O.hideWhenDetached,
                  reference: O.reference,
                  onKeydown: k,
                  onBlur: A,
                  onPointermove: $
                }, {
                  default: C(() => [
                    D(O.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "position-strategy", "update-position-strategy", "sticky", "hide-when-detached", "reference"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), MU = /* @__PURE__ */ I({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Ie(n, o), i = Li(), { forwardRef: s, currentElement: a } = ee();
    return _f(a), (l, c) => (E(), T(U1, j(h(r), {
      ref: h(s),
      "trap-focus": h(i).open.value,
      "disable-outside-pointer-events": h(i).open.value,
      "disable-outside-scroll": !0,
      onDismiss: c[0] || (c[0] = (u) => h(i).onOpenChange(!1)),
      onFocusOutside: c[1] || (c[1] = mt((u) => o("focusOutside", u), ["prevent"]))
    }), {
      default: C(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), IU = /* @__PURE__ */ I({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const r = Ie(t, e), i = Li();
    return (s, a) => (E(), T(U1, j(h(r), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: a[0] || (a[0] = (l) => h(i).onOpenChange(!1))
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), q4 = /* @__PURE__ */ I({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const r = Ie(t, e), i = Li(), s = tc();
    return (a, l) => (E(), T(h(rn), {
      present: a.forceMount || h(i).open.value
    }, {
      default: C(() => [
        h(s).modal.value ? (E(), T(MU, _e(j({ key: 0 }, { ...a.$attrs, ...h(r) })), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)) : (E(), T(IU, _e(j({ key: 1 }, { ...a.$attrs, ...h(r) })), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Y4 = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = V1(), { forwardRef: o } = ee(), { CollectionItem: r } = Yt(), i = R(!1);
    async function s(l) {
      if (!l.defaultPrevented && bl(l)) {
        if (e.disabled)
          n.onItemLeave(l);
        else if (!n.onItemEnter(l)) {
          const u = l.currentTarget;
          u == null || u.focus({ preventScroll: !0 });
        }
      }
    }
    async function a(l) {
      await ze(), !l.defaultPrevented && bl(l) && n.onItemLeave(l);
    }
    return (l, c) => (E(), T(h(r), {
      value: { textValue: l.textValue }
    }, {
      default: C(() => [
        _(h(ae), j({
          ref: h(o),
          role: "menuitem",
          tabindex: "-1"
        }, l.$attrs, {
          as: l.as,
          "as-child": l.asChild,
          "aria-disabled": l.disabled || void 0,
          "data-disabled": l.disabled ? "" : void 0,
          "data-highlighted": i.value ? "" : void 0,
          onPointermove: s,
          onPointerleave: a,
          onFocus: c[0] || (c[0] = async (u) => {
            await ze(), !(u.defaultPrevented || l.disabled) && (i.value = !0);
          }),
          onBlur: c[1] || (c[1] = async (u) => {
            await ze(), !u.defaultPrevented && (i.value = !1);
          })
        }), {
          default: C(() => [
            D(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"])
      ]),
      _: 3
    }, 8, ["value"]));
  }
}), j1 = /* @__PURE__ */ I({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = ee(), s = tc(), a = V1(), l = R(!1);
    async function c() {
      const u = i.value;
      if (!n.disabled && u) {
        const d = new CustomEvent(OV, {
          bubbles: !0,
          cancelable: !0
        });
        o("select", d), await ze(), d.defaultPrevented ? l.value = !1 : s.onClose();
      }
    }
    return (u, d) => (E(), T(Y4, j(n, {
      ref: h(r),
      onClick: c,
      onPointerdown: d[0] || (d[0] = () => {
        l.value = !0;
      }),
      onPointerup: d[1] || (d[1] = async (f) => {
        var p;
        await ze(), !f.defaultPrevented && (l.value || (p = f.currentTarget) == null || p.click());
      }),
      onKeydown: d[2] || (d[2] = async (f) => {
        const p = h(a).searchRef.value !== "";
        u.disabled || p && f.key === " " || h(wm).includes(f.key) && (f.currentTarget.click(), f.preventDefault());
      })
    }), {
      default: C(() => [
        D(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), J4 = /* @__PURE__ */ I({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(ae), j(e, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [RU, $U] = je(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
), X4 = /* @__PURE__ */ I({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = RU({
      modelValue: R(!1)
    });
    return (n, o) => (E(), T(h(rn), {
      present: n.forceMount || h(ed)(h(e).modelValue.value) || h(e).modelValue.value === !0
    }, {
      default: C(() => [
        _(h(ae), {
          as: n.as,
          "as-child": n.asChild,
          "data-state": h(L4)(h(e).modelValue.value)
        }, {
          default: C(() => [
            D(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Z4 = /* @__PURE__ */ I({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String], default: !1 },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = It(n, "modelValue", o);
    return $U({ modelValue: r }), (i, s) => (E(), T(j1, j({ role: "menuitemcheckbox" }, n, {
      "aria-checked": h(ed)(h(r)) ? "mixed" : h(r),
      "data-state": h(L4)(h(r)),
      onSelect: s[0] || (s[0] = async (a) => {
        o("select", a), h(ed)(h(r)) ? r.value = !0 : r.value = !h(r);
      })
    }), {
      default: C(() => [
        D(i.$slots, "default", { modelValue: h(r) })
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), [Q4, PU] = je("MenuSub"), LU = /* @__PURE__ */ I({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, r = It(n, "open", e, {
      defaultValue: !1,
      passive: n.open === void 0
    }), i = Li(), s = R(), a = R();
    return Ve((l) => {
      (i == null ? void 0 : i.open.value) === !1 && (r.value = !1), l(() => r.value = !1);
    }), W4({
      open: r,
      onOpenChange: (l) => {
        r.value = l;
      },
      content: a,
      onContentChange: (l) => {
        a.value = l;
      }
    }), PU({
      triggerId: "",
      contentId: "",
      trigger: s,
      onTriggerChange: (l) => {
        s.value = l;
      }
    }), (l, c) => (E(), T(h(ec), null, {
      default: C(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }));
  }
}), DU = /* @__PURE__ */ I({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean, default: !0 },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const r = Ie(t, e), i = Li(), s = tc(), a = Q4(), { forwardRef: l, currentElement: c } = ee();
    return a.contentId || (a.contentId = St(void 0, "reka-menu-sub-content")), (u, d) => (E(), T(h(rn), {
      present: u.forceMount || h(i).open.value
    }, {
      default: C(() => [
        _(U1, j(h(r), {
          id: h(a).contentId,
          ref: h(l),
          "aria-labelledby": h(a).triggerId,
          align: "start",
          side: h(s).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": !1,
          "disable-outside-scroll": !1,
          "trap-focus": !1,
          onOpenAutoFocus: d[0] || (d[0] = mt((f) => {
            var p;
            h(s).isUsingKeyboardRef.value && ((p = h(c)) == null || p.focus());
          }, ["prevent"])),
          onCloseAutoFocus: d[1] || (d[1] = mt(() => {
          }, ["prevent"])),
          onFocusOutside: d[2] || (d[2] = (f) => {
            f.defaultPrevented || f.target !== h(a).trigger.value && h(i).onOpenChange(!1);
          }),
          onEscapeKeyDown: d[3] || (d[3] = (f) => {
            h(s).onClose(), f.preventDefault();
          }),
          onKeydown: d[4] || (d[4] = (f) => {
            var g, v;
            const p = (g = f.currentTarget) == null ? void 0 : g.contains(f.target), m = h($V)[h(s).dir.value].includes(f.key);
            p && m && (h(i).onOpenChange(!1), (v = h(a).trigger.value) == null || v.focus(), f.preventDefault());
          })
        }), {
          default: C(() => [
            D(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), NU = /* @__PURE__ */ I({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = Li(), o = tc(), r = Q4(), i = V1(), s = R(null);
    r.triggerId || (r.triggerId = St(void 0, "reka-menu-sub-trigger"));
    function a() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    Nt(() => {
      a();
    });
    function l(d) {
      !bl(d) || i.onItemEnter(d) || !e.disabled && !n.open.value && !s.value && (i.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), a();
      }, 100));
    }
    async function c(d) {
      var p, m;
      if (!bl(d))
        return;
      a();
      const f = (p = n.content.value) == null ? void 0 : p.getBoundingClientRect();
      if (f != null && f.width) {
        const g = (m = n.content.value) == null ? void 0 : m.dataset.side, v = g === "right", y = v ? -5 : 5, w = f[v ? "left" : "right"], x = f[v ? "right" : "left"];
        i.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: d.clientX + y, y: d.clientY },
            { x: w, y: f.top },
            { x, y: f.top },
            { x, y: f.bottom },
            { x: w, y: f.bottom }
          ],
          side: g
        }), window.clearTimeout(i.pointerGraceTimerRef.value), i.pointerGraceTimerRef.value = window.setTimeout(
          () => i.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (i.onTriggerLeave(d))
          return;
        i.onPointerGraceIntentChange(null);
      }
    }
    async function u(d) {
      var p;
      const f = i.searchRef.value !== "";
      e.disabled || f && d.key === " " || RV[o.dir.value].includes(d.key) && (n.onOpenChange(!0), await ze(), (p = n.content.value) == null || p.focus(), d.preventDefault());
    }
    return (d, f) => (E(), T(z1, { "as-child": "" }, {
      default: C(() => [
        _(Y4, j(e, {
          id: h(r).triggerId,
          ref: (p) => {
            var m;
            (m = h(r)) == null || m.onTriggerChange(p == null ? void 0 : p.$el);
          },
          "aria-haspopup": "menu",
          "aria-expanded": h(n).open.value,
          "aria-controls": h(r).contentId,
          "data-state": h(D1)(h(n).open.value),
          onClick: f[0] || (f[0] = async (p) => {
            e.disabled || p.defaultPrevented || (p.currentTarget.focus(), h(n).open.value || h(n).onOpenChange(!0));
          }),
          onPointermove: l,
          onPointerleave: c,
          onKeydown: u
        }), {
          default: C(() => [
            D(d.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
      ]),
      _: 3
    }));
  }
}), [nc, BU] = je("PopoverRoot"), FU = /* @__PURE__ */ I({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { modal: r } = st(n), i = It(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = R(), a = R(!1);
    return BU({
      contentId: "",
      triggerId: "",
      modal: r,
      open: i,
      onOpenChange: (l) => {
        i.value = l;
      },
      onOpenToggle: () => {
        i.value = !i.value;
      },
      triggerElement: s,
      hasCustomAnchor: a
    }), (l, c) => (E(), T(h(ec), null, {
      default: C(() => [
        D(l.$slots, "default", { open: h(i) })
      ]),
      _: 3
    }));
  }
}), zU = /* @__PURE__ */ I({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = nc(), { forwardRef: o, currentElement: r } = ee();
    return n.triggerId || (n.triggerId = St(void 0, "reka-popover-trigger")), be(() => {
      n.triggerElement.value = r.value;
    }), (i, s) => (E(), T(An(h(n).hasCustomAnchor.value ? h(ae) : h(If)), { "as-child": "" }, {
      default: C(() => [
        _(h(ae), {
          id: h(n).triggerId,
          ref: h(o),
          type: i.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": h(n).open.value,
          "aria-controls": h(n).contentId,
          "data-state": h(n).open.value ? "open" : "closed",
          as: i.as,
          "as-child": e.asChild,
          onClick: h(n).onOpenToggle
        }, {
          default: C(() => [
            D(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
}), HU = /* @__PURE__ */ I({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Zl), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ek = /* @__PURE__ */ I({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = vt(ZH(n, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: i } = ee(), s = nc();
    return H1(), (a, l) => (E(), T(h(Ef), {
      "as-child": "",
      loop: "",
      trapped: a.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (c) => o("openAutoFocus", c)),
      onUnmountAutoFocus: l[6] || (l[6] = (c) => o("closeAutoFocus", c))
    }, {
      default: C(() => [
        _(h(Ql), {
          "as-child": "",
          "disable-outside-pointer-events": a.disableOutsidePointerEvents,
          onPointerDownOutside: l[0] || (l[0] = (c) => o("pointerDownOutside", c)),
          onInteractOutside: l[1] || (l[1] = (c) => o("interactOutside", c)),
          onEscapeKeyDown: l[2] || (l[2] = (c) => o("escapeKeyDown", c)),
          onFocusOutside: l[3] || (l[3] = (c) => o("focusOutside", c)),
          onDismiss: l[4] || (l[4] = (c) => h(s).onOpenChange(!1))
        }, {
          default: C(() => [
            _(h(Rf), j(h(r), {
              id: h(s).contentId,
              ref: h(i),
              "data-state": h(s).open.value ? "open" : "closed",
              "aria-labelledby": h(s).triggerId,
              style: {
                "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
                "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
                "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
                "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
                "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
              },
              role: "dialog"
            }), {
              default: C(() => [
                D(a.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "aria-labelledby"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), VU = /* @__PURE__ */ I({
  __name: "PopoverContentModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = nc(), i = R(!1);
    Af(!0);
    const s = Ie(n, o), { forwardRef: a, currentElement: l } = ee();
    return _f(l), (c, u) => (E(), T(ek, j(h(s), {
      ref: h(a),
      "trap-focus": h(r).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: u[0] || (u[0] = mt(
        (d) => {
          var f;
          o("closeAutoFocus", d), i.value || (f = h(r).triggerElement.value) == null || f.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: u[1] || (u[1] = (d) => {
        o("pointerDownOutside", d);
        const f = d.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, m = f.button === 2 || p;
        i.value = m;
      }),
      onFocusOutside: u[2] || (u[2] = mt(() => {
      }, ["prevent"]))
    }), {
      default: C(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), UU = /* @__PURE__ */ I({
  __name: "PopoverContentNonModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = nc(), i = R(!1), s = R(!1), a = Ie(n, o);
    return (l, c) => (E(), T(ek, j(h(a), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: c[0] || (c[0] = (u) => {
        var d;
        o("closeAutoFocus", u), u.defaultPrevented || (i.value || (d = h(r).triggerElement.value) == null || d.focus(), u.preventDefault()), i.value = !1, s.value = !1;
      }),
      onInteractOutside: c[1] || (c[1] = async (u) => {
        var p;
        o("interactOutside", u), u.defaultPrevented || (i.value = !0, u.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const d = u.target;
        ((p = h(r).triggerElement.value) == null ? void 0 : p.contains(d)) && u.preventDefault(), u.detail.originalEvent.type === "focusin" && s.value && u.preventDefault();
      })
    }), {
      default: C(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jU = /* @__PURE__ */ I({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = nc(), i = Ie(n, o), { forwardRef: s } = ee();
    return r.contentId || (r.contentId = St(void 0, "reka-popover-content")), (a, l) => (E(), T(h(rn), {
      present: a.forceMount || h(r).open.value
    }, {
      default: C(() => [
        h(r).modal.value ? (E(), T(VU, j({ key: 0 }, h(i), { ref: h(s) }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)) : (E(), T(UU, j({ key: 1 }, h(i), { ref: h(s) }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), WU = /* @__PURE__ */ I({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Zl), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [tk, KU] = je("DropdownMenuRoot"), GU = /* @__PURE__ */ I({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    ee();
    const r = It(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = R(), { modal: s, dir: a } = st(n), l = qo(a);
    return KU({
      open: r,
      onOpenChange: (c) => {
        r.value = c;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerId: "",
      triggerElement: i,
      contentId: "",
      modal: s,
      dir: l
    }), (c, u) => (E(), T(h(K4), {
      open: h(r),
      "onUpdate:open": u[0] || (u[0] = (d) => No(r) ? r.value = d : null),
      dir: h(l),
      modal: h(s)
    }, {
      default: C(() => [
        D(c.$slots, "default", { open: h(r) })
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), qU = /* @__PURE__ */ I({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = tk(), { forwardRef: o, currentElement: r } = ee();
    return be(() => {
      n.triggerElement = r;
    }), n.triggerId || (n.triggerId = St(void 0, "reka-dropdown-menu-trigger")), (i, s) => (E(), T(h(z1), { "as-child": "" }, {
      default: C(() => [
        _(h(ae), {
          id: h(n).triggerId,
          ref: h(o),
          type: i.as === "button" ? "button" : void 0,
          "as-child": e.asChild,
          as: i.as,
          "aria-haspopup": "menu",
          "aria-expanded": h(n).open.value,
          "aria-controls": h(n).open.value ? h(n).contentId : void 0,
          "data-disabled": i.disabled ? "" : void 0,
          disabled: i.disabled,
          "data-state": h(n).open.value ? "open" : "closed",
          onClick: s[0] || (s[0] = async (a) => {
            var l;
            !i.disabled && a.button === 0 && a.ctrlKey === !1 && ((l = h(n)) == null || l.onOpenToggle(), await ze(), h(n).open.value && a.preventDefault());
          }),
          onKeydown: s[1] || (s[1] = Sr(
            (a) => {
              i.disabled || (["Enter", " "].includes(a.key) && h(n).onOpenToggle(), a.key === "ArrowDown" && h(n).onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: C(() => [
            D(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), Em = /* @__PURE__ */ I({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(G4), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), YU = /* @__PURE__ */ I({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    ee();
    const i = tk(), s = R(!1);
    function a(l) {
      l.defaultPrevented || (s.value || setTimeout(() => {
        var c;
        (c = i.triggerElement.value) == null || c.focus();
      }, 0), s.value = !1, l.preventDefault());
    }
    return i.contentId || (i.contentId = St(void 0, "reka-dropdown-menu-content")), (l, c) => {
      var u;
      return E(), T(h(q4), j(h(r), {
        id: h(i).contentId,
        "aria-labelledby": (u = h(i)) == null ? void 0 : u.triggerId,
        style: {
          "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: a,
        onInteractOutside: c[0] || (c[0] = (d) => {
          var g;
          if (d.defaultPrevented) return;
          const f = d.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, m = f.button === 2 || p;
          (!h(i).modal.value || m) && (s.value = !0), (g = h(i).triggerElement.value) != null && g.contains(d.target) && d.preventDefault();
        })
      }), {
        default: C(() => [
          D(l.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
}), JU = /* @__PURE__ */ I({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, r = zr(e);
    return ee(), (i, s) => (E(), T(h(j1), _e(Me({ ...n, ...h(r) })), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), XU = /* @__PURE__ */ I({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(J4), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ZU = /* @__PURE__ */ I({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, r = zr(e);
    return ee(), (i, s) => (E(), T(h(Z4), _e(Me({ ...n, ...h(r) })), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), QU = /* @__PURE__ */ I({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(X4), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ej = /* @__PURE__ */ I({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, r = It(n, "open", e, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return ee(), (i, s) => (E(), T(h(LU), {
      open: h(r),
      "onUpdate:open": s[0] || (s[0] = (a) => No(r) ? r.value = a : null)
    }, {
      default: C(() => [
        D(i.$slots, "default", { open: h(r) })
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), tj = /* @__PURE__ */ I({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return ee(), (i, s) => (E(), T(h(DU), j(h(r), { style: {
      "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nj = /* @__PURE__ */ I({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(NU), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function oj(t, e) {
  const n = A4(!1, 300), o = R(null), r = qH();
  function i() {
    o.value = null, n.value = !1;
  }
  function s(a, l) {
    const c = a.currentTarget, u = { x: a.clientX, y: a.clientY }, d = rj(u, c.getBoundingClientRect()), f = ij(u, d), p = sj(l.getBoundingClientRect()), m = lj([...f, ...p]);
    o.value = m, n.value = !0;
  }
  return Ve((a) => {
    if (t.value && e.value) {
      const l = (u) => s(u, e.value), c = (u) => s(u, t.value);
      t.value.addEventListener("pointerleave", l), e.value.addEventListener("pointerleave", c), a(() => {
        var u, d;
        (u = t.value) == null || u.removeEventListener("pointerleave", l), (d = e.value) == null || d.removeEventListener("pointerleave", c);
      });
    }
  }), Ve((a) => {
    var l;
    if (o.value) {
      const c = (u) => {
        var v, y;
        if (!o.value || !(u.target instanceof HTMLElement))
          return;
        const d = u.target, f = { x: u.clientX, y: u.clientY }, p = ((v = t.value) == null ? void 0 : v.contains(d)) || ((y = e.value) == null ? void 0 : y.contains(d)), m = !aj(f, o.value), g = !!d.closest("[data-grace-area-trigger]");
        p ? i() : (m || g) && (i(), r.trigger());
      };
      (l = t.value) == null || l.ownerDocument.addEventListener("pointermove", c), a(() => {
        var u;
        return (u = t.value) == null ? void 0 : u.ownerDocument.removeEventListener("pointermove", c);
      });
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: r.on
  };
}
function rj(t, e) {
  const n = Math.abs(e.top - t.y), o = Math.abs(e.bottom - t.y), r = Math.abs(e.right - t.x), i = Math.abs(e.left - t.x);
  switch (Math.min(n, o, r, i)) {
    case i:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case o:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function ij(t, e, n = 5) {
  const o = [];
  switch (e) {
    case "top":
      o.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      o.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      o.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      o.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return o;
}
function sj(t) {
  const { top: e, right: n, bottom: o, left: r } = t;
  return [
    { x: r, y: e },
    { x: n, y: e },
    { x: n, y: o },
    { x: r, y: o }
  ];
}
function aj(t, e) {
  const { x: n, y: o } = t;
  let r = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const a = e[i].x, l = e[i].y, c = e[s].x, u = e[s].y;
    l > o != u > o && n < (c - a) * (o - l) / (u - l) + a && (r = !r);
  }
  return r;
}
function lj(t) {
  const e = t.slice();
  return e.sort((n, o) => n.x < o.x ? -1 : n.x > o.x ? 1 : n.y < o.y ? -1 : n.y > o.y ? 1 : 0), cj(e);
}
function cj(t) {
  if (t.length <= 1)
    return t.slice();
  const e = [];
  for (let o = 0; o < t.length; o++) {
    const r = t[o];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], s = e[e.length - 2];
      if ((i.x - s.x) * (r.y - s.y) >= (i.y - s.y) * (r.x - s.x))
        e.pop();
      else break;
    }
    e.push(r);
  }
  e.pop();
  const n = [];
  for (let o = t.length - 1; o >= 0; o--) {
    const r = t[o];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], s = n[n.length - 2];
      if ((i.x - s.x) * (r.y - s.y) >= (i.y - s.y) * (r.x - s.x))
        n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
const uj = /* @__PURE__ */ I({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(ae), j(e, {
      onMousedown: o[0] || (o[0] = (r) => {
        !r.defaultPrevented && r.detail > 1 && r.preventDefault();
      })
    }), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [W1, dj] = je("MenubarRoot"), fj = /* @__PURE__ */ I({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r } = ee(), { CollectionSlot: i } = Yt({ key: "Menubar", isProvider: !0 }), s = It(n, "modelValue", o, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), a = R(null), { dir: l, loop: c } = st(n), u = qo(l);
    return dj({
      modelValue: s,
      dir: u,
      loop: c,
      onMenuOpen: (d) => {
        s.value = d, a.value = d;
      },
      onMenuClose: () => {
        s.value = "";
      },
      onMenuToggle: (d) => {
        s.value = s.value ? "" : d, a.value = d;
      }
    }), (d, f) => (E(), T(h(i), null, {
      default: C(() => [
        _(h(Of), {
          "current-tab-stop-id": a.value,
          "onUpdate:currentTabStopId": f[0] || (f[0] = (p) => a.value = p),
          orientation: "horizontal",
          loop: h(c),
          dir: h(u),
          "as-child": ""
        }, {
          default: C(() => [
            _(h(ae), {
              ref: h(r),
              role: "menubar"
            }, {
              default: C(() => [
                D(d.$slots, "default", { modelValue: h(s) })
              ]),
              _: 3
            }, 512)
          ]),
          _: 3
        }, 8, ["current-tab-stop-id", "loop", "dir"])
      ]),
      _: 3
    }));
  }
}), [nk, pj] = je("MenubarMenu"), hj = /* @__PURE__ */ I({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(t) {
    const n = St(t.value), o = W1();
    ee();
    const r = R(), i = R(!1), s = L(() => o.modelValue.value === n);
    return le(s, () => {
      s.value || (i.value = !1);
    }), pj({
      value: n,
      triggerElement: r,
      triggerId: n,
      contentId: "",
      wasKeyboardTriggerOpenRef: i
    }), (a, l) => (E(), T(h(K4), {
      open: s.value,
      modal: !1,
      dir: h(o).dir.value,
      "onUpdate:open": l[0] || (l[0] = (c) => {
        c || h(o).onMenuClose();
      })
    }, {
      default: C(() => [
        D(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), mj = /* @__PURE__ */ I({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = W1(), n = nk(), { forwardRef: o, currentElement: r } = ee(), { CollectionItem: i } = Yt({ key: "Menubar" }), s = R(!1), a = L(() => e.modelValue.value === n.value);
    return be(() => {
      n.triggerElement = r;
    }), (l, c) => (E(), T(h(Mf), {
      "as-child": "",
      focusable: !l.disabled,
      "tab-stop-id": h(n).value
    }, {
      default: C(() => [
        _(h(i), null, {
          default: C(() => [
            _(h(z1), { "as-child": "" }, {
              default: C(() => [
                _(h(ae), {
                  id: h(n).triggerId,
                  ref: h(o),
                  as: l.as,
                  type: l.as === "button" ? "button" : void 0,
                  role: "menuitem",
                  "aria-haspopup": "menu",
                  "aria-expanded": a.value,
                  "aria-controls": a.value ? h(n).contentId : void 0,
                  "data-highlighted": s.value ? "" : void 0,
                  "data-state": a.value ? "open" : "closed",
                  "data-disabled": l.disabled ? "" : void 0,
                  disabled: l.disabled,
                  "data-value": h(n).value,
                  onPointerdown: c[0] || (c[0] = (u) => {
                    !l.disabled && u.button === 0 && u.ctrlKey === !1 && (h(e).onMenuOpen(h(n).value), a.value || u.preventDefault());
                  }),
                  onPointerenter: c[1] || (c[1] = () => {
                    var d;
                    !!h(e).modelValue.value && !a.value && (h(e).onMenuOpen(h(n).value), (d = h(r)) == null || d.focus());
                  }),
                  onKeydown: c[2] || (c[2] = Sr((u) => {
                    l.disabled || (["Enter", " "].includes(u.key) && h(e).onMenuToggle(h(n).value), u.key === "ArrowDown" && h(e).onMenuOpen(h(n).value), ["Enter", " ", "ArrowDown"].includes(u.key) && (h(n).wasKeyboardTriggerOpenRef.value = !0, u.preventDefault()));
                  }, ["enter", "space", "arrow-down"])),
                  onFocus: c[3] || (c[3] = (u) => s.value = !0),
                  onBlur: c[4] || (c[4] = (u) => s.value = !1)
                }, {
                  default: C(() => [
                    D(l.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), gj = /* @__PURE__ */ I({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(G4), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vj = /* @__PURE__ */ I({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    ee();
    const i = W1(), s = nk();
    s.contentId || (s.contentId = St(void 0, "reka-menubar-content"));
    const { getItems: a } = Yt({ key: "Menubar" }), l = R(!1);
    function c(u) {
      const f = u.target.hasAttribute(
        "data-reka-menubar-subtrigger"
      ), m = (i.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === u.key;
      if (!m && f)
        return;
      let v = a().filter((x) => x.ref.dataset.disabled !== "").map((x) => x.ref.dataset.value);
      m && v.reverse();
      const y = v.indexOf(s.value);
      v = i.loop.value ? V4(v, y + 1) : v.slice(y + 1);
      const [w] = v;
      w && i.onMenuOpen(w);
    }
    return (u, d) => (E(), T(h(q4), j(h(r), {
      id: h(s).contentId,
      "data-reka-menubar-content": "",
      "aria-labelledby": h(s).triggerId,
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: d[0] || (d[0] = (f) => {
        var m;
        !!!h(i).modelValue.value && !l.value && ((m = h(s).triggerElement.value) == null || m.focus()), l.value = !1, f.preventDefault();
      }),
      onFocusOutside: d[1] || (d[1] = (f) => {
        const p = f.target;
        h(a)().filter((g) => g.ref.dataset.disabled !== "").some((g) => g.ref.contains(p)) && f.preventDefault();
      }),
      onInteractOutside: d[2] || (d[2] = (f) => {
        l.value = !0;
      }),
      onEntryFocus: d[3] || (d[3] = (f) => {
        h(s).wasKeyboardTriggerOpenRef.value || f.preventDefault();
      }),
      onKeydown: Sr(c, ["arrow-right", "arrow-left"])
    }), {
      default: C(() => [
        D(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), yj = /* @__PURE__ */ I({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, r = zr(e);
    return ee(), (i, s) => (E(), T(h(j1), _e(Me({ ...n, ...h(r) })), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bj = /* @__PURE__ */ I({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(J4), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wj = /* @__PURE__ */ I({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, r = zr(e);
    return ee(), (i, s) => (E(), T(h(Z4), _e(Me({ ...n, ...h(r) })), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), xj = /* @__PURE__ */ I({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(X4), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function _m(t, e = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(e, t));
}
const [Rn, Cj] = je("ScrollAreaRoot"), Sj = /* @__PURE__ */ I({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: {},
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t, { expose: e }) {
    const n = t, o = R(0), r = R(0), i = R(), s = R(), a = R(), l = R(), c = R(!1), u = R(!1), { type: d, dir: f, scrollHideDelay: p } = st(n), m = qo(f);
    function g() {
      var x;
      (x = i.value) == null || x.scrollTo({
        top: 0
      });
    }
    function v() {
      var x;
      (x = i.value) == null || x.scrollTo({
        top: 0,
        left: 0
      });
    }
    e({
      /** Viewport element within ScrollArea */
      viewport: i,
      /** Scroll viewport to top */
      scrollTop: g,
      /** Scroll viewport to top-left */
      scrollTopLeft: v
    });
    const { forwardRef: y, currentElement: w } = ee();
    return Cj({
      type: d,
      dir: m,
      scrollHideDelay: p,
      scrollArea: w,
      viewport: i,
      onViewportChange: (x) => {
        i.value = x || void 0;
      },
      content: s,
      onContentChange: (x) => {
        s.value = x;
      },
      scrollbarX: a,
      scrollbarXEnabled: c,
      scrollbarY: l,
      scrollbarYEnabled: u,
      onScrollbarXChange: (x) => {
        a.value = x || void 0;
      },
      onScrollbarYChange: (x) => {
        l.value = x || void 0;
      },
      onScrollbarXEnabledChange: (x) => {
        c.value = x;
      },
      onScrollbarYEnabledChange: (x) => {
        u.value = x;
      },
      onCornerWidthChange: (x) => {
        o.value = x;
      },
      onCornerHeightChange: (x) => {
        r.value = x;
      }
    }), (x, b) => (E(), T(h(ae), {
      ref: h(y),
      "as-child": n.asChild,
      as: x.as,
      dir: h(m),
      style: pt({
        position: "relative",
        // Pass corner sizes as CSS vars to reduce re-renders of context consumers
        "--reka-scroll-area-corner-width": `${o.value}px`,
        "--reka-scroll-area-corner-height": `${r.value}px`
      })
    }, {
      default: C(() => [
        D(x.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]));
  }
}), kj = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t, { expose: e }) {
    const n = t, { nonce: o } = st(n), r = j4(o), i = Rn(), s = R();
    be(() => {
      i.onViewportChange(s.value), i.onContentChange(l.value);
    }), e({
      viewportElement: s
    });
    const { forwardRef: a, currentElement: l } = ee();
    return (c, u) => (E(), W(me, null, [
      N("div", j({
        ref_key: "viewportElement",
        ref: s,
        "data-reka-scroll-area-viewport": "",
        style: {
          /**
           * We don't support `visible` because the intention is to have at least one scrollbar
           * if this component is used and `visible` will behave like `auto` in that case
           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
           *
           * We don't handle `auto` because the intention is for the native implementation
           * to be hidden if using this component. We just want to ensure the node is scrollable
           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
           * the browser from having to work out whether to render native scrollbars or not,
           * we tell it to with the intention of hiding them in CSS.
           */
          overflowX: h(i).scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: h(i).scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      }, c.$attrs, { tabindex: 0 }), [
        _(h(ae), {
          ref: h(a),
          style: pt({
            /**
             * When horizontal scrollbar is visible: this element should be at least
             * as wide as its children for size calculations to work correctly.
             *
             * When horizontal scrollbar is NOT visible: this element's width should
             * be constrained by the parent container to enable `text-overflow: ellipsis`
             */
            minWidth: h(i).scrollbarXEnabled.value ? "fit-content" : void 0
          }),
          "as-child": n.asChild,
          as: c.as
        }, {
          default: C(() => [
            D(c.$slots, "default")
          ]),
          _: 3
        }, 8, ["style", "as-child", "as"])
      ], 16),
      _(h(ae), {
        as: "style",
        nonce: h(r)
      }, {
        default: C(() => u[0] || (u[0] = [
          ue(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
        ])),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
});
function ok(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1])
      return e[0];
    const o = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + o * (n - t[0]);
  };
}
function $f(t) {
  const e = rk(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = (t.scrollbar.size - n) * e;
  return Math.max(o, 18);
}
function rk(t, e) {
  const n = t / e;
  return Number.isNaN(n) ? 0 : n;
}
function Ej(t, e = () => {
}) {
  let n = { left: t.scrollLeft, top: t.scrollTop }, o = 0;
  return function r() {
    const i = { left: t.scrollLeft, top: t.scrollTop }, s = n.left !== i.left, a = n.top !== i.top;
    (s || a) && e(), n = i, o = window.requestAnimationFrame(r);
  }(), () => window.cancelAnimationFrame(o);
}
function Mb(t, e, n = "ltr") {
  const o = $f(e), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, i = e.scrollbar.size - r, s = e.content - e.viewport, a = i - o, l = n === "ltr" ? [0, s] : [s * -1, 0], c = _m(
    t,
    l[0],
    l[1]
  );
  return ok([0, s], [0, a])(c);
}
function Dc(t) {
  return t ? Number.parseInt(t, 10) : 0;
}
function _j(t, e, n, o = "ltr") {
  const r = $f(n), i = r / 2, s = e || i, a = r - s, l = n.scrollbar.paddingStart + s, c = n.scrollbar.size - n.scrollbar.paddingEnd - a, u = n.content - n.viewport, d = o === "ltr" ? [0, u] : [u * -1, 0];
  return ok(
    [l, c],
    d
  )(t);
}
function Ib(t, e) {
  return t > 0 && t < e;
}
const ik = /* @__PURE__ */ I({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Rn(), i = Pf(), s = Lf(), { forwardRef: a, currentElement: l } = ee(), c = R(""), u = R();
    function d(y) {
      var w, x;
      if (u.value) {
        const b = y.clientX - ((w = u.value) == null ? void 0 : w.left), S = y.clientY - ((x = u.value) == null ? void 0 : x.top);
        o("onDragScroll", { x: b, y: S });
      }
    }
    function f(y) {
      y.button === 0 && (y.target.setPointerCapture(y.pointerId), u.value = l.value.getBoundingClientRect(), c.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", r.viewport && (r.viewport.value.style.scrollBehavior = "auto"), d(y));
    }
    function p(y) {
      d(y);
    }
    function m(y) {
      const w = y.target;
      w.hasPointerCapture(y.pointerId) && w.releasePointerCapture(y.pointerId), document.body.style.webkitUserSelect = c.value, r.viewport && (r.viewport.value.style.scrollBehavior = ""), u.value = void 0;
    }
    function g(y) {
      var S;
      const w = y.target, x = (S = l.value) == null ? void 0 : S.contains(w), b = i.sizes.value.content - i.sizes.value.viewport;
      x && i.handleWheelScroll(y, b);
    }
    be(() => {
      document.addEventListener("wheel", g, { passive: !1 });
    }), Nt(() => {
      document.removeEventListener("wheel", g);
    });
    function v() {
      var y, w, x, b, S;
      l.value && (n.isHorizontal ? i.handleSizeChange({
        content: ((y = r.viewport.value) == null ? void 0 : y.scrollWidth) ?? 0,
        viewport: ((w = r.viewport.value) == null ? void 0 : w.offsetWidth) ?? 0,
        scrollbar: {
          size: l.value.clientWidth ?? 0,
          paddingStart: Dc(getComputedStyle(l.value).paddingLeft),
          paddingEnd: Dc(getComputedStyle(l.value).paddingRight)
        }
      }) : i.handleSizeChange({
        content: ((x = r.viewport.value) == null ? void 0 : x.scrollHeight) ?? 0,
        viewport: ((b = r.viewport.value) == null ? void 0 : b.offsetHeight) ?? 0,
        scrollbar: {
          size: ((S = l.value) == null ? void 0 : S.clientHeight) ?? 0,
          paddingStart: Dc(getComputedStyle(l.value).paddingLeft),
          paddingEnd: Dc(getComputedStyle(l.value).paddingRight)
        }
      }));
    }
    return Ei(l, v), Ei(r.content, v), (y, w) => (E(), T(h(ae), {
      ref: h(a),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: h(s).as.value,
      "as-child": h(s).asChild.value,
      onPointerdown: f,
      onPointermove: p,
      onPointerup: m
    }, {
      default: C(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Aj = /* @__PURE__ */ I({
  __name: "ScrollAreaScrollbarX",
  setup(t) {
    const e = Rn(), n = Pf(), { forwardRef: o, currentElement: r } = ee();
    be(() => {
      r.value && e.onScrollbarXChange(r.value);
    });
    const i = L(() => n.sizes.value);
    return (s, a) => (E(), T(ik, {
      ref: h(o),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: pt({
        bottom: 0,
        left: h(e).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
        right: h(e).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
        "--reka-scroll-area-thumb-width": i.value ? `${h($f)(i.value)}px` : void 0
      }),
      onOnDragScroll: a[0] || (a[0] = (l) => h(n).onDragScroll(l.x))
    }, {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), Tj = /* @__PURE__ */ I({
  __name: "ScrollAreaScrollbarY",
  setup(t) {
    const e = Rn(), n = Pf(), { forwardRef: o, currentElement: r } = ee();
    be(() => {
      r.value && e.onScrollbarYChange(r.value);
    });
    const i = L(() => n.sizes.value);
    return (s, a) => (E(), T(ik, {
      ref: h(o),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: pt({
        top: 0,
        right: h(e).dir.value === "ltr" ? 0 : void 0,
        left: h(e).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--reka-scroll-area-corner-height)",
        "--reka-scroll-area-thumb-height": i.value ? `${h($f)(i.value)}px` : void 0
      }),
      onOnDragScroll: a[0] || (a[0] = (l) => h(n).onDragScroll(l.y))
    }, {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), [Pf, Oj] = je("ScrollAreaScrollbarVisible"), K1 = /* @__PURE__ */ I({
  __name: "ScrollAreaScrollbarVisible",
  setup(t) {
    const e = Rn(), n = Lf(), { forwardRef: o } = ee(), r = R({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }), i = L(() => {
      const y = rk(r.value.viewport, r.value.content);
      return y > 0 && y < 1;
    }), s = R(), a = R(0);
    function l(y, w) {
      if (p.value) {
        const x = e.viewport.value.scrollLeft + y.deltaY;
        e.viewport.value.scrollLeft = x, Ib(x, w) && y.preventDefault();
      } else {
        const x = e.viewport.value.scrollTop + y.deltaY;
        e.viewport.value.scrollTop = x, Ib(x, w) && y.preventDefault();
      }
    }
    function c(y, w) {
      p.value ? a.value = w.x : a.value = w.y;
    }
    function u(y) {
      a.value = 0;
    }
    function d(y) {
      r.value = y;
    }
    function f(y, w) {
      return _j(
        y,
        a.value,
        r.value,
        w
      );
    }
    const p = L(
      () => n.isHorizontal.value
    );
    function m(y) {
      p.value ? e.viewport.value.scrollLeft = f(
        y,
        e.dir.value
      ) : e.viewport.value.scrollTop = f(y);
    }
    function g() {
      if (p.value) {
        if (e.viewport.value && s.value) {
          const y = e.viewport.value.scrollLeft, w = Mb(
            y,
            r.value,
            e.dir.value
          );
          s.value.style.transform = `translate3d(${w}px, 0, 0)`;
        }
      } else if (e.viewport.value && s.value) {
        const y = e.viewport.value.scrollTop, w = Mb(y, r.value);
        s.value.style.transform = `translate3d(0, ${w}px, 0)`;
      }
    }
    function v(y) {
      s.value = y;
    }
    return Oj({
      sizes: r,
      hasThumb: i,
      handleWheelScroll: l,
      handleThumbDown: c,
      handleThumbUp: u,
      handleSizeChange: d,
      onThumbPositionChange: g,
      onThumbChange: v,
      onDragScroll: m
    }), (y, w) => p.value ? (E(), T(Aj, j({ key: 0 }, y.$attrs, { ref: h(o) }), {
      default: C(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 16)) : (E(), T(Tj, j({ key: 1 }, y.$attrs, { ref: h(o) }), {
      default: C(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sk = /* @__PURE__ */ I({
  __name: "ScrollAreaScrollbarAuto",
  props: {
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = Rn(), n = Lf(), { forwardRef: o } = ee(), r = R(!1), i = T4(() => {
      if (e.viewport.value) {
        const s = e.viewport.value.offsetWidth < e.viewport.value.scrollWidth, a = e.viewport.value.offsetHeight < e.viewport.value.scrollHeight;
        r.value = n.isHorizontal.value ? s : a;
      }
    }, 10);
    return be(() => i()), Ei(e.viewport, i), Ei(e.content, i), (s, a) => (E(), T(h(rn), {
      present: s.forceMount || r.value
    }, {
      default: C(() => [
        _(K1, j(s.$attrs, {
          ref: h(o),
          "data-state": r.value ? "visible" : "hidden"
        }), {
          default: C(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Mj = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: {
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = Rn(), { forwardRef: n } = ee();
    let o;
    const r = R(!1);
    function i() {
      window.clearTimeout(o), r.value = !0;
    }
    function s() {
      o = window.setTimeout(() => {
        r.value = !1;
      }, e.scrollHideDelay.value);
    }
    return be(() => {
      const a = e.scrollArea.value;
      a && (a.addEventListener("pointerenter", i), a.addEventListener("pointerleave", s));
    }), Nt(() => {
      const a = e.scrollArea.value;
      a && (window.clearTimeout(o), a.removeEventListener("pointerenter", i), a.removeEventListener("pointerleave", s));
    }), (a, l) => (E(), T(h(rn), {
      present: a.forceMount || r.value
    }, {
      default: C(() => [
        _(sk, j(a.$attrs, {
          ref: h(n),
          "data-state": r.value ? "visible" : "hidden"
        }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Ij = /* @__PURE__ */ I({
  __name: "ScrollAreaScrollbarScroll",
  props: {
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = Rn(), n = Lf(), { forwardRef: o } = ee(), { state: r, dispatch: i } = R4("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    Ve((a) => {
      if (r.value === "idle") {
        const l = window.setTimeout(
          () => i("HIDE"),
          e.scrollHideDelay.value
        );
        a(() => {
          window.clearTimeout(l);
        });
      }
    });
    const s = T4(() => i("SCROLL_END"), 100);
    return Ve((a) => {
      const l = e.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (l) {
        let u = l[c];
        const d = () => {
          const f = l[c];
          u !== f && (i("SCROLL"), s()), u = f;
        };
        l.addEventListener("scroll", d), a(() => {
          l.removeEventListener("scroll", d);
        });
      }
    }), (a, l) => (E(), T(h(rn), {
      present: a.forceMount || h(r) !== "hidden"
    }, {
      default: C(() => [
        _(K1, j(a.$attrs, { ref: h(o) }), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Lf, Rj] = je("ScrollAreaScrollbar"), $j = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(t) {
    const e = t, { forwardRef: n } = ee(), o = Rn(), r = L(() => e.orientation === "horizontal");
    le(
      r,
      () => {
        r.value ? o.onScrollbarXEnabledChange(!0) : o.onScrollbarYEnabledChange(!0);
      },
      { immediate: !0 }
    ), Nt(() => {
      o.onScrollbarXEnabledChange(!1), o.onScrollbarYEnabledChange(!1);
    });
    const { orientation: i, forceMount: s, asChild: a, as: l } = st(e);
    return Rj({
      orientation: i,
      forceMount: s,
      isHorizontal: r,
      as: l,
      asChild: a
    }), (c, u) => h(o).type.value === "hover" ? (E(), T(Mj, j({ key: 0 }, c.$attrs, {
      ref: h(n),
      "force-mount": h(s)
    }), {
      default: C(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : h(o).type.value === "scroll" ? (E(), T(Ij, j({ key: 1 }, c.$attrs, {
      ref: h(n),
      "force-mount": h(s)
    }), {
      default: C(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : h(o).type.value === "auto" ? (E(), T(sk, j({ key: 2 }, c.$attrs, {
      ref: h(n),
      "force-mount": h(s)
    }), {
      default: C(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : h(o).type.value === "always" ? (E(), T(K1, j({ key: 3 }, c.$attrs, {
      ref: h(n),
      "data-state": "visible"
    }), {
      default: C(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16)) : oe("", !0);
  }
}), Pj = /* @__PURE__ */ I({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = Rn(), o = Pf();
    function r(f) {
      const m = f.target.getBoundingClientRect(), g = f.clientX - m.left, v = f.clientY - m.top;
      o.handleThumbDown(f, { x: g, y: v });
    }
    function i(f) {
      o.handleThumbUp(f);
    }
    const { forwardRef: s, currentElement: a } = ee(), l = R(), c = L(() => n.viewport.value);
    function u() {
      if (!l.value) {
        const f = Ej(
          c.value,
          o.onThumbPositionChange
        );
        l.value = f, o.onThumbPositionChange();
      }
    }
    const d = L(() => o.sizes.value);
    return uV(d, () => {
      o.onThumbChange(a.value), c.value && (o.onThumbPositionChange(), c.value.addEventListener("scroll", u));
    }), Nt(() => {
      var f;
      c.value.removeEventListener("scroll", u), (f = n.viewport.value) == null || f.removeEventListener("scroll", u);
    }), (f, p) => (E(), T(h(ae), {
      ref: h(s),
      "data-state": h(o).hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--reka-scroll-area-thumb-width)",
        height: "var(--reka-scroll-area-thumb-height)"
      },
      "as-child": e.asChild,
      as: f.as,
      onPointerdown: r,
      onPointerup: i
    }, {
      default: C(() => [
        D(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "as-child", "as"]));
  }
}), Lj = /* @__PURE__ */ I({
  __name: "ScrollAreaCornerImpl",
  setup(t) {
    const e = Rn(), n = R(0), o = R(0), r = L(() => !!n.value && !!o.value);
    function i() {
      var l;
      const a = ((l = e.scrollbarX.value) == null ? void 0 : l.offsetHeight) || 0;
      e.onCornerHeightChange(a), o.value = a;
    }
    function s() {
      var l;
      const a = ((l = e.scrollbarY.value) == null ? void 0 : l.offsetWidth) || 0;
      e.onCornerWidthChange(a), n.value = a;
    }
    return Ei(e.scrollbarX.value, i), Ei(e.scrollbarY.value, s), le(() => e.scrollbarX.value, i), le(() => e.scrollbarY.value, s), (a, l) => {
      var c;
      return r.value ? (E(), T(h(ae), j({
        key: 0,
        style: {
          width: `${n.value}px`,
          height: `${o.value}px`,
          position: "absolute",
          right: h(e).dir.value === "ltr" ? 0 : void 0,
          left: h(e).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (c = a.$parent) == null ? void 0 : c.$props), {
        default: C(() => [
          D(a.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : oe("", !0);
    };
  }
}), Dj = /* @__PURE__ */ I({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n } = ee(), o = Rn(), r = L(
      () => !!o.scrollbarX.value && !!o.scrollbarY.value
    ), i = L(
      () => o.type.value !== "scroll" && r.value
    );
    return (s, a) => i.value ? (E(), T(Lj, j({ key: 0 }, e, { ref: h(n) }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : oe("", !0);
  }
}), Nj = /* @__PURE__ */ I({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(t) {
    const e = t, n = R();
    return le(() => e.value, (o, r) => {
      const i = window.HTMLSelectElement.prototype, a = Object.getOwnPropertyDescriptor(
        i,
        "value"
      ).set;
      if (o !== r && a && n.value) {
        const l = new Event("change", { bubbles: !0 });
        a.call(n.value, o), n.value.dispatchEvent(l);
      }
    }), (o, r) => (E(), T(h(Jl), { "as-child": "" }, {
      default: C(() => [
        N("select", j({
          ref_key: "selectElement",
          ref: n
        }, e), [
          D(o.$slots, "default")
        ], 16)
      ]),
      _: 3
    }));
  }
}), Bj = [" ", "Enter", "ArrowUp", "ArrowDown"], Fj = [" ", "Enter"], Ln = 10;
function Am(t, e, n) {
  return t === void 0 ? !1 : Array.isArray(t) ? t.some((o) => Tm(o, e, n)) : Tm(t, e, n);
}
function Tm(t, e, n) {
  return t === void 0 || e === void 0 ? !1 : typeof t == "string" ? t === e : typeof n == "function" ? n(t, e) : typeof n == "string" ? (t == null ? void 0 : t[n]) === (e == null ? void 0 : e[n]) : Os(t, e);
}
const zj = {
  key: 0,
  value: ""
}, [Di, ak] = je("SelectRoot"), Hj = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: { default: void 0 },
    by: {},
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { required: r, disabled: i, multiple: s, dir: a } = st(n), l = It(n, "modelValue", o, {
      defaultValue: n.defaultValue ?? (s.value ? [] : void 0),
      passive: n.modelValue === void 0,
      deep: !0
    }), c = It(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), u = R(), d = R(), f = R({
      x: 0,
      y: 0
    }), p = L(() => {
      var x;
      return s.value && Array.isArray(l.value) ? ((x = l.value) == null ? void 0 : x.length) === 0 : yl(l.value);
    });
    Yt({ isProvider: !0 });
    const m = qo(a), g = Tf(u), v = R(/* @__PURE__ */ new Set()), y = L(() => Array.from(v.value).map((x) => x.value).join(";"));
    function w(x) {
      if (s.value) {
        const b = Array.isArray(l.value) ? [...l.value] : [], S = b.findIndex((k) => Tm(k, x, n.by));
        S === -1 ? b.push(x) : b.splice(S, 1), l.value = [...b];
      } else
        l.value = x;
    }
    return ak({
      triggerElement: u,
      onTriggerChange: (x) => {
        u.value = x;
      },
      valueElement: d,
      onValueElementChange: (x) => {
        d.value = x;
      },
      contentId: "",
      modelValue: l,
      // @ts-expect-error Missing infer for AcceptableValue
      onValueChange: w,
      by: n.by,
      open: c,
      multiple: s,
      required: r,
      onOpenChange: (x) => {
        c.value = x;
      },
      dir: m,
      triggerPointerDownPosRef: f,
      disabled: i,
      isEmptyModelValue: p,
      optionsSet: v,
      onOptionAdd: (x) => v.value.add(x),
      onOptionRemove: (x) => v.value.delete(x)
    }), (x, b) => (E(), T(h(ec), null, {
      default: C(() => [
        D(x.$slots, "default", {
          modelValue: h(l),
          open: h(c)
        }),
        h(g) ? (E(), T(Nj, {
          key: y.value,
          "aria-hidden": "true",
          tabindex: "-1",
          multiple: h(s),
          required: h(r),
          name: x.name,
          autocomplete: x.autocomplete,
          disabled: h(i),
          value: h(l)
        }, {
          default: C(() => [
            h(yl)(h(l)) ? (E(), W("option", zj)) : oe("", !0),
            (E(!0), W(me, null, Oe(Array.from(v.value), (S) => (E(), W("option", j({
              key: S.value ?? "",
              ref_for: !0
            }, S), null, 16))), 128))
          ]),
          _: 1
        }, 8, ["multiple", "required", "name", "autocomplete", "disabled", "value"])) : oe("", !0)
      ]),
      _: 3
    }));
  }
}), Vj = /* @__PURE__ */ I({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = Di(), { forwardRef: o, currentElement: r } = ee(), i = L(() => {
      var f;
      return ((f = n.disabled) == null ? void 0 : f.value) || e.disabled;
    });
    n.contentId || (n.contentId = St(void 0, "reka-select-content")), be(() => {
      n.onTriggerChange(r.value);
    });
    const { getItems: s } = Yt(), { search: a, handleTypeaheadSearch: l, resetTypeahead: c } = F1();
    function u() {
      i.value || (n.onOpenChange(!0), c());
    }
    function d(f) {
      u(), n.triggerPointerDownPosRef.value = {
        x: Math.round(f.pageX),
        y: Math.round(f.pageY)
      };
    }
    return (f, p) => (E(), T(h(If), {
      "as-child": "",
      reference: f.reference
    }, {
      default: C(() => {
        var m, g, v, y;
        return [
          _(h(ae), {
            ref: h(o),
            role: "combobox",
            type: f.as === "button" ? "button" : void 0,
            "aria-controls": h(n).contentId,
            "aria-expanded": h(n).open.value || !1,
            "aria-required": (m = h(n).required) == null ? void 0 : m.value,
            "aria-autocomplete": "none",
            disabled: i.value,
            dir: (g = h(n)) == null ? void 0 : g.dir.value,
            "data-state": (v = h(n)) != null && v.open.value ? "open" : "closed",
            "data-disabled": i.value ? "" : void 0,
            "data-placeholder": (y = h(n).modelValue) != null && y.value ? void 0 : "",
            "as-child": f.asChild,
            as: f.as,
            onClick: p[0] || (p[0] = (w) => {
              var x;
              (x = w == null ? void 0 : w.currentTarget) == null || x.focus();
            }),
            onPointerdown: p[1] || (p[1] = (w) => {
              if (w.pointerType === "touch")
                return w.preventDefault();
              const x = w.target;
              x.hasPointerCapture(w.pointerId) && x.releasePointerCapture(w.pointerId), w.button === 0 && w.ctrlKey === !1 && (d(w), w.preventDefault());
            }),
            onPointerup: p[2] || (p[2] = mt(
              (w) => {
                w.pointerType === "touch" && d(w);
              },
              ["prevent"]
            )),
            onKeydown: p[3] || (p[3] = (w) => {
              const x = h(a) !== "";
              !(w.ctrlKey || w.altKey || w.metaKey) && w.key.length === 1 && x && w.key === " " || (h(l)(w.key, h(s)()), h(Bj).includes(w.key) && (u(), w.preventDefault()));
            })
          }, {
            default: C(() => [
              D(f.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }, 8, ["reference"]));
  }
}), Uj = /* @__PURE__ */ I({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Zl), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [G1, jj] = je("SelectItemAlignedPosition"), Wj = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(t, { emit: e }) {
    const n = t, o = e, { getItems: r } = Yt(), i = Di(), s = Ni(), a = R(!1), l = R(!0), c = R(), { forwardRef: u, currentElement: d } = ee(), { viewport: f, selectedItem: p, selectedItemText: m, focusSelectedItem: g } = s;
    function v() {
      if (i.triggerElement.value && i.valueElement.value && c.value && d.value && (f != null && f.value) && (p != null && p.value) && (m != null && m.value)) {
        const x = i.triggerElement.value.getBoundingClientRect(), b = d.value.getBoundingClientRect(), S = i.valueElement.value.getBoundingClientRect(), k = m.value.getBoundingClientRect();
        if (i.dir.value !== "rtl") {
          const qe = k.left - b.left, Ue = S.left - qe, Be = x.left - Ue, rt = x.width + Be, yn = Math.max(rt, b.width), Jt = window.innerWidth - Ln, bn = _m(Ue, Ln, Math.max(Ln, Jt - yn));
          c.value.style.minWidth = `${rt}px`, c.value.style.left = `${bn}px`;
        } else {
          const qe = b.right - k.right, Ue = window.innerWidth - S.right - qe, Be = window.innerWidth - x.right - Ue, rt = x.width + Be, yn = Math.max(rt, b.width), Jt = window.innerWidth - Ln, bn = _m(
            Ue,
            Ln,
            Math.max(Ln, Jt - yn)
          );
          c.value.style.minWidth = `${rt}px`, c.value.style.right = `${bn}px`;
        }
        const A = r().map((qe) => qe.ref), $ = window.innerHeight - Ln * 2, O = f.value.scrollHeight, M = window.getComputedStyle(d.value), P = Number.parseInt(
          M.borderTopWidth,
          10
        ), F = Number.parseInt(M.paddingTop, 10), J = Number.parseInt(
          M.borderBottomWidth,
          10
        ), Q = Number.parseInt(
          M.paddingBottom,
          10
        ), G = P + F + O + Q + J, V = Math.min(
          p.value.offsetHeight * 5,
          G
        ), B = window.getComputedStyle(f.value), q = Number.parseInt(B.paddingTop, 10), z = Number.parseInt(
          B.paddingBottom,
          10
        ), H = x.top + x.height / 2 - Ln, Z = $ - H, ne = p.value.offsetHeight / 2, he = p.value.offsetTop + ne, we = P + F + he, Ae = G - we;
        if (we <= H) {
          const qe = p.value === A[A.length - 1];
          c.value.style.bottom = "0px";
          const Ue = d.value.clientHeight - f.value.offsetTop - f.value.offsetHeight, Be = Math.max(
            Z,
            ne + (qe ? z : 0) + Ue + J
          ), rt = we + Be;
          c.value.style.height = `${rt}px`;
        } else {
          const qe = p.value === A[0];
          c.value.style.top = "0px";
          const Be = Math.max(
            H,
            P + f.value.offsetTop + (qe ? q : 0) + ne
          ) + Ae;
          c.value.style.height = `${Be}px`, f.value.scrollTop = we - H + f.value.offsetTop;
        }
        c.value.style.margin = `${Ln}px 0`, c.value.style.minHeight = `${V}px`, c.value.style.maxHeight = `${$}px`, o("placed"), requestAnimationFrame(() => a.value = !0);
      }
    }
    const y = R("");
    be(async () => {
      await ze(), v(), d.value && (y.value = window.getComputedStyle(d.value).zIndex);
    });
    function w(x) {
      x && l.value === !0 && (v(), g == null || g(), l.value = !1);
    }
    return Ei(i.triggerElement, () => {
      v();
    }), jj({
      contentWrapper: c,
      shouldExpandOnScrollRef: a,
      onScrollButtonChange: w
    }), (x, b) => (E(), W("div", {
      ref_key: "contentWrapperElement",
      ref: c,
      style: pt({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: y.value
      })
    }, [
      _(h(ae), j({
        ref: h(u),
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...x.$attrs, ...n }), {
        default: C(() => [
          D(x.$slots, "default")
        ]),
        _: 3
      }, 16)
    ], 4));
  }
}), Kj = /* @__PURE__ */ I({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: Ln },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const n = vt(t);
    return (o, r) => (E(), T(h(Rf), j(h(n), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-select-content-available-width": "var(--reka-popper-available-width)",
      "--reka-select-content-available-height": "var(--reka-popper-available-height)",
      "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Gj = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [Ni, lk] = je("SelectContent"), qj = /* @__PURE__ */ I({
  __name: "SelectContentImpl",
  props: {
    position: { default: "item-aligned" },
    bodyLock: { type: Boolean, default: !0 },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Di();
    H1(), Af(n.bodyLock);
    const { CollectionSlot: i, getItems: s } = Yt(), a = R();
    _f(a);
    const { search: l, handleTypeaheadSearch: c } = F1(), u = R(), d = R(), f = R(), p = R(!1), m = R(!1), g = R(!1);
    function v() {
      d.value && a.value && xm([d.value, a.value]);
    }
    le(p, () => {
      v();
    });
    const { onOpenChange: y, triggerPointerDownPosRef: w } = r;
    Ve((k) => {
      if (!a.value)
        return;
      let A = { x: 0, y: 0 };
      const $ = (M) => {
        var P, F;
        A = {
          x: Math.abs(
            Math.round(M.pageX) - (((P = w.value) == null ? void 0 : P.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(M.pageY) - (((F = w.value) == null ? void 0 : F.y) ?? 0)
          )
        };
      }, O = (M) => {
        var P;
        M.pointerType !== "touch" && (A.x <= 10 && A.y <= 10 ? M.preventDefault() : (P = a.value) != null && P.contains(M.target) || y(!1), document.removeEventListener("pointermove", $), w.value = null);
      };
      w.value !== null && (document.addEventListener("pointermove", $), document.addEventListener("pointerup", O, {
        capture: !0,
        once: !0
      })), k(() => {
        document.removeEventListener("pointermove", $), document.removeEventListener("pointerup", O, {
          capture: !0
        });
      });
    });
    function x(k) {
      const A = k.ctrlKey || k.altKey || k.metaKey;
      if (k.key === "Tab" && k.preventDefault(), !A && k.key.length === 1 && c(k.key, s()), ["ArrowUp", "ArrowDown", "Home", "End"].includes(k.key)) {
        let O = [...s().map((M) => M.ref)];
        if (["ArrowUp", "End"].includes(k.key) && (O = O.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(k.key)) {
          const M = k.target, P = O.indexOf(M);
          O = O.slice(P + 1);
        }
        setTimeout(() => xm(O)), k.preventDefault();
      }
    }
    const b = L(() => n.position === "popper" ? n : {}), S = vt(b.value);
    return lk({
      content: a,
      viewport: u,
      onViewportChange: (k) => {
        u.value = k;
      },
      itemRefCallback: (k, A, $) => {
        const O = !m.value && !$, M = Am(r.modelValue.value, A, r.by);
        if (r.multiple.value) {
          if (g.value)
            return;
          (M || O) && (d.value = k, M && (g.value = !0));
        } else
          (M || O) && (d.value = k);
        O && (m.value = !0);
      },
      selectedItem: d,
      selectedItemText: f,
      onItemLeave: () => {
        var k;
        (k = a.value) == null || k.focus();
      },
      itemTextRefCallback: (k, A, $) => {
        const O = !m.value && !$;
        (Am(r.modelValue.value, A, r.by) || O) && (f.value = k);
      },
      focusSelectedItem: v,
      position: n.position,
      isPositioned: p,
      searchRef: l
    }), (k, A) => (E(), T(h(i), null, {
      default: C(() => [
        _(h(Ef), {
          "as-child": "",
          onMountAutoFocus: A[6] || (A[6] = mt(() => {
          }, ["prevent"])),
          onUnmountAutoFocus: A[7] || (A[7] = ($) => {
            var O;
            o("closeAutoFocus", $), !$.defaultPrevented && ((O = h(r).triggerElement.value) == null || O.focus({ preventScroll: !0 }), $.preventDefault());
          })
        }, {
          default: C(() => [
            _(h(Ql), {
              "as-child": "",
              "disable-outside-pointer-events": "",
              onFocusOutside: A[2] || (A[2] = mt(() => {
              }, ["prevent"])),
              onDismiss: A[3] || (A[3] = ($) => h(r).onOpenChange(!1)),
              onEscapeKeyDown: A[4] || (A[4] = ($) => o("escapeKeyDown", $)),
              onPointerDownOutside: A[5] || (A[5] = ($) => o("pointerDownOutside", $))
            }, {
              default: C(() => [
                (E(), T(An(
                  k.position === "popper" ? Kj : Wj
                ), j({ ...k.$attrs, ...h(S) }, {
                  id: h(r).contentId,
                  ref: ($) => {
                    a.value = h(In)($);
                  },
                  role: "listbox",
                  "data-state": h(r).open.value ? "open" : "closed",
                  dir: h(r).dir.value,
                  style: {
                    // flex layout so we can place the scroll buttons properly
                    display: "flex",
                    flexDirection: "column",
                    // reset the outline by default as the content MAY get focused
                    outline: "none"
                  },
                  onContextmenu: A[0] || (A[0] = mt(() => {
                  }, ["prevent"])),
                  onPlaced: A[1] || (A[1] = ($) => p.value = !0),
                  onKeydown: x
                }), {
                  default: C(() => [
                    D(k.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["id", "data-state", "dir", "onKeydown"]))
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), Yj = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(t) {
    return ak(t.context), lk(Gj), (n, o) => D(n.$slots, "default");
  }
}), Jj = { key: 1 }, Xj = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, r = Ie(n, e), i = Di(), s = R();
    be(() => {
      s.value = new DocumentFragment();
    });
    const a = R(), l = L(() => n.forceMount || i.open.value);
    return (c, u) => {
      var d;
      return l.value ? (E(), T(h(rn), {
        key: 0,
        ref_key: "presenceRef",
        ref: a,
        present: !0
      }, {
        default: C(() => [
          _(qj, _e(Me({ ...h(r), ...c.$attrs })), {
            default: C(() => [
              D(c.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 512)) : !((d = a.value) != null && d.present) && s.value ? (E(), W("div", Jj, [
        (E(), T(qd, { to: s.value }, [
          _(Yj, { context: h(i) }, {
            default: C(() => [
              D(c.$slots, "default")
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"]))
      ])) : oe("", !0);
    };
  }
}), [ck, Zj] = je("SelectItem"), Qj = /* @__PURE__ */ I({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = e, { disabled: r } = st(n), i = Di(), s = Ni(), { forwardRef: a, currentElement: l } = ee(), { CollectionItem: c } = Yt(), u = L(() => {
      var b;
      return Am((b = i.modelValue) == null ? void 0 : b.value, n.value, i.by);
    }), d = R(!1), f = R(n.textValue ?? ""), p = St(void 0, "reka-select-item-text"), m = "select.select";
    async function g(b) {
      if (b.defaultPrevented)
        return;
      const S = { originalEvent: b, value: n.value };
      L1(m, v, S);
    }
    async function v(b) {
      await ze(), o("select", b), !b.defaultPrevented && (r.value || (i.onValueChange(n.value), i.multiple.value || i.onOpenChange(!1)));
    }
    async function y(b) {
      var S;
      await ze(), !b.defaultPrevented && (r.value ? (S = s.onItemLeave) == null || S.call(s) : b.currentTarget.focus({ preventScroll: !0 }));
    }
    async function w(b) {
      var S;
      await ze(), !b.defaultPrevented && b.currentTarget === gt() && ((S = s.onItemLeave) == null || S.call(s));
    }
    async function x(b) {
      var k;
      await ze(), !(b.defaultPrevented || ((k = s.searchRef) == null ? void 0 : k.value) !== "" && b.key === " ") && (Fj.includes(b.key) && g(b), b.key === " " && b.preventDefault());
    }
    if (n.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return be(() => {
      l.value && s.itemRefCallback(
        l.value,
        n.value,
        n.disabled
      );
    }), Zj({
      value: n.value,
      disabled: r,
      textId: p,
      isSelected: u,
      onItemTextChange: (b) => {
        f.value = ((f.value || (b == null ? void 0 : b.textContent)) ?? "").trim();
      }
    }), (b, S) => (E(), T(h(c), {
      value: { textValue: f.value }
    }, {
      default: C(() => [
        _(h(ae), {
          ref: h(a),
          role: "option",
          "aria-labelledby": h(p),
          "data-highlighted": d.value ? "" : void 0,
          "aria-selected": u.value,
          "data-state": u.value ? "checked" : "unchecked",
          "aria-disabled": h(r) || void 0,
          "data-disabled": h(r) ? "" : void 0,
          tabindex: h(r) ? void 0 : -1,
          as: b.as,
          "as-child": b.asChild,
          onFocus: S[0] || (S[0] = (k) => d.value = !0),
          onBlur: S[1] || (S[1] = (k) => d.value = !1),
          onPointerup: g,
          onPointerdown: S[2] || (S[2] = (k) => {
            k.currentTarget.focus({ preventScroll: !0 });
          }),
          onTouchend: S[3] || (S[3] = mt(() => {
          }, ["prevent", "stop"])),
          onPointermove: y,
          onPointerleave: w,
          onKeydown: x
        }, {
          default: C(() => [
            D(b.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"])
      ]),
      _: 3
    }, 8, ["value"]));
  }
}), eW = /* @__PURE__ */ I({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, n = ck();
    return (o, r) => h(n).isSelected.value ? (E(), T(h(ae), j({
      key: 0,
      "aria-hidden": "true"
    }, e), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16)) : oe("", !0);
  }
}), tW = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, n = Di(), o = Ni(), r = ck(), { forwardRef: i, currentElement: s } = ee(), a = L(() => {
      var l, c;
      return {
        value: r.value,
        disabled: r.disabled.value,
        textContent: ((l = s.value) == null ? void 0 : l.textContent) ?? ((c = r.value) == null ? void 0 : c.toString()) ?? ""
      };
    });
    return be(() => {
      s.value && (r.onItemTextChange(s.value), o.itemTextRefCallback(
        s.value,
        r.value,
        r.disabled.value
      ), n.onOptionAdd(a.value));
    }), mo(() => {
      n.onOptionRemove(a.value);
    }), (l, c) => (E(), T(h(ae), j({
      id: h(r).textId,
      ref: h(i)
    }, { ...e, ...l.$attrs }), {
      default: C(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), nW = /* @__PURE__ */ I({
  __name: "SelectViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { nonce: n } = st(e), o = j4(n), r = Ni(), i = r.position === "item-aligned" ? G1() : void 0, { forwardRef: s, currentElement: a } = ee();
    be(() => {
      r == null || r.onViewportChange(a.value);
    });
    const l = R(0);
    function c(u) {
      const d = u.currentTarget, { shouldExpandOnScrollRef: f, contentWrapper: p } = i ?? {};
      if (f != null && f.value && (p != null && p.value)) {
        const m = Math.abs(l.value - d.scrollTop);
        if (m > 0) {
          const g = window.innerHeight - Ln * 2, v = Number.parseFloat(
            p.value.style.minHeight
          ), y = Number.parseFloat(p.value.style.height), w = Math.max(v, y);
          if (w < g) {
            const x = w + m, b = Math.min(g, x), S = x - b;
            p.value.style.height = `${b}px`, p.value.style.bottom === "0px" && (d.scrollTop = S > 0 ? S : 0, p.value.style.justifyContent = "flex-end");
          }
        }
      }
      l.value = d.scrollTop;
    }
    return (u, d) => (E(), W(me, null, [
      _(h(ae), j({
        ref: h(s),
        "data-reka-select-viewport": "",
        role: "presentation"
      }, { ...u.$attrs, ...e }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "hidden auto"
        },
        onScroll: c
      }), {
        default: C(() => [
          D(u.$slots, "default")
        ]),
        _: 3
      }, 16),
      _(h(ae), {
        as: "style",
        nonce: h(o)
      }, {
        default: C(() => d[0] || (d[0] = [
          ue(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")
        ])),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
}), uk = /* @__PURE__ */ I({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(t, { emit: e }) {
    const n = e, { getItems: o } = Yt(), r = Ni(), i = R(null);
    function s() {
      i.value !== null && (window.clearInterval(i.value), i.value = null);
    }
    Ve(() => {
      const c = o().map((u) => u.ref).find(
        (u) => u === gt()
      );
      c == null || c.scrollIntoView({ block: "nearest" });
    });
    function a() {
      i.value === null && (i.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function l() {
      var c;
      (c = r.onItemLeave) == null || c.call(r), i.value === null && (i.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return mo(() => s()), (c, u) => {
      var d;
      return E(), T(h(ae), j({
        "aria-hidden": "true",
        style: {
          flexShrink: 0
        }
      }, (d = c.$parent) == null ? void 0 : d.$props, {
        onPointerdown: a,
        onPointermove: l,
        onPointerleave: u[0] || (u[0] = () => {
          s();
        })
      }), {
        default: C(() => [
          D(c.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
}), oW = /* @__PURE__ */ I({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Ni(), n = e.position === "item-aligned" ? G1() : void 0, { forwardRef: o, currentElement: r } = ee(), i = R(!1);
    return Ve((s) => {
      var a, l;
      if ((a = e.viewport) != null && a.value && ((l = e.isPositioned) != null && l.value)) {
        let c = function() {
          i.value = u.scrollTop > 0;
        };
        const u = e.viewport.value;
        c(), u.addEventListener("scroll", c), s(() => u.removeEventListener("scroll", c));
      }
    }), le(r, () => {
      r.value && (n == null || n.onScrollButtonChange(r.value));
    }), (s, a) => i.value ? (E(), T(uk, {
      key: 0,
      ref: h(o),
      onAutoScroll: a[0] || (a[0] = () => {
        const { viewport: l, selectedItem: c } = h(e);
        l != null && l.value && (c != null && c.value) && (l.value.scrollTop = l.value.scrollTop - c.value.offsetHeight);
      })
    }, {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 512)) : oe("", !0);
  }
}), rW = /* @__PURE__ */ I({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Ni(), n = e.position === "item-aligned" ? G1() : void 0, { forwardRef: o, currentElement: r } = ee(), i = R(!1);
    return Ve((s) => {
      var a, l;
      if ((a = e.viewport) != null && a.value && ((l = e.isPositioned) != null && l.value)) {
        let c = function() {
          const d = u.scrollHeight - u.clientHeight;
          i.value = Math.ceil(u.scrollTop) < d;
        };
        const u = e.viewport.value;
        c(), u.addEventListener("scroll", c), s(() => u.removeEventListener("scroll", c));
      }
    }), le(r, () => {
      r.value && (n == null || n.onScrollButtonChange(r.value));
    }), (s, a) => i.value ? (E(), T(uk, {
      key: 0,
      ref: h(o),
      onAutoScroll: a[0] || (a[0] = () => {
        const { viewport: l, selectedItem: c } = h(e);
        l != null && l.value && (c != null && c.value) && (l.value.scrollTop = l.value.scrollTop + c.value.offsetHeight);
      })
    }, {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 512)) : oe("", !0);
  }
}), iW = /* @__PURE__ */ I({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, { forwardRef: n, currentElement: o } = ee(), r = Di();
    be(() => {
      r.valueElement = o;
    });
    const i = L(() => {
      var u;
      let a = [];
      const l = Array.from(r.optionsSet.value), c = (d) => l.find((f) => f.value === d);
      return Array.isArray(r.modelValue.value) ? a = r.modelValue.value.map((d) => {
        var f;
        return ((f = c(d)) == null ? void 0 : f.textContent) ?? "";
      }) : a = [((u = c(r.modelValue.value)) == null ? void 0 : u.textContent) ?? ""], a.filter(Boolean);
    }), s = L(() => i.value.length ? i.value.join(", ") : e.placeholder);
    return (a, l) => (E(), T(h(ae), {
      ref: h(n),
      as: a.as,
      "as-child": a.asChild,
      style: { pointerEvents: "none" },
      "data-placeholder": i.value.length ? void 0 : e.placeholder
    }, {
      default: C(() => [
        D(a.$slots, "default", {
          selectedLabel: i.value,
          modelValue: h(r).modelValue.value
        }, () => [
          ue(Y(s.value), 1)
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-placeholder"]));
  }
}), sW = /* @__PURE__ */ I({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    return (e, n) => (E(), T(h(ae), {
      "aria-hidden": "true",
      as: e.as,
      "as-child": e.asChild
    }, {
      default: C(() => [
        D(e.$slots, "default", {}, () => [
          n[0] || (n[0] = ue("▼"))
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), aW = /* @__PURE__ */ I({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = ["horizontal", "vertical"];
    function o(a) {
      return n.includes(a);
    }
    const r = L(
      () => o(e.orientation) ? e.orientation : "horizontal"
    ), i = L(
      () => r.value === "vertical" ? e.orientation : void 0
    ), s = L(
      () => e.decorative ? { role: "none" } : { "aria-orientation": i.value, role: "separator" }
    );
    return (a, l) => (E(), T(h(ae), j({
      as: a.as,
      "as-child": a.asChild,
      "data-orientation": r.value
    }, s.value), {
      default: C(() => [
        D(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "data-orientation"]));
  }
}), lW = /* @__PURE__ */ I({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(aW, _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
let Om = null, li = null;
function cW(t, e) {
  if (e) {
    const n = (e & vk) !== 0, o = (e & yk) !== 0, r = (e & bk) !== 0, i = (e & wk) !== 0;
    if (n)
      return r ? "se-resize" : i ? "ne-resize" : "e-resize";
    if (o)
      return r ? "sw-resize" : i ? "nw-resize" : "w-resize";
    if (r)
      return "s-resize";
    if (i)
      return "n-resize";
  }
  switch (t) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function dk() {
  li !== null && (document.head.removeChild(li), Om = null, li = null);
}
function Up(t, e) {
  const n = cW(t, e);
  Om !== n && (Om = n, li === null && (li = document.createElement("style"), document.head.appendChild(li)), li.innerHTML = `*{cursor: ${n}!important;}`);
}
function uW({
  defaultSize: t,
  dragState: e,
  layout: n,
  panelData: o,
  panelIndex: r,
  precision: i = 3
}) {
  const s = n[r];
  let a;
  return s == null ? a = t !== void 0 ? t.toPrecision(i) : "1" : o.length === 1 ? a = "1" : a = s.toPrecision(i), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: e !== null ? "none" : void 0
  };
}
function fk(t) {
  return t.type === "keydown";
}
function pk(t) {
  return t.type.startsWith("mouse");
}
function hk(t) {
  return t.type.startsWith("touch");
}
function Df(t) {
  if (pk(t))
    return {
      x: t.clientX,
      y: t.clientY
    };
  if (hk(t)) {
    const e = t.touches[0];
    if (e && e.clientX && e.clientY)
      return {
        x: e.clientX,
        y: e.clientY
      };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function mk(t, e) {
  const n = t === "horizontal", { x: o, y: r } = Df(e);
  return n ? o : r;
}
function dW(t, e, n) {
  return t.x < e.x + e.width && t.x + t.width > e.x && t.y < e.y + e.height && t.y + t.height > e.y;
}
function Ee(t, e = "Assertion failed!") {
  if (!t)
    throw console.error(e), new Error(e);
}
function fW(t, e) {
  if (t === e)
    throw new Error("Cannot compare node with itself");
  const n = {
    a: Pb(t),
    b: Pb(e)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    t = n.a.pop(), e = n.b.pop(), o = t;
  Ee(o);
  const r = {
    a: $b(Rb(n.a)),
    b: $b(Rb(n.b))
  };
  if (r.a === r.b) {
    const i = o.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let a = i.length;
    for (; a--; ) {
      const l = i[a];
      if (l === s.a)
        return 1;
      if (l === s.b)
        return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const pW = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function hW(t) {
  const e = getComputedStyle(gk(t)).display;
  return e === "flex" || e === "inline-flex";
}
function mW(t) {
  const e = getComputedStyle(t);
  return !!(e.position === "fixed" || e.zIndex !== "auto" && (e.position !== "static" || hW(t)) || +e.opacity < 1 || "transform" in e && e.transform !== "none" || "webkitTransform" in e && e.webkitTransform !== "none" || "mixBlendMode" in e && e.mixBlendMode !== "normal" || "filter" in e && e.filter !== "none" || "webkitFilter" in e && e.webkitFilter !== "none" || "isolation" in e && e.isolation === "isolate" || pW.test(e.willChange) || e.webkitOverflowScrolling === "touch");
}
function Rb(t) {
  let e = t.length;
  for (; e--; ) {
    const n = t[e];
    if (Ee(n), mW(n))
      return n;
  }
  return null;
}
function $b(t) {
  return t && Number(getComputedStyle(t).zIndex) || 0;
}
function Pb(t) {
  const e = [];
  for (; t; )
    e.push(t), t = gk(t);
  return e;
}
function gk(t) {
  var e;
  return t.parentNode instanceof DocumentFragment && ((e = t.parentNode) == null ? void 0 : e.host) || t.parentNode;
}
const vk = 1, yk = 2, bk = 4, wk = 8;
function gW() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const vW = gW() === "coarse", Or = [];
let Nf = !1;
const ur = /* @__PURE__ */ new Map(), Bf = /* @__PURE__ */ new Map(), wl = /* @__PURE__ */ new Set();
function yW(t, e, n, o, r) {
  const { ownerDocument: i } = e, s = {
    direction: n,
    element: e,
    hitAreaMargins: o,
    setResizeHandlerState: r
  }, a = ur.get(i) ?? 0;
  return ur.set(i, a + 1), wl.add(s), nd(), function() {
    Bf.delete(t), wl.delete(s);
    const c = ur.get(i) ?? 1;
    ur.set(i, c - 1), nd(), dk(), c === 1 && ur.delete(i);
  };
}
function Nc(t) {
  const { target: e } = t, { x: n, y: o } = Df(t);
  Nf = !0, q1({ target: e, x: n, y: o }), nd(), Or.length > 0 && (Y1("down", t), t.preventDefault());
}
function er(t) {
  const { x: e, y: n } = Df(t);
  if (!Nf) {
    const { target: o } = t;
    q1({ target: o, x: e, y: n });
  }
  Y1("move", t), xk(), Or.length > 0 && t.preventDefault();
}
function tr(t) {
  const { target: e } = t, { x: n, y: o } = Df(t);
  Bf.clear(), Nf = !1, Or.length > 0 && t.preventDefault(), Y1("up", t), q1({ target: e, x: n, y: o }), xk(), nd();
}
function q1({
  target: t,
  x: e,
  y: n
}) {
  Or.splice(0);
  let o = null;
  t instanceof HTMLElement && (o = t), wl.forEach((r) => {
    const { element: i, hitAreaMargins: s } = r, a = i.getBoundingClientRect(), { bottom: l, left: c, right: u, top: d } = a, f = vW ? s.coarse : s.fine;
    if (e >= c - f && e <= u + f && n >= d - f && n <= l + f) {
      if (o !== null && i !== o && !i.contains(o) && !o.contains(i) && fW(o, i) > 0) {
        let m = o, g = !1;
        for (; m && !m.contains(i); ) {
          if (dW(
            m.getBoundingClientRect(),
            a
          )) {
            g = !0;
            break;
          }
          m = m.parentElement;
        }
        if (g)
          return;
      }
      Or.push(r);
    }
  });
}
function jp(t, e) {
  Bf.set(t, e);
}
function xk() {
  let t = !1, e = !1;
  Or.forEach((o) => {
    const { direction: r } = o;
    r.value === "horizontal" ? t = !0 : e = !0;
  });
  let n = 0;
  Bf.forEach((o) => {
    n |= o;
  }), t && e ? Up("intersection", n) : t ? Up("horizontal", n) : e ? Up("vertical", n) : dk();
}
function nd() {
  ur.forEach((t, e) => {
    const { body: n } = e;
    n.removeEventListener("contextmenu", tr), n.removeEventListener("mousedown", Nc), n.removeEventListener("mouseleave", er), n.removeEventListener("mousemove", er), n.removeEventListener("touchmove", er), n.removeEventListener("touchstart", Nc);
  }), window.removeEventListener("mouseup", tr), window.removeEventListener("touchcancel", tr), window.removeEventListener("touchend", tr), wl.size > 0 && (Nf ? (Or.length > 0 && ur.forEach((t, e) => {
    const { body: n } = e;
    t > 0 && (n.addEventListener("contextmenu", tr), n.addEventListener("mouseleave", er), n.addEventListener("mousemove", er), n.addEventListener("touchmove", er, {
      passive: !1
    }));
  }), window.addEventListener("mouseup", tr), window.addEventListener("touchcancel", tr), window.addEventListener("touchend", tr)) : ur.forEach((t, e) => {
    const { body: n } = e;
    t > 0 && (n.addEventListener("mousedown", Nc), n.addEventListener("mousemove", er), n.addEventListener("touchmove", er, {
      passive: !1
    }), n.addEventListener("touchstart", Nc));
  }));
}
function Y1(t, e) {
  wl.forEach((n) => {
    const { setResizeHandlerState: o } = n, r = Or.includes(n);
    o(t, r, e);
  });
}
const J1 = 10;
function xl(t, e, n = J1) {
  t = Number.parseFloat(t.toFixed(n)), e = Number.parseFloat(e.toFixed(n));
  const o = t - e;
  return o === 0 ? 0 : o > 0 ? 1 : -1;
}
function an(t, e, n) {
  return xl(t, e, n) === 0;
}
function as({
  panelConstraints: t,
  panelIndex: e,
  size: n
}) {
  const o = t[e];
  Ee(o != null);
  const { collapsedSize: r = 0, collapsible: i, maxSize: s = 100, minSize: a = 0 } = o;
  if (xl(n, a) < 0)
    if (i) {
      const l = (r + a) / 2;
      xl(n, l) < 0 ? n = r : n = a;
    } else
      n = a;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(J1)), n;
}
function Bc(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Ma({
  delta: t,
  layout: e,
  panelConstraints: n,
  pivotIndices: o,
  trigger: r
}) {
  if (an(t, 0))
    return e;
  const i = [...e], [s, a] = o;
  Ee(s != null), Ee(a != null);
  let l = 0;
  if (r === "keyboard") {
    {
      const u = t < 0 ? a : s, d = n[u];
      if (Ee(d), d.collapsible) {
        const f = e[u];
        Ee(f != null);
        const p = n[u];
        Ee(p);
        const { collapsedSize: m = 0, minSize: g = 0 } = p;
        if (an(f, m)) {
          const v = g - f;
          xl(v, Math.abs(t)) > 0 && (t = t < 0 ? 0 - v : v);
        }
      }
    }
    {
      const u = t < 0 ? s : a, d = n[u];
      Ee(d);
      const { collapsible: f } = d;
      if (f) {
        const p = e[u];
        Ee(p != null);
        const m = n[u];
        Ee(m);
        const { collapsedSize: g = 0, minSize: v = 0 } = m;
        if (an(p, v)) {
          const y = p - g;
          xl(y, Math.abs(t)) > 0 && (t = t < 0 ? 0 - y : y);
        }
      }
    }
  }
  {
    const u = t < 0 ? 1 : -1;
    let d = t < 0 ? a : s, f = 0;
    for (; ; ) {
      const m = e[d];
      Ee(m != null);
      const v = as({
        panelConstraints: n,
        panelIndex: d,
        size: 100
      }) - m;
      if (f += v, d += u, d < 0 || d >= n.length)
        break;
    }
    const p = Math.min(Math.abs(t), Math.abs(f));
    t = t < 0 ? 0 - p : p;
  }
  {
    let d = t < 0 ? s : a;
    for (; d >= 0 && d < n.length; ) {
      const f = Math.abs(t) - Math.abs(l), p = e[d];
      Ee(p != null);
      const m = p - f, g = as({
        panelConstraints: n,
        panelIndex: d,
        size: m
      });
      if (!an(p, g) && (l += p - g, i[d] = g, l.toPrecision(3).localeCompare(Math.abs(t).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      t < 0 ? d-- : d++;
    }
  }
  if (an(l, 0))
    return e;
  {
    const u = t < 0 ? a : s, d = e[u];
    Ee(d != null);
    const f = d + l, p = as({
      panelConstraints: n,
      panelIndex: u,
      size: f
    });
    if (i[u] = p, !an(p, f)) {
      let m = f - p, v = t < 0 ? a : s;
      for (; v >= 0 && v < n.length; ) {
        const y = i[v];
        Ee(y != null);
        const w = y + m, x = as({
          panelConstraints: n,
          panelIndex: v,
          size: w
        });
        if (an(y, x) || (m -= x - y, i[v] = x), an(m, 0))
          break;
        t > 0 ? v-- : v++;
      }
    }
  }
  const c = i.reduce((u, d) => d + u, 0);
  return an(c, 100) ? i : e;
}
const oc = typeof document < "u";
function Ck(t, e = document) {
  var o;
  if (!oc)
    return null;
  if (e instanceof HTMLElement && ((o = e == null ? void 0 : e.dataset) == null ? void 0 : o.panelGroupId) === t)
    return e;
  const n = e.querySelector(
    `[data-panel-group][data-panel-group-id="${t}"]`
  );
  return n || null;
}
function Ff(t, e = document) {
  if (!oc)
    return null;
  const n = e.querySelector(`[data-panel-resize-handle-id="${t}"]`);
  return n || null;
}
function Sk(t, e, n = document) {
  return oc ? Cl(t, n).findIndex(
    (i) => i.getAttribute("data-panel-resize-handle-id") === e
  ) ?? null : null;
}
function Cl(t, e = document) {
  return oc ? Array.from(
    e.querySelectorAll(
      `[data-panel-resize-handle-id][data-panel-group-id="${t}"]`
    )
  ) : [];
}
function bW(t, e, n, o = document) {
  var c, u;
  const r = Ff(e, o), i = Cl(t, o), s = r ? i.indexOf(r) : -1, a = ((c = n[s]) == null ? void 0 : c.id) ?? null, l = ((u = n[s + 1]) == null ? void 0 : u.id) ?? null;
  return [a, l];
}
function wW(t, e, n, o, r) {
  const i = n === "horizontal", s = Ff(e, r);
  Ee(s);
  const a = s.getAttribute("data-panel-group-id");
  Ee(a);
  const { initialCursorPosition: l } = o, c = mk(n, t), u = Ck(a, r);
  Ee(u);
  const d = u.getBoundingClientRect(), f = i ? d.width : d.height;
  return (c - l) / f * 100;
}
function xW(t, e, n, o, r, i) {
  if (fk(t)) {
    const s = n === "horizontal";
    let a = 0;
    t.shiftKey ? a = 100 : a = r ?? 10;
    let l = 0;
    switch (t.key) {
      case "ArrowDown":
        l = s ? 0 : a;
        break;
      case "ArrowLeft":
        l = s ? -a : 0;
        break;
      case "ArrowRight":
        l = s ? a : 0;
        break;
      case "ArrowUp":
        l = s ? 0 : -a;
        break;
      case "End":
        l = 100;
        break;
      case "Home":
        l = -100;
        break;
    }
    return l;
  } else
    return o == null ? 0 : wW(
      t,
      e,
      n,
      o,
      i
    );
}
function CW({
  layout: t,
  panelsArray: e,
  pivotIndices: n
}) {
  let o = 0, r = 100, i = 0, s = 0;
  const a = n[0];
  Ee(a != null), e.forEach((d, f) => {
    const { constraints: p } = d, { maxSize: m = 100, minSize: g = 0 } = p;
    f === a ? (o = g, r = m) : (i += g, s += m);
  });
  const l = Math.min(r, 100 - i), c = Math.max(o, 100 - s), u = t[a];
  return {
    valueMax: l,
    valueMin: c,
    valueNow: u
  };
}
function SW({
  panelDataArray: t
}) {
  const e = Array(t.length), n = t.map(
    (i) => i.constraints
  );
  let o = 0, r = 100;
  for (let i = 0; i < t.length; i++) {
    const s = n[i];
    Ee(s);
    const { defaultSize: a } = s;
    a != null && (o++, e[i] = a, r -= a);
  }
  for (let i = 0; i < t.length; i++) {
    const s = n[i];
    Ee(s);
    const { defaultSize: a } = s;
    if (a != null)
      continue;
    const l = t.length - o, c = r / l;
    o++, e[i] = c, r -= c;
  }
  return e;
}
function wa(t, e, n) {
  e.forEach((o, r) => {
    const i = t[r];
    Ee(i);
    const { callbacks: s, constraints: a, id: l } = i, { collapsedSize: c = 0, collapsible: u } = a, d = n[l];
    if (d == null || o !== d) {
      n[l] = o;
      const { onCollapse: f, onExpand: p, onResize: m } = s;
      m && m(o, d), u && (f || p) && (p && (d == null || d === c) && o !== c && p(), f && (d == null || d !== c) && o === c && f());
    }
  });
}
function kW(t, e = 10) {
  let n = null;
  return (...r) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      t(...r);
    }, e);
  };
}
function kk(t, e, n) {
  const o = Sk(
    t,
    e,
    n
  );
  return o != null ? [o, o + 1] : [-1, -1];
}
function EW({
  layout: t,
  panelConstraints: e
}) {
  const n = [...t], o = n.reduce(
    (i, s) => i + s,
    0
  );
  if (n.length !== e.length)
    throw new Error(
      `Invalid ${e.length} panel layout: ${n.map((i) => `${i}%`).join(", ")}`
    );
  if (!an(o, 100)) {
    console.warn(
      `WARNING: Invalid layout total size: ${n.map((i) => `${i}%`).join(", ")}. Layout normalization will be applied.`
    );
    for (let i = 0; i < e.length; i++) {
      const s = n[i];
      Ee(s != null);
      const a = 100 / o * s;
      n[i] = a;
    }
  }
  let r = 0;
  for (let i = 0; i < e.length; i++) {
    const s = n[i];
    Ee(s != null);
    const a = as({
      panelConstraints: e,
      panelIndex: i,
      size: s
    });
    s !== a && (r += s - a, n[i] = a);
  }
  if (!an(r, 0))
    for (let i = 0; i < e.length; i++) {
      const s = n[i];
      Ee(s != null);
      const a = s + r, l = as({
        panelConstraints: e,
        panelIndex: i,
        size: a
      });
      if (s !== l && (r -= l - s, n[i] = l, an(r, 0)))
        break;
    }
  return n;
}
function Lb(t) {
  try {
    if (typeof localStorage < "u")
      t.getItem = (e) => localStorage.getItem(e), t.setItem = (e, n) => {
        localStorage.setItem(e, n);
      };
    else
      throw new TypeError("localStorage not supported in this environment");
  } catch (e) {
    console.error(e), t.getItem = () => null, t.setItem = () => {
    };
  }
}
function Ek(t) {
  return `reka:${t}`;
}
function _k(t) {
  return t.map((e) => {
    const { constraints: n, id: o, idIsFromProps: r, order: i } = e;
    return r ? o : i ? `${i}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((e, n) => e.localeCompare(n)).join(",");
}
function Ak(t, e) {
  try {
    const n = Ek(t), o = e.getItem(n);
    if (o) {
      const r = JSON.parse(o);
      if (typeof r == "object" && r != null)
        return r;
    }
  } catch {
  }
  return null;
}
function _W(t, e, n) {
  const o = Ak(t, n) ?? {}, r = _k(e);
  return o[r] ?? null;
}
function AW(t, e, n, o, r) {
  const i = Ek(t), s = _k(e), a = Ak(t, r) ?? {};
  a[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: o
  };
  try {
    r.setItem(i, JSON.stringify(a));
  } catch (l) {
    console.error(l);
  }
}
function TW({
  eagerValuesRef: t,
  groupId: e,
  layout: n,
  panelDataArray: o,
  panelGroupElement: r,
  setLayout: i
}) {
  Ve((s) => {
    const a = r.value;
    if (!a)
      return;
    const l = Cl(
      e,
      a
    );
    for (let c = 0; c < o.length - 1; c++) {
      const { valueMax: u, valueMin: d, valueNow: f } = CW({
        layout: n.value,
        panelsArray: o,
        pivotIndices: [c, c + 1]
      }), p = l[c];
      if (p != null) {
        const m = o[c];
        Ee(m), p.setAttribute("aria-controls", m.id), p.setAttribute(
          "aria-valuemax",
          `${Math.round(u)}`
        ), p.setAttribute(
          "aria-valuemin",
          `${Math.round(d)}`
        ), p.setAttribute(
          "aria-valuenow",
          f != null ? `${Math.round(f)}` : ""
        );
      }
    }
    s(() => {
      l.forEach((c) => {
        c.removeAttribute("aria-controls"), c.removeAttribute("aria-valuemax"), c.removeAttribute("aria-valuemin"), c.removeAttribute("aria-valuenow");
      });
    });
  }), Ve((s) => {
    const a = r.value;
    if (!a)
      return;
    const l = t.value;
    Ee(l);
    const { panelDataArray: c } = l, u = Ck(e, a);
    Ee(u != null, `No group found for id "${e}"`);
    const d = Cl(e, a);
    Ee(d);
    const f = d.map((p) => {
      const m = p.getAttribute("data-panel-resize-handle-id");
      Ee(m);
      const [g, v] = bW(
        e,
        m,
        c,
        a
      );
      if (g == null || v == null)
        return () => {
        };
      const y = (w) => {
        if (!w.defaultPrevented)
          switch (w.key) {
            case "Enter": {
              w.preventDefault();
              const x = c.findIndex(
                (b) => b.id === g
              );
              if (x >= 0) {
                const b = c[x];
                Ee(b);
                const S = n.value[x], {
                  collapsedSize: k = 0,
                  collapsible: A,
                  minSize: $ = 0
                } = b.constraints;
                if (S != null && A) {
                  const O = Ma({
                    delta: an(S, k) ? $ - k : k - S,
                    layout: n.value,
                    panelConstraints: c.map(
                      (M) => M.constraints
                    ),
                    pivotIndices: kk(
                      e,
                      m,
                      a
                    ),
                    trigger: "keyboard"
                  });
                  n.value !== O && i(O);
                }
              }
              break;
            }
          }
      };
      return p.addEventListener("keydown", y), () => {
        p.removeEventListener("keydown", y);
      };
    });
    s(() => {
      f.forEach((p) => p());
    });
  });
}
const OW = 100, Ia = {
  getItem: (t) => (Lb(Ia), Ia.getItem(t)),
  setItem: (t, e) => {
    Lb(Ia), Ia.setItem(t, e);
  }
}, [Tk, MW] = je("PanelGroup"), IW = /* @__PURE__ */ I({
  __name: "SplitterGroup",
  props: {
    id: {},
    autoSaveId: { default: null },
    direction: {},
    keyboardResizeBy: { default: 10 },
    storage: { default: () => Ia },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["layout"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = {}, { direction: i } = st(n), s = St(n.id, "reka-splitter-group"), a = qo(), { forwardRef: l, currentElement: c } = ee(), u = R(null), d = R([]), f = R({}), p = R(/* @__PURE__ */ new Map()), m = R(0), g = L(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: u.value,
      id: s,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), v = R({
      layout: d.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), y = (B) => d.value = B;
    TW({
      eagerValuesRef: v,
      groupId: s,
      layout: d,
      panelDataArray: v.value.panelDataArray,
      setLayout: y,
      panelGroupElement: c
    }), Ve(() => {
      const { panelDataArray: B } = v.value, { autoSaveId: q } = n;
      if (q) {
        if (d.value.length === 0 || d.value.length !== B.length)
          return;
        let z = r[q];
        z || (z = kW(
          AW,
          OW
        ), r[q] = z);
        const H = [...B], Z = new Map(
          p.value
        );
        z(
          q,
          H,
          Z,
          d.value,
          n.storage
        );
      }
    });
    function w(B, q) {
      const { panelDataArray: z } = v.value, H = G(z, B);
      return uW({
        defaultSize: q,
        dragState: u.value,
        layout: d.value,
        panelData: z,
        panelIndex: H
      });
    }
    function x(B) {
      const { panelDataArray: q } = v.value;
      q.push(B), q.sort((z, H) => {
        const Z = z.order, ne = H.order;
        return Z == null && ne == null ? 0 : Z == null ? -1 : ne == null ? 1 : Z - ne;
      }), v.value.panelDataArrayChanged = !0;
    }
    le(() => v.value.panelDataArrayChanged, () => {
      if (v.value.panelDataArrayChanged) {
        v.value.panelDataArrayChanged = !1;
        const { autoSaveId: B, storage: q } = g.value, { layout: z, panelDataArray: H } = v.value;
        let Z = null;
        if (B) {
          const he = _W(B, H, q);
          he && (p.value = new Map(
            Object.entries(he.expandToSizes)
          ), Z = he.layout);
        }
        Z === null && (Z = SW({
          panelDataArray: H
        }));
        const ne = EW({
          layout: Z,
          panelConstraints: H.map(
            (he) => he.constraints
          )
        });
        xU(z, ne) || (y(ne), v.value.layout = ne, o("layout", ne), wa(
          H,
          ne,
          f.value
        ));
      }
    });
    function b(B) {
      return function(z) {
        z.preventDefault();
        const H = c.value;
        if (!H)
          return () => null;
        const { direction: Z, dragState: ne, id: he, keyboardResizeBy: we } = g.value, { layout: Ae, panelDataArray: Re } = v.value, { initialLayout: qe } = ne ?? {}, Ue = kk(
          he,
          B,
          H
        );
        let Be = xW(
          z,
          B,
          Z,
          ne,
          we,
          H
        );
        if (Be === 0)
          return;
        const rt = Z === "horizontal";
        a.value === "rtl" && rt && (Be = -Be);
        const yn = Re.map((Fi) => Fi.constraints), Jt = Ma({
          delta: Be,
          layout: qe ?? Ae,
          panelConstraints: yn,
          pivotIndices: Ue,
          trigger: fk(z) ? "keyboard" : "mouse-or-touch"
        }), bn = !Bc(Ae, Jt);
        (pk(z) || hk(z)) && m.value !== Be && (m.value = Be, bn ? jp(B, 0) : rt ? jp(
          B,
          Be < 0 ? vk : yk
        ) : jp(
          B,
          Be < 0 ? bk : wk
        )), bn && (y(Jt), v.value.layout = Jt, o("layout", Jt), wa(
          Re,
          Jt,
          f.value
        ));
      };
    }
    function S(B, q) {
      const { layout: z, panelDataArray: H } = v.value, Z = H.map((qe) => qe.constraints), { panelSize: ne, pivotIndices: he } = V(
        H,
        B,
        z
      );
      Ee(ne != null);
      const Ae = G(H, B) === H.length - 1 ? ne - q : q - ne, Re = Ma({
        delta: Ae,
        layout: z,
        panelConstraints: Z,
        pivotIndices: he,
        trigger: "imperative-api"
      });
      Bc(z, Re) || (y(Re), v.value.layout = Re, o("layout", Re), wa(
        H,
        Re,
        f.value
      ));
    }
    function k(B, q) {
      const { layout: z, panelDataArray: H } = v.value, Z = G(H, B);
      H[Z] = B, v.value.panelDataArrayChanged = !0;
      const {
        collapsedSize: ne = 0,
        collapsible: he
      } = q, {
        collapsedSize: we = 0,
        collapsible: Ae,
        maxSize: Re = 100,
        minSize: qe = 0
      } = B.constraints, { panelSize: Ue } = V(
        H,
        B,
        z
      );
      Ue !== null && (he && Ae && Ue === ne ? ne !== we && S(B, we) : Ue < qe ? S(B, qe) : Ue > Re && S(B, Re));
    }
    function A(B, q) {
      const { direction: z } = g.value, { layout: H } = v.value;
      if (!c.value)
        return;
      const Z = Ff(
        B,
        c.value
      );
      Ee(Z);
      const ne = mk(
        z,
        q
      );
      u.value = {
        dragHandleId: B,
        dragHandleRect: Z.getBoundingClientRect(),
        initialCursorPosition: ne,
        initialLayout: H
      };
    }
    function $() {
      u.value = null;
    }
    function O(B) {
      const { panelDataArray: q } = v.value, z = G(q, B);
      z >= 0 && (q.splice(z, 1), delete f.value[B.id], v.value.panelDataArrayChanged = !0);
    }
    function M(B) {
      const { layout: q, panelDataArray: z } = v.value;
      if (B.constraints.collapsible) {
        const H = z.map(
          (we) => we.constraints
        ), {
          collapsedSize: Z = 0,
          panelSize: ne,
          pivotIndices: he
        } = V(z, B, q);
        if (Ee(
          ne != null,
          `Panel size not found for panel "${B.id}"`
        ), ne !== Z) {
          p.value.set(B.id, ne);
          const Ae = G(z, B) === z.length - 1 ? ne - Z : Z - ne, Re = Ma({
            delta: Ae,
            layout: q,
            panelConstraints: H,
            pivotIndices: he,
            trigger: "imperative-api"
          });
          Bc(q, Re) || (y(Re), v.value.layout = Re, o("layout", Re), wa(
            z,
            Re,
            f.value
          ));
        }
      }
    }
    function P(B) {
      const { layout: q, panelDataArray: z } = v.value;
      if (B.constraints.collapsible) {
        const H = z.map(
          (Ae) => Ae.constraints
        ), {
          collapsedSize: Z = 0,
          panelSize: ne,
          minSize: he = 0,
          pivotIndices: we
        } = V(z, B, q);
        if (ne === Z) {
          const Ae = p.value.get(
            B.id
          ), Re = Ae != null && Ae >= he ? Ae : he, Ue = G(z, B) === z.length - 1 ? ne - Re : Re - ne, Be = Ma({
            delta: Ue,
            layout: q,
            panelConstraints: H,
            pivotIndices: we,
            trigger: "imperative-api"
          });
          Bc(q, Be) || (y(Be), v.value.layout = Be, o("layout", Be), wa(
            z,
            Be,
            f.value
          ));
        }
      }
    }
    function F(B) {
      const { layout: q, panelDataArray: z } = v.value, { panelSize: H } = V(z, B, q);
      return Ee(
        H != null,
        `Panel size not found for panel "${B.id}"`
      ), H;
    }
    function J(B) {
      const { layout: q, panelDataArray: z } = v.value, {
        collapsedSize: H = 0,
        collapsible: Z,
        panelSize: ne
      } = V(z, B, q);
      return Z ? ne === void 0 ? B.constraints.defaultSize === B.constraints.collapsedSize : ne === H : !1;
    }
    function Q(B) {
      const { layout: q, panelDataArray: z } = v.value, {
        collapsedSize: H = 0,
        collapsible: Z,
        panelSize: ne
      } = V(z, B, q);
      return Ee(
        ne != null,
        `Panel size not found for panel "${B.id}"`
      ), !Z || ne > H;
    }
    MW({
      direction: i,
      dragState: u.value,
      groupId: s,
      reevaluatePanelConstraints: k,
      registerPanel: x,
      registerResizeHandle: b,
      resizePanel: S,
      startDragging: A,
      stopDragging: $,
      unregisterPanel: O,
      panelGroupElement: c,
      collapsePanel: M,
      expandPanel: P,
      isPanelCollapsed: J,
      isPanelExpanded: Q,
      getPanelSize: F,
      getPanelStyle: w
    });
    function G(B, q) {
      return B.findIndex(
        (z) => z === q || z.id === q.id
      );
    }
    function V(B, q, z) {
      const H = G(B, q), ne = H === B.length - 1 ? [H - 1, H] : [H, H + 1], he = z[H];
      return {
        ...q.constraints,
        panelSize: he,
        pivotIndices: ne
      };
    }
    return (B, q) => (E(), T(h(ae), {
      ref: h(l),
      as: B.as,
      "as-child": B.asChild,
      style: pt({
        display: "flex",
        flexDirection: h(i) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": h(i),
      "data-panel-group-id": h(s)
    }, {
      default: C(() => [
        D(B.$slots, "default", { layout: d.value })
      ]),
      _: 3
    }, 8, ["as", "as-child", "style", "data-orientation", "data-panel-group-id"]));
  }
}), Db = /* @__PURE__ */ I({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {},
    collapsible: { type: Boolean },
    defaultSize: {},
    id: {},
    maxSize: {},
    minSize: {},
    order: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["collapse", "expand", "resize"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, i = Tk();
    if (i === null)
      throw new Error(
        "SplitterPanel components must be rendered within a SplitterGroup container"
      );
    const { collapsePanel: s, expandPanel: a, getPanelSize: l, getPanelStyle: c, isPanelCollapsed: u, resizePanel: d, groupId: f, reevaluatePanelConstraints: p, registerPanel: m, unregisterPanel: g } = i, v = St(o.id, "reka-splitter-panel"), y = L(() => ({
      callbacks: {
        onCollapse: () => r("collapse"),
        onExpand: () => r("expand"),
        onResize: (...S) => r("resize", ...S)
      },
      constraints: {
        collapsedSize: o.collapsedSize && Number.parseFloat(o.collapsedSize.toFixed(J1)),
        collapsible: o.collapsible,
        defaultSize: o.defaultSize,
        /** Panel id (unique within group); falls back to useId when not provided */
        /** Panel id (unique within group); falls back to useId when not provided */
        maxSize: o.maxSize,
        minSize: o.minSize
      },
      id: v,
      idIsFromProps: o.id !== void 0,
      order: o.order
    }));
    le(() => y.value.constraints, (S, k) => {
      (k.collapsedSize !== S.collapsedSize || k.collapsible !== S.collapsible || k.maxSize !== S.maxSize || k.minSize !== S.minSize) && p(y.value, k);
    }, { deep: !0 }), be(() => {
      const S = y.value;
      m(S), Nt(() => {
        g(S);
      });
    });
    const w = L(() => c(y.value, o.defaultSize)), x = L(() => u(y.value)), b = L(() => !x.value);
    return e({
      /** If panel is `collapsible`, collapse it fully. */
      collapse: () => {
        s(y.value);
      },
      /** If panel is currently collapsed, expand it to its most recent size. */
      expand: () => {
        a(y.value);
      },
      /** Gets the current size of the panel as a percentage (1 - 100). */
      getSize() {
        return l(y.value);
      },
      /** Resize panel to the specified percentage (1 - 100). */
      resize: (S) => {
        d(y.value, S);
      },
      /** Returns `true` if the panel is currently collapsed */
      isCollapsed: x,
      /** Returns `true` if the panel is currently not collapsed */
      isExpanded: b
    }), (S, k) => (E(), T(h(ae), {
      id: h(v),
      style: pt(w.value),
      as: S.as,
      "as-child": S.asChild,
      "data-panel": "",
      "data-panel-collapsible": S.collapsible || void 0,
      "data-panel-group-id": h(f),
      "data-panel-id": h(v),
      "data-panel-size": Number.parseFloat(`${w.value.flexGrow}`).toFixed(1),
      "data-state": S.collapsible ? x.value ? "collapsed" : "expanded" : void 0
    }, {
      default: C(() => [
        D(S.$slots, "default", {
          isCollapsed: x.value,
          isExpanded: b.value
        })
      ]),
      _: 3
    }, 8, ["id", "style", "as", "as-child", "data-panel-collapsible", "data-panel-group-id", "data-panel-id", "data-panel-size", "data-state"]));
  }
});
function RW({
  disabled: t,
  handleId: e,
  resizeHandler: n,
  panelGroupElement: o
}) {
  Ve((r) => {
    const i = o.value;
    if (t.value || n.value === null || i === null)
      return;
    const s = Ff(e, i);
    if (s == null)
      return;
    const a = (l) => {
      var c;
      if (!l.defaultPrevented)
        switch (l.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            l.preventDefault(), (c = n.value) == null || c.call(n, l);
            break;
          }
          case "F6": {
            l.preventDefault();
            const u = s.getAttribute("data-panel-group-id");
            Ee(u);
            const d = Cl(
              u,
              i
            ), f = Sk(
              u,
              e,
              i
            );
            Ee(f !== null);
            const p = l.shiftKey ? f > 0 ? f - 1 : d.length - 1 : f + 1 < d.length ? f + 1 : 0;
            d[p].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", a), r(() => {
      s.removeEventListener("keydown", a);
    });
  });
}
const $W = /* @__PURE__ */ I({
  __name: "SplitterResizeHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: { default: 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["dragging"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = ee(), { disabled: s } = st(n), a = Tk();
    if (a === null)
      throw new Error(
        "PanelResizeHandle components must be rendered within a PanelGroup container"
      );
    const {
      direction: l,
      groupId: c,
      registerResizeHandle: u,
      startDragging: d,
      stopDragging: f,
      panelGroupElement: p
    } = a, m = St(n.id, "reka-splitter-resize-handle"), g = R("inactive"), v = R(!1), y = R(null);
    return le(s, () => {
      oc && (s.value ? y.value = null : y.value = u(m));
    }, { immediate: !0 }), Ve((w) => {
      var S, k;
      if (s.value || y.value === null)
        return;
      const x = i.value;
      if (!x)
        return;
      Ee(x);
      const b = (A, $, O) => {
        var M;
        if ($)
          switch (A) {
            case "down": {
              g.value = "drag", d(m, O), o("dragging", !0);
              break;
            }
            case "move": {
              g.value !== "drag" && (g.value = "hover"), (M = y.value) == null || M.call(y, O);
              break;
            }
            case "up": {
              g.value = "hover", f(), o("dragging", !1);
              break;
            }
          }
        else
          g.value = "inactive";
      };
      w(yW(
        m,
        x,
        l,
        {
          // Coarse inputs (e.g. finger/touch)
          coarse: ((S = n.hitAreaMargins) == null ? void 0 : S.coarse) ?? 15,
          // Fine inputs (e.g. mouse)
          fine: ((k = n.hitAreaMargins) == null ? void 0 : k.fine) ?? 5
        },
        b
      ));
    }), RW({
      disabled: s,
      resizeHandler: y,
      handleId: m,
      panelGroupElement: p
    }), (w, x) => (E(), T(h(ae), {
      id: h(m),
      ref: h(r),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: w.as,
      "as-child": w.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: w.tabindex,
      "data-state": g.value,
      "data-disabled": h(s) ? "" : void 0,
      "data-orientation": h(l),
      "data-panel-group-id": h(c),
      "data-resize-handle-active": g.value === "drag" ? "pointer" : v.value ? "keyboard" : void 0,
      "data-resize-handle-state": g.value,
      "data-panel-resize-handle-enabled": !h(s),
      "data-panel-resize-handle-id": h(m),
      onBlur: x[0] || (x[0] = (b) => v.value = !1),
      onFocus: x[1] || (x[1] = (b) => v.value = !1)
    }, {
      default: C(() => [
        D(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "as", "as-child", "tabindex", "data-state", "data-disabled", "data-orientation", "data-panel-group-id", "data-resize-handle-active", "data-resize-handle-state", "data-panel-resize-handle-enabled", "data-panel-resize-handle-id"]));
  }
}), [X1, PW] = je("TabsRoot"), LW = /* @__PURE__ */ I({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    unmountOnHide: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { orientation: r, unmountOnHide: i, dir: s } = st(n), a = qo(s);
    ee();
    const l = It(n, "modelValue", o, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), c = R();
    return PW({
      modelValue: l,
      changeModelValue: (u) => {
        l.value = u;
      },
      orientation: r,
      dir: a,
      unmountOnHide: i,
      activationMode: n.activationMode,
      baseId: St(void 0, "reka-tabs"),
      tabsList: c
    }), (u, d) => (E(), T(h(ae), {
      dir: h(a),
      "data-orientation": h(r),
      "as-child": u.asChild,
      as: u.as
    }, {
      default: C(() => [
        D(u.$slots, "default", { modelValue: h(l) })
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), DW = /* @__PURE__ */ I({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { loop: n } = st(e), { forwardRef: o, currentElement: r } = ee(), i = X1();
    return i.tabsList = r, (s, a) => (E(), T(h(Of), {
      "as-child": "",
      orientation: h(i).orientation.value,
      dir: h(i).dir.value,
      loop: h(n)
    }, {
      default: C(() => [
        _(h(ae), {
          ref: h(o),
          role: "tablist",
          "as-child": s.asChild,
          as: s.as,
          "aria-orientation": h(i).orientation.value
        }, {
          default: C(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
function Ok(t, e) {
  return `${t}-trigger-${e}`;
}
function Mk(t, e) {
  return `${t}-content-${e}`;
}
const NW = /* @__PURE__ */ I({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n } = ee(), o = X1(), r = L(() => Ok(o.baseId, e.value)), i = L(() => Mk(o.baseId, e.value)), s = L(() => e.value === o.modelValue.value), a = R(s.value);
    return be(() => {
      requestAnimationFrame(() => {
        a.value = !1;
      });
    }), (l, c) => (E(), T(h(rn), {
      present: l.forceMount || s.value,
      "force-mount": ""
    }, {
      default: C(({ present: u }) => [
        _(h(ae), {
          id: i.value,
          ref: h(n),
          "as-child": l.asChild,
          as: l.as,
          role: "tabpanel",
          "data-state": s.value ? "active" : "inactive",
          "data-orientation": h(o).orientation.value,
          "aria-labelledby": r.value,
          hidden: !u,
          tabindex: "0",
          style: pt({
            animationDuration: a.value ? "0s" : void 0
          })
        }, {
          default: C(() => [
            !h(o).unmountOnHide.value || u ? D(l.$slots, "default", { key: 0 }) : oe("", !0)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), BW = /* @__PURE__ */ I({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, { forwardRef: n } = ee(), o = X1(), r = L(() => Ok(o.baseId, e.value)), i = L(() => Mk(o.baseId, e.value)), s = L(() => e.value === o.modelValue.value);
    return (a, l) => (E(), T(h(Mf), {
      "as-child": "",
      focusable: !a.disabled,
      active: s.value
    }, {
      default: C(() => [
        _(h(ae), {
          id: r.value,
          ref: h(n),
          role: "tab",
          type: a.as === "button" ? "button" : void 0,
          as: a.as,
          "as-child": a.asChild,
          "aria-selected": s.value ? "true" : "false",
          "aria-controls": i.value,
          "data-state": s.value ? "active" : "inactive",
          disabled: a.disabled,
          "data-disabled": a.disabled ? "" : void 0,
          "data-orientation": h(o).orientation.value,
          onMousedown: l[0] || (l[0] = mt((c) => {
            !a.disabled && c.ctrlKey === !1 ? h(o).changeModelValue(a.value) : c.preventDefault();
          }, ["left"])),
          onKeydown: l[1] || (l[1] = Sr((c) => h(o).changeModelValue(a.value), ["enter", "space"])),
          onFocus: l[2] || (l[2] = () => {
            const c = h(o).activationMode !== "manual";
            !s.value && !a.disabled && c && h(o).changeModelValue(a.value);
          })
        }, {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), [zf, FW] = je("ToastProvider"), zW = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(t) {
    const e = t, { label: n, duration: o, swipeDirection: r, swipeThreshold: i } = st(e);
    Yt({ isProvider: !0 });
    const s = R(), a = R(0), l = R(!1), c = R(!1);
    if (e.label && typeof e.label == "string" && !e.label.trim()) {
      const u = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(u);
    }
    return FW({
      label: n,
      duration: o,
      swipeDirection: r,
      swipeThreshold: i,
      toastCount: a,
      viewport: s,
      onViewportChange(u) {
        s.value = u;
      },
      onToastAdd() {
        a.value++;
      },
      onToastRemove() {
        a.value--;
      },
      isFocusedToastEscapeKeyDownRef: l,
      isClosePausedRef: c
    }), (u, d) => D(u.$slots, "default");
  }
}), HW = "toast.swipeStart", VW = "toast.swipeMove", UW = "toast.swipeCancel", jW = "toast.swipeEnd", Mm = "toast.viewportPause", Im = "toast.viewportResume";
function Fc(t, e, n) {
  const o = n.originalEvent.currentTarget, r = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && o.addEventListener(t, e, { once: !0 }), o.dispatchEvent(r);
}
function Nb(t, e, n = 0) {
  const o = Math.abs(t.x), r = Math.abs(t.y), i = o > r;
  return e === "left" || e === "right" ? i && o > n : !i && r > n;
}
function WW(t) {
  return t.nodeType === t.ELEMENT_NODE;
}
function Ik(t) {
  const e = [];
  return Array.from(t.childNodes).forEach((o) => {
    if (o.nodeType === o.TEXT_NODE && o.textContent && e.push(o.textContent), WW(o)) {
      const r = o.ariaHidden || o.hidden || o.style.display === "none", i = o.dataset.rekaToastAnnounceExclude === "";
      if (!r)
        if (i) {
          const s = o.dataset.rekaToastAnnounceAlt;
          s && e.push(s);
        } else
          e.push(...Ik(o));
    }
  }), e;
}
const KW = /* @__PURE__ */ I({
  __name: "ToastAnnounce",
  setup(t) {
    const e = zf(), n = lV(1e3), o = R(!1);
    return M4(() => {
      o.value = !0;
    }), (r, i) => h(n) || o.value ? (E(), T(h(Jl), { key: 0 }, {
      default: C(() => [
        ue(Y(h(e).label.value) + " ", 1),
        D(r.$slots, "default")
      ]),
      _: 3
    })) : oe("", !0);
  }
}), [GW, qW] = je("ToastRoot"), YW = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: !1 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = ee(), { CollectionItem: s } = Yt(), a = zf(), l = R(null), c = R(null), u = L(
      () => typeof n.duration == "number" ? n.duration : a.duration.value
    ), d = R(0), f = R(u.value), p = R(0), m = R(u.value), g = M4(() => {
      const x = (/* @__PURE__ */ new Date()).getTime() - d.value;
      m.value = Math.max(f.value - x, 0);
    }, { fpsLimit: 60 });
    function v(x) {
      x <= 0 || x === Number.POSITIVE_INFINITY || yo && (window.clearTimeout(p.value), d.value = (/* @__PURE__ */ new Date()).getTime(), p.value = window.setTimeout(y, x));
    }
    function y(x) {
      var k, A;
      const b = (x == null ? void 0 : x.pointerType) === "";
      ((k = i.value) == null ? void 0 : k.contains(gt())) && b && ((A = a.viewport.value) == null || A.focus()), b && (a.isClosePausedRef.value = !1), o("close");
    }
    const w = L(() => i.value ? Ik(i.value) : null);
    if (n.type && !["foreground", "background"].includes(n.type)) {
      const x = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(x);
    }
    return Ve((x) => {
      const b = a.viewport.value;
      if (b) {
        const S = () => {
          v(f.value), g.resume(), o("resume");
        }, k = () => {
          const A = (/* @__PURE__ */ new Date()).getTime() - d.value;
          f.value = f.value - A, window.clearTimeout(p.value), g.pause(), o("pause");
        };
        return b.addEventListener(Mm, k), b.addEventListener(Im, S), () => {
          b.removeEventListener(Mm, k), b.removeEventListener(Im, S);
        };
      }
    }), le(() => [n.open, u.value], () => {
      f.value = u.value, n.open && !a.isClosePausedRef.value && v(u.value);
    }, { immediate: !0 }), P1("Escape", (x) => {
      o("escapeKeyDown", x), x.defaultPrevented || (a.isFocusedToastEscapeKeyDownRef.value = !0, y());
    }), be(() => {
      a.onToastAdd();
    }), Nt(() => {
      a.onToastRemove();
    }), qW({ onClose: y }), (x, b) => (E(), W(me, null, [
      w.value ? (E(), T(KW, {
        key: 0,
        role: "alert",
        "aria-live": x.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": "true"
      }, {
        default: C(() => [
          ue(Y(w.value), 1)
        ]),
        _: 1
      }, 8, ["aria-live"])) : oe("", !0),
      h(a).viewport.value ? (E(), T(qd, {
        key: 1,
        to: h(a).viewport.value
      }, [
        _(h(s), null, {
          default: C(() => [
            _(h(ae), j({
              ref: h(r),
              role: "alert",
              "aria-live": "off",
              "aria-atomic": "true",
              tabindex: "0"
            }, x.$attrs, {
              as: x.as,
              "as-child": x.asChild,
              "data-state": x.open ? "open" : "closed",
              "data-swipe-direction": h(a).swipeDirection.value,
              style: { userSelect: "none", touchAction: "none" },
              onPointerdown: b[0] || (b[0] = mt((S) => {
                l.value = { x: S.clientX, y: S.clientY };
              }, ["left"])),
              onPointermove: b[1] || (b[1] = (S) => {
                if (!l.value) return;
                const k = S.clientX - l.value.x, A = S.clientY - l.value.y, $ = !!c.value, O = ["left", "right"].includes(h(a).swipeDirection.value), M = ["left", "up"].includes(h(a).swipeDirection.value) ? Math.min : Math.max, P = O ? M(0, k) : 0, F = O ? 0 : M(0, A), J = S.pointerType === "touch" ? 10 : 2, Q = { x: P, y: F }, G = { originalEvent: S, delta: Q };
                $ ? (c.value = Q, h(Fc)(h(VW), (V) => o("swipeMove", V), G)) : h(Nb)(Q, h(a).swipeDirection.value, J) ? (c.value = Q, h(Fc)(h(HW), (V) => o("swipeStart", V), G), S.target.setPointerCapture(S.pointerId)) : (Math.abs(k) > J || Math.abs(A) > J) && (l.value = null);
              }),
              onPointerup: b[2] || (b[2] = (S) => {
                const k = c.value, A = S.target;
                if (A.hasPointerCapture(S.pointerId) && A.releasePointerCapture(S.pointerId), c.value = null, l.value = null, k) {
                  const $ = S.currentTarget, O = { originalEvent: S, delta: k };
                  h(Nb)(k, h(a).swipeDirection.value, h(a).swipeThreshold.value) ? h(Fc)(h(jW), (M) => o("swipeEnd", M), O) : h(Fc)(h(UW), (M) => o("swipeCancel", M), O), $ == null || $.addEventListener("click", (M) => M.preventDefault(), {
                    once: !0
                  });
                }
              })
            }), {
              default: C(() => [
                D(x.$slots, "default", {
                  remaining: m.value,
                  duration: u.value
                })
              ]),
              _: 3
            }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
          ]),
          _: 3
        })
      ], 8, ["to"])) : oe("", !0)
    ], 64));
  }
}), JW = /* @__PURE__ */ I({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: !0 },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r } = ee(), i = It(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (s, a) => (E(), T(h(rn), {
      present: s.forceMount || h(i)
    }, {
      default: C(() => [
        _(YW, j({
          ref: h(r),
          open: h(i),
          type: s.type,
          as: s.as,
          "as-child": s.asChild,
          duration: s.duration
        }, s.$attrs, {
          onClose: a[0] || (a[0] = (l) => i.value = !1),
          onPause: a[1] || (a[1] = (l) => o("pause")),
          onResume: a[2] || (a[2] = (l) => o("resume")),
          onEscapeKeyDown: a[3] || (a[3] = (l) => o("escapeKeyDown", l)),
          onSwipeStart: a[4] || (a[4] = (l) => {
            o("swipeStart", l), l.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: a[5] || (a[5] = (l) => {
            o("swipeMove", l);
            const { x: c, y: u } = l.detail.delta, d = l.currentTarget;
            d.setAttribute("data-swipe", "move"), d.style.setProperty("--reka-toast-swipe-move-x", `${c}px`), d.style.setProperty("--reka-toast-swipe-move-y", `${u}px`);
          }),
          onSwipeCancel: a[6] || (a[6] = (l) => {
            o("swipeCancel", l);
            const c = l.currentTarget;
            c.setAttribute("data-swipe", "cancel"), c.style.removeProperty("--reka-toast-swipe-move-x"), c.style.removeProperty("--reka-toast-swipe-move-y"), c.style.removeProperty("--reka-toast-swipe-end-x"), c.style.removeProperty("--reka-toast-swipe-end-y");
          }),
          onSwipeEnd: a[7] || (a[7] = (l) => {
            o("swipeEnd", l);
            const { x: c, y: u } = l.detail.delta, d = l.currentTarget;
            d.setAttribute("data-swipe", "end"), d.style.removeProperty("--reka-toast-swipe-move-x"), d.style.removeProperty("--reka-toast-swipe-move-y"), d.style.setProperty("--reka-toast-swipe-end-x", `${c}px`), d.style.setProperty("--reka-toast-swipe-end-y", `${u}px`), i.value = !1;
          })
        }), {
          default: C(({ remaining: l, duration: c }) => [
            D(s.$slots, "default", {
              remaining: l,
              duration: c,
              open: h(i)
            })
          ]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), XW = /* @__PURE__ */ I({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    return (e, n) => (E(), T(h(ae), {
      as: e.as,
      "as-child": e.asChild,
      "data-reka-toast-announce-exclude": "",
      "data-reka-toast-announce-alt": e.altText || void 0
    }, {
      default: C(() => [
        D(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-reka-toast-announce-alt"]));
  }
}), ZW = /* @__PURE__ */ I({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = GW(), { forwardRef: o } = ee();
    return (r, i) => (E(), T(XW, { "as-child": "" }, {
      default: C(() => [
        _(h(ae), j(e, {
          ref: h(o),
          type: r.as === "button" ? "button" : void 0,
          onClick: h(n).onClose
        }), {
          default: C(() => [
            D(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["type", "onClick"])
      ]),
      _: 3
    }));
  }
}), Bb = /* @__PURE__ */ I({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(t, { emit: e }) {
    const n = e, o = zf();
    return (r, i) => (E(), T(h(Jl), {
      "aria-hidden": "true",
      tabindex: "0",
      style: { position: "fixed" },
      onFocus: i[0] || (i[0] = (s) => {
        var c;
        const a = s.relatedTarget;
        !((c = h(o).viewport.value) != null && c.contains(a)) && n("focusFromOutsideViewport");
      })
    }, {
      default: C(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }));
  }
}), QW = /* @__PURE__ */ I({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n, currentElement: o } = ee();
    return be(() => {
      Pn.branches.add(o.value);
    }), Nt(() => {
      Pn.branches.delete(o.value);
    }), (r, i) => (E(), T(h(ae), j({ ref: h(n) }, e), {
      default: C(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), eK = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => ["F8"] },
    label: { type: [String, Function], default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(t) {
    const e = t, { hotkey: n, label: o } = st(e), { forwardRef: r, currentElement: i } = ee(), { CollectionSlot: s, getItems: a } = Yt(), l = zf(), c = L(() => l.toastCount.value > 0), u = R(), d = R(), f = L(() => n.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    P1(n.value, () => {
      i.value.focus();
    }), be(() => {
      l.onViewportChange(i.value);
    }), Ve((m) => {
      const g = i.value;
      if (c.value && g) {
        const v = () => {
          if (!l.isClosePausedRef.value) {
            const S = new CustomEvent(Mm);
            g.dispatchEvent(S), l.isClosePausedRef.value = !0;
          }
        }, y = () => {
          if (l.isClosePausedRef.value) {
            const S = new CustomEvent(Im);
            g.dispatchEvent(S), l.isClosePausedRef.value = !1;
          }
        }, w = (S) => {
          !g.contains(S.relatedTarget) && y();
        }, x = () => {
          g.contains(gt()) || y();
        }, b = (S) => {
          var $, O, M;
          const k = S.altKey || S.ctrlKey || S.metaKey;
          if (S.key === "Tab" && !k) {
            const P = gt(), F = S.shiftKey;
            if (S.target === g && F) {
              ($ = u.value) == null || $.focus();
              return;
            }
            const G = p({ tabbingDirection: F ? "backwards" : "forwards" }), V = G.findIndex((B) => B === P);
            hu(G.slice(V + 1)) ? S.preventDefault() : F ? (O = u.value) == null || O.focus() : (M = d.value) == null || M.focus();
          }
        };
        g.addEventListener("focusin", v), g.addEventListener("focusout", w), g.addEventListener("pointermove", v), g.addEventListener("pointerleave", x), g.addEventListener("keydown", b), window.addEventListener("blur", v), window.addEventListener("focus", y), m(() => {
          g.removeEventListener("focusin", v), g.removeEventListener("focusout", w), g.removeEventListener("pointermove", v), g.removeEventListener("pointerleave", x), g.removeEventListener("keydown", b), window.removeEventListener("blur", v), window.removeEventListener("focus", y);
        });
      }
    });
    function p({ tabbingDirection: m }) {
      const v = a().map((y) => y.ref).map((y) => {
        const w = [y, ...N1(y)];
        return m === "forwards" ? w : w.reverse();
      });
      return (m === "forwards" ? v.reverse() : v).flat();
    }
    return (m, g) => (E(), T(h(QW), {
      role: "region",
      "aria-label": typeof h(o) == "string" ? h(o).replace("{hotkey}", f.value) : h(o)(f.value),
      tabindex: "-1",
      style: pt({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: c.value ? void 0 : "none"
      })
    }, {
      default: C(() => [
        c.value ? (E(), T(Bb, {
          key: 0,
          ref: (v) => {
            u.value = h(In)(v);
          },
          onFocusFromOutsideViewport: g[0] || (g[0] = () => {
            const v = p({
              tabbingDirection: "forwards"
            });
            h(hu)(v);
          })
        }, null, 512)) : oe("", !0),
        _(h(s), null, {
          default: C(() => [
            _(h(ae), j({
              ref: h(r),
              tabindex: "-1",
              as: m.as,
              "as-child": m.asChild
            }, m.$attrs), {
              default: C(() => [
                D(m.$slots, "default")
              ]),
              _: 3
            }, 16, ["as", "as-child"])
          ]),
          _: 3
        }),
        c.value ? (E(), T(Bb, {
          key: 1,
          ref: (v) => {
            d.value = h(In)(v);
          },
          onFocusFromOutsideViewport: g[1] || (g[1] = () => {
            const v = p({
              tabbingDirection: "backwards"
            });
            h(hu)(v);
          })
        }, null, 512)) : oe("", !0)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
}), tK = /* @__PURE__ */ I({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(ae), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nK = /* @__PURE__ */ I({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return ee(), (n, o) => (E(), T(h(ae), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Rk, oK] = je("ToggleGroupRoot"), rK = /* @__PURE__ */ I({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    orientation: {},
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { loop: r, rovingFocus: i, disabled: s, dir: a } = st(n), l = qo(a), { forwardRef: c, currentElement: u } = ee(), { modelValue: d, changeModelValue: f, isSingle: p } = yV(n, o), m = Tf(u);
    return oK({
      isSingle: p,
      modelValue: d,
      changeModelValue: f,
      dir: l,
      orientation: n.orientation,
      loop: r,
      rovingFocus: i,
      disabled: s
    }), (g, v) => (E(), T(An(h(i) ? h(Of) : h(ae)), {
      "as-child": "",
      orientation: h(i) ? g.orientation : void 0,
      dir: h(l),
      loop: h(i) ? h(r) : void 0
    }, {
      default: C(() => [
        _(h(ae), {
          ref: h(c),
          role: "group",
          "as-child": g.asChild,
          as: g.as
        }, {
          default: C(() => [
            D(g.$slots, "default", { modelValue: h(d) }),
            h(m) && g.name ? (E(), T(B1, {
              key: 0,
              name: g.name,
              required: g.required,
              value: h(d)
            }, null, 8, ["name", "required", "value"])) : oe("", !0)
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), $k = /* @__PURE__ */ I({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null], default: void 0 },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = ee(), s = Rk(null), a = It(n, "modelValue", o, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function l() {
      a.value = !a.value;
    }
    const c = L(() => a.value ? "on" : "off"), u = Tf(i);
    return (d, f) => (E(), T(h(ae), {
      ref: h(r),
      type: d.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: d.as,
      "aria-pressed": h(a),
      "data-state": c.value,
      "data-disabled": d.disabled ? "" : void 0,
      disabled: d.disabled,
      onClick: l
    }, {
      default: C(() => [
        D(d.$slots, "default", {
          modelValue: h(a),
          disabled: d.disabled,
          pressed: h(a),
          state: c.value
        }),
        h(u) && d.name && !h(s) ? (E(), T(B1, {
          key: 0,
          type: "checkbox",
          name: d.name,
          value: h(a),
          required: d.required
        }, null, 8, ["name", "value", "required"])) : oe("", !0)
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled"]));
  }
}), iK = /* @__PURE__ */ I({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = Rk(), o = L(() => {
      var s;
      return ((s = n.disabled) == null ? void 0 : s.value) || e.disabled;
    }), r = L(() => Qu(n.modelValue.value, e.value)), { forwardRef: i } = ee();
    return (s, a) => (E(), T(An(h(n).rovingFocus.value ? h(Mf) : h(ae)), {
      "as-child": "",
      focusable: !o.value,
      active: r.value
    }, {
      default: C(() => [
        _(h($k), j(e, {
          ref: h(i),
          disabled: o.value,
          "model-value": r.value,
          "onUpdate:modelValue": a[0] || (a[0] = (l) => h(n).changeModelValue(s.value))
        }), {
          default: C((l) => [
            D(s.$slots, "default", _e(Me(l)))
          ]),
          _: 3
        }, 16, ["disabled", "model-value"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), Pk = "tooltip.open", [Z1, sK] = je("TooltipProvider"), aK = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { delayDuration: n, skipDelayDuration: o, disableHoverableContent: r, disableClosingTrigger: i, ignoreNonKeyboardFocus: s, disabled: a } = st(e);
    ee();
    const l = R(!0), c = R(!1), { start: u, stop: d } = $1(() => {
      l.value = !0;
    }, o, { immediate: !1 });
    return sK({
      isOpenDelayed: l,
      delayDuration: n,
      onOpen() {
        d(), l.value = !1;
      },
      onClose() {
        u();
      },
      isPointerInTransitRef: c,
      disableHoverableContent: r,
      disableClosingTrigger: i,
      disabled: a,
      ignoreNonKeyboardFocus: s
    }), (f, p) => D(f.$slots, "default");
  }
}), [Hf, lK] = je("TooltipRoot"), cK = /* @__PURE__ */ I({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    ee();
    const r = Z1(), i = L(() => n.disableHoverableContent ?? r.disableHoverableContent.value), s = L(() => n.disableClosingTrigger ?? r.disableClosingTrigger.value), a = L(() => n.disabled ?? r.disabled.value), l = L(() => n.delayDuration ?? r.delayDuration.value), c = L(() => n.ignoreNonKeyboardFocus ?? r.ignoreNonKeyboardFocus.value), u = It(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    le(u, (x) => {
      r.onClose && (x ? (r.onOpen(), document.dispatchEvent(new CustomEvent(Pk))) : r.onClose());
    });
    const d = R(!1), f = R(), p = L(() => u.value ? d.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: g } = $1(() => {
      d.value = !0, u.value = !0;
    }, l, { immediate: !1 });
    function v() {
      g(), d.value = !1, u.value = !0;
    }
    function y() {
      g(), u.value = !1;
    }
    function w() {
      m();
    }
    return lK({
      contentId: "",
      open: u,
      stateAttribute: p,
      trigger: f,
      onTriggerChange(x) {
        f.value = x;
      },
      onTriggerEnter() {
        r.isOpenDelayed.value ? w() : v();
      },
      onTriggerLeave() {
        i.value ? y() : g();
      },
      onOpen: v,
      onClose: y,
      disableHoverableContent: i,
      disableClosingTrigger: s,
      disabled: a,
      ignoreNonKeyboardFocus: c
    }), (x, b) => (E(), T(h(ec), null, {
      default: C(() => [
        D(x.$slots, "default", { open: h(u) })
      ]),
      _: 3
    }));
  }
}), uK = /* @__PURE__ */ I({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = Hf(), o = Z1();
    n.contentId || (n.contentId = St(void 0, "reka-tooltip-content"));
    const { forwardRef: r, currentElement: i } = ee(), s = R(!1), a = R(!1), l = L(() => n.disabled.value ? {} : {
      click: g,
      focus: p,
      pointermove: d,
      pointerleave: f,
      pointerdown: u,
      blur: m
    });
    be(() => {
      n.onTriggerChange(i.value);
    });
    function c() {
      setTimeout(() => {
        s.value = !1;
      }, 1);
    }
    function u() {
      s.value = !0, document.addEventListener("pointerup", c, { once: !0 });
    }
    function d(v) {
      v.pointerType !== "touch" && !a.value && !o.isPointerInTransitRef.value && (n.onTriggerEnter(), a.value = !0);
    }
    function f() {
      n.onTriggerLeave(), a.value = !1;
    }
    function p(v) {
      var y, w;
      s.value || n.ignoreNonKeyboardFocus.value && !((w = (y = v.target).matches) != null && w.call(y, ":focus-visible")) || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function g() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (v, y) => (E(), T(h(If), {
      "as-child": "",
      reference: v.reference
    }, {
      default: C(() => [
        _(h(ae), j({
          ref: h(r),
          "aria-describedby": h(n).open.value ? h(n).contentId : void 0,
          "data-state": h(n).stateAttribute.value,
          as: v.as,
          "as-child": e.asChild,
          "data-grace-area-trigger": ""
        }, o_(l.value)), {
          default: C(() => [
            D(v.$slots, "default")
          ]),
          _: 3
        }, 16, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }, 8, ["reference"]));
  }
}), Lk = /* @__PURE__ */ I({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hf(), { forwardRef: i } = ee(), s = r_(), a = L(() => {
      var u;
      return (u = s.default) == null ? void 0 : u.call(s, {});
    }), l = L(() => {
      var f;
      if (n.ariaLabel)
        return n.ariaLabel;
      let u = "";
      function d(p) {
        typeof p.children == "string" && p.type !== K2 ? u += p.children : Array.isArray(p.children) && p.children.forEach((m) => d(m));
      }
      return (f = a.value) == null || f.forEach((p) => d(p)), u;
    }), c = L(() => {
      const { ariaLabel: u, ...d } = n;
      return d;
    });
    return be(() => {
      Ts(window, "scroll", (u) => {
        const d = u.target;
        d != null && d.contains(r.trigger.value) && r.onClose();
      }), Ts(window, Pk, r.onClose);
    }), (u, d) => (E(), T(h(Ql), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: d[0] || (d[0] = (f) => o("escapeKeyDown", f)),
      onPointerDownOutside: d[1] || (d[1] = (f) => {
        var p;
        h(r).disableClosingTrigger.value && ((p = h(r).trigger.value) != null && p.contains(f.target)) && f.preventDefault(), o("pointerDownOutside", f);
      }),
      onFocusOutside: d[2] || (d[2] = mt(() => {
      }, ["prevent"])),
      onDismiss: d[3] || (d[3] = (f) => h(r).onClose())
    }, {
      default: C(() => [
        _(h(Rf), j({
          ref: h(i),
          "data-state": h(r).stateAttribute.value
        }, { ...u.$attrs, ...c.value }, { style: {
          "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
          "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
          "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
        } }), {
          default: C(() => [
            D(u.$slots, "default"),
            _(h(Jl), {
              id: h(r).contentId,
              role: "tooltip"
            }, {
              default: C(() => [
                ue(Y(l.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }));
  }
}), dK = /* @__PURE__ */ I({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  setup(t) {
    const n = vt(t), { forwardRef: o, currentElement: r } = ee(), { trigger: i, onClose: s } = Hf(), a = Z1(), { isPointerInTransit: l, onPointerExit: c } = oj(i, r);
    return a.isPointerInTransitRef = l, c(() => {
      s();
    }), (u, d) => (E(), T(Lk, j({ ref: h(o) }, h(n)), {
      default: C(() => [
        D(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fK = /* @__PURE__ */ I({
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hf(), i = Ie(n, o), { forwardRef: s } = ee();
    return (a, l) => (E(), T(h(rn), {
      present: a.forceMount || h(r).open.value
    }, {
      default: C(() => [
        (E(), T(An(h(r).disableHoverableContent.value ? Lk : dK), j({ ref: h(s) }, h(i)), {
          default: C(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), pK = /* @__PURE__ */ I({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Zl), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ho = /* @__PURE__ */ I({
  __name: "Separator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    label: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(lW), j(n.value, {
      class: h(ve)(
        "shrink-0 bg-border relative",
        e.orientation === "vertical" ? "w-px h-full" : "h-px w-full",
        e.class
      )
    }), {
      default: C(() => [
        e.label ? (E(), W("span", {
          key: 0,
          class: He(
            h(ve)(
              "text-xs text-muted-foreground bg-background absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex justify-center items-center",
              e.orientation === "vertical" ? "w-[1px] px-1 py-2" : "h-[1px] py-1 px-2"
            )
          )
        }, Y(e.label), 3)) : oe("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), hK = { class: "border border-neutral-200 dark:border-neutral-800 px-3 py-2 transition-all select-none pointer-events-auto shadow-sm rounded-sm bg-background w-auto max-w-[calc(-68px_+_100vw)] overflow-x-auto" }, mK = { class: "flex items-center flex-nowrap whitespace-nowrap h-[26px] justify-start relative gap-0.5" }, gK = /* @__PURE__ */ I({
  __name: "BasicBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = vn(), { t: o } = Ge(), r = hn({
      maxWidth: "auto",
      zIndex: 20,
      appendTo: "parent",
      moveTransition: "transform 0.15s ease-out"
    }), i = L(() => {
      var f;
      const l = e.editor.state.selection, c = e.editor.isActive("link"), u = ((f = l.node) == null ? void 0 : f.type.name) === "video", d = l instanceof ce;
      if (c) return "link";
      if (u) return "video";
      if (d) return "text";
    }), s = L(() => {
      var f;
      const { extensions: l = [] } = e.editor.extensionManager, c = l.find((p) => p.name === "base-kit");
      if (!c) return {};
      const { button: u } = ((f = c.options) == null ? void 0 : f.bubble) ?? {};
      return u ? u({
        editor: e.editor,
        extension: c,
        t: h(o)
      }) : {};
    }), a = L(() => {
      var l;
      return i.value ? ((l = h(s)) == null ? void 0 : l[i.value]) ?? [] : [];
    });
    return (l, c) => {
      var u;
      return Vn((E(), T(h(zs), {
        editor: l.editor,
        "tippy-options": r
      }, {
        default: C(() => [
          N("div", hK, [
            N("div", mK, [
              (E(!0), W(me, null, Oe(a.value, (d, f) => {
                var p;
                return E(), W(me, { key: f }, [
                  d.type === "divider" ? (E(), T(h(Ho), {
                    key: 0,
                    orientation: "vertical",
                    class: "mx-1 me-1 h-[16px]"
                  })) : (E(), T(An(d.component), j({
                    key: 1,
                    ref_for: !0
                  }, d.componentProps, {
                    editor: l.editor,
                    disabled: l.disabled || ((p = d.componentProps) == null ? void 0 : p.disabled)
                  }), J2({ _: 2 }, [
                    Oe(d.componentSlots, (m, g, v) => ({
                      name: `${g}`,
                      fn: C((y) => [
                        (E(), T(An(m), j({ ref_for: !0 }, y == null ? void 0 : y.props), null, 16))
                      ])
                    }))
                  ]), 1040, ["editor", "disabled"]))
                ], 64);
              }), 128))
            ])
          ])
        ]),
        _: 1
      }, 8, ["editor", "tippy-options"])), [
        [no, a.value.length && !((u = h(n)) != null && u.state.AIMenu)]
      ]);
    };
  }
});
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vK = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var zc = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yK = ({ size: t, strokeWidth: e = 2, absoluteStrokeWidth: n, color: o, iconNode: r, name: i, class: s, ...a }, { slots: l }) => Ot(
  "svg",
  {
    ...zc,
    width: t || zc.width,
    height: t || zc.height,
    stroke: o || zc.stroke,
    "stroke-width": n ? Number(e) * 24 / Number(t) : e,
    class: ["lucide", `lucide-${vK(i ?? "icon")}`],
    ...a
  },
  [...r.map((c) => Ot(...c)), ...l.default ? [l.default()] : []]
);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Xs = (t, e) => (n, { slots: o }) => Ot(
  yK,
  {
    ...n,
    iconNode: e,
    name: t
  },
  o
);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rc = Xs("CheckIcon", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Dk = Xs("ChevronDownIcon", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bK = Xs("ChevronRightIcon", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wK = Xs("ChevronUpIcon", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }]
]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xK = Xs("GripVerticalIcon", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Nk = Xs("XIcon", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), Bk = /* @__PURE__ */ I({
  __name: "Checkbox",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null] },
    disabled: { type: Boolean },
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(vU), j(h(i), {
      class: h(ve)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: C(() => [
        _(h(yU), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: C(() => [
            D(s.$slots, "default", {}, () => [
              _(h(rc), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CK = {
  Bold: "lucide:bold",
  LoaderCircle: "lucide:loader-circle",
  Italic: "lucide:italic",
  Underline: "lucide:underline",
  Quote: "lucide:quote",
  TextQuote: "lucide:text-quote",
  Strikethrough: "lucide:strikethrough",
  Minus: "lucide:minus",
  Eraser: "lucide:eraser",
  PaintRoller: "lucide:paint-roller",
  Redo2: "lucide:redo-2",
  Undo2: "lucide:undo-2",
  AlignCenter: "radix-icons:text-align-center",
  AlignJustify: "radix-icons:text-align-justify",
  AlignLeft: "radix-icons:text-align-left",
  AlignRight: "radix-icons:text-align-right",
  ChevronUp: "lucide:chevron-up",
  ChevronDown: "lucide:chevron-down",
  Subscript: "lucide:subscript",
  Superscript: "lucide:superscript",
  Code: "lucide:code",
  Code2: "lucide:code-2",
  Type: "lucide:type",
  IndentIncrease: "lucide:indent-increase",
  IndentDecrease: "lucide:indent-decrease",
  List: "lucide:list",
  ListOrdered: "lucide:list-ordered",
  ListTodo: "lucide:list-todo",
  Link: "lucide:link",
  ImageUp: "lucide:image-up",
  Video: "lucide:video",
  Maximize: "lucide:maximize",
  Minimize: "lucide:minimize",
  Table: "lucide:table",
  Sparkles: "lucide:sparkles",
  Magic: "mdi:magic",
  Pencil: "lucide:pencil",
  Unlink: "lucide:unlink",
  BetweenHorizonalEnd: "lucide:between-horizontal-end",
  BetweenHorizonalStart: "lucide:between-horizontal-start",
  ColumnDelete: "hugeicons:column-delete",
  BetweenVerticalStart: "lucide:between-vertical-start",
  BetweenVerticalEnd: "lucide:between-vertical-end",
  RowDelete: "hugeicons:row-delete",
  TableCellsMerge: "lucide:table-cells-merge",
  TableCellsSplit: "lucide:table-cells-split",
  Trash2: "lucide:trash-2",
  Trash: "lucide:trash",
  Replace: "lucide:replace",
  ChevronsUpDown: "lucide:chevrons-up-down",
  LineHeight: "mdi:format-line-height",
  Word: "mdi:file-word-outline",
  Paragraph: "ci:text",
  Heading1: "lucide:heading-1",
  Heading2: "lucide:heading-2",
  Heading3: "lucide:heading-3",
  Columns2: "lucide:columns-2",
  Columns3: "lucide:columns-3",
  Columns4: "lucide:columns-4",
  Plus: "lucide:plus",
  Grip: "lucide:grip-vertical",
  Copy: "lucide:copy",
  Clipboard: "lucide:clipboard",
  MenuDown: "icon-park-solid:down-one",
  SizeS: "mdi:size-s",
  SizeM: "mdi:size-m",
  SizeL: "mdi:size-l",
  AspectRatio: "mdi:aspect-ratio",
  Gaode: "echo-gaode",
  Baidu: "echo-baidu",
  Youku: "echo-youku",
  BiliBili: "echo-bilibili",
  Modao: "echo-modao",
  Lanhu: "echo-lanhu",
  QQVideo: "echo-qqvideo",
  Figma: "echo-figma",
  Canva: "echo-canva",
  Processon: "echo-processon",
  Codepen: "echo-codepen",
  Jinshuju: "echo-jinshuju",
  PanelLeft: "lucide:panel-left",
  PanelRight: "lucide:panel-right",
  Columns: "lucide:columns",
  AI: "meteocons:star-fill",
  ChevronRight: "lucide:chevron-right",
  ArrowUp: "lucide:arrow-up",
  Paste: "lucide:clipboard-paste",
  Cut: "lucide:scissors",
  File: "lucide:file",
  Refresh: "lucide:refresh-ccw",
  Eye: "lucide:eye",
  Printer: "lucide:printer",
  Tablet: "lucide:tablet",
  Phone: "lucide:smartphone",
  Monitor: "lucide:monitor",
  TextSelect: "lucide:text-select",
  SpellCheck: "lucide:spell-check-2",
  DocSearch: "lucide:text-search",
  Close: "lucide:x",
  ImageSize: "fluent:resize-image-24-filled",
  FlipVertical: "lucide:flip-vertical",
  FlipHorizontal: "lucide:flip-horizontal",
  WrapText: "lucide:wrap-text"
};
function Yo(...t) {
  return g4(C1(t));
}
const Fk = /^[a-z0-9]+(-[a-z0-9]+)*$/, Vf = (t, e, n, o = "") => {
  const r = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (r.length < 2 || r.length > 3)
      return null;
    o = r.shift().slice(1);
  }
  if (r.length > 3 || !r.length)
    return null;
  if (r.length > 1) {
    const a = r.pop(), l = r.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: r.length > 0 ? r[0] : o,
      prefix: l,
      name: a
    };
    return e && !mu(c) ? null : c;
  }
  const i = r[0], s = i.split("-");
  if (s.length > 1) {
    const a = {
      provider: o,
      prefix: s.shift(),
      name: s.join("-")
    };
    return e && !mu(a) ? null : a;
  }
  if (n && o === "") {
    const a = {
      provider: o,
      prefix: "",
      name: i
    };
    return e && !mu(a, n) ? null : a;
  }
  return null;
}, mu = (t, e) => t ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((e && t.prefix === "" || t.prefix) && t.name) : !1, zk = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), od = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), Uf = Object.freeze({
  ...zk,
  ...od
}), Rm = Object.freeze({
  ...Uf,
  body: "",
  hidden: !1
});
function SK(t, e) {
  const n = {};
  !t.hFlip != !e.hFlip && (n.hFlip = !0), !t.vFlip != !e.vFlip && (n.vFlip = !0);
  const o = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return o && (n.rotate = o), n;
}
function Fb(t, e) {
  const n = SK(t, e);
  for (const o in Rm)
    o in od ? o in t && !(o in n) && (n[o] = od[o]) : o in e ? n[o] = e[o] : o in t && (n[o] = t[o]);
  return n;
}
function kK(t, e) {
  const n = t.icons, o = t.aliases || /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function i(s) {
    if (n[s])
      return r[s] = [];
    if (!(s in r)) {
      r[s] = null;
      const a = o[s] && o[s].parent, l = a && i(a);
      l && (r[s] = [a].concat(l));
    }
    return r[s];
  }
  return Object.keys(n).concat(Object.keys(o)).forEach(i), r;
}
function EK(t, e, n) {
  const o = t.icons, r = t.aliases || /* @__PURE__ */ Object.create(null);
  let i = {};
  function s(a) {
    i = Fb(
      o[a] || r[a],
      i
    );
  }
  return s(e), n.forEach(s), Fb(t, i);
}
function Hk(t, e) {
  const n = [];
  if (typeof t != "object" || typeof t.icons != "object")
    return n;
  t.not_found instanceof Array && t.not_found.forEach((r) => {
    e(r, null), n.push(r);
  });
  const o = kK(t);
  for (const r in o) {
    const i = o[r];
    i && (e(r, EK(t, r, i)), n.push(r));
  }
  return n;
}
const _K = {
  provider: "",
  aliases: {},
  not_found: {},
  ...zk
};
function Wp(t, e) {
  for (const n in e)
    if (n in t && typeof t[n] != typeof e[n])
      return !1;
  return !0;
}
function Vk(t) {
  if (typeof t != "object" || t === null)
    return null;
  const e = t;
  if (typeof e.prefix != "string" || !t.icons || typeof t.icons != "object" || !Wp(t, _K))
    return null;
  const n = e.icons;
  for (const r in n) {
    const i = n[r];
    if (
      // Name cannot be empty
      !r || // Must have body
      typeof i.body != "string" || // Check other props
      !Wp(
        i,
        Rm
      )
    )
      return null;
  }
  const o = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const r in o) {
    const i = o[r], s = i.parent;
    if (
      // Name cannot be empty
      !r || // Parent must be set and point to existing icon
      typeof s != "string" || !n[s] && !o[s] || // Check other props
      !Wp(
        i,
        Rm
      )
    )
      return null;
  }
  return e;
}
const zb = /* @__PURE__ */ Object.create(null);
function AK(t, e) {
  return {
    provider: t,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Ms(t, e) {
  const n = zb[t] || (zb[t] = /* @__PURE__ */ Object.create(null));
  return n[e] || (n[e] = AK(t, e));
}
function Uk(t, e) {
  return Vk(e) ? Hk(e, (n, o) => {
    o ? t.icons[n] = o : t.missing.add(n);
  }) : [];
}
function TK(t, e, n) {
  try {
    if (typeof n.body == "string")
      return t.icons[e] = { ...n }, !0;
  } catch {
  }
  return !1;
}
let Sl = !1;
function jk(t) {
  return typeof t == "boolean" && (Sl = t), Sl;
}
function OK(t) {
  const e = typeof t == "string" ? Vf(t, !0, Sl) : t;
  if (e) {
    const n = Ms(e.provider, e.prefix), o = e.name;
    return n.icons[o] || (n.missing.has(o) ? null : void 0);
  }
}
function MK(t, e) {
  const n = Vf(t, !0, Sl);
  if (!n)
    return !1;
  const o = Ms(n.provider, n.prefix);
  return e ? TK(o, n.name, e) : (o.missing.add(n.name), !0);
}
function Wk(t, e) {
  if (typeof t != "object")
    return !1;
  if (typeof e != "string" && (e = t.provider || ""), Sl && !e && !t.prefix) {
    let r = !1;
    return Vk(t) && (t.prefix = "", Hk(t, (i, s) => {
      MK(i, s) && (r = !0);
    })), r;
  }
  const n = t.prefix;
  if (!mu({
    prefix: n,
    name: "a"
  }))
    return !1;
  const o = Ms(e, n);
  return !!Uk(o, t);
}
const Kk = Object.freeze({
  width: null,
  height: null
}), Gk = Object.freeze({
  // Dimensions
  ...Kk,
  // Transformations
  ...od
}), IK = /(-?[0-9.]*[0-9]+[0-9.]*)/g, RK = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Hb(t, e, n) {
  if (e === 1)
    return t;
  if (n = n || 100, typeof t == "number")
    return Math.ceil(t * e * n) / n;
  if (typeof t != "string")
    return t;
  const o = t.split(IK);
  if (o === null || !o.length)
    return t;
  const r = [];
  let i = o.shift(), s = RK.test(i);
  for (; ; ) {
    if (s) {
      const a = parseFloat(i);
      isNaN(a) ? r.push(i) : r.push(Math.ceil(a * e * n) / n);
    } else
      r.push(i);
    if (i = o.shift(), i === void 0)
      return r.join("");
    s = !s;
  }
}
function $K(t, e = "defs") {
  let n = "";
  const o = t.indexOf("<" + e);
  for (; o >= 0; ) {
    const r = t.indexOf(">", o), i = t.indexOf("</" + e);
    if (r === -1 || i === -1)
      break;
    const s = t.indexOf(">", i);
    if (s === -1)
      break;
    n += t.slice(r + 1, i).trim(), t = t.slice(0, o).trim() + t.slice(s + 1);
  }
  return {
    defs: n,
    content: t
  };
}
function PK(t, e) {
  return t ? "<defs>" + t + "</defs>" + e : e;
}
function LK(t, e, n) {
  const o = $K(t);
  return PK(o.defs, e + o.content + n);
}
const DK = (t) => t === "unset" || t === "undefined" || t === "none";
function NK(t, e) {
  const n = {
    ...Uf,
    ...t
  }, o = {
    ...Gk,
    ...e
  }, r = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let i = n.body;
  [n, o].forEach((g) => {
    const v = [], y = g.hFlip, w = g.vFlip;
    let x = g.rotate;
    y ? w ? x += 2 : (v.push(
      "translate(" + (r.width + r.left).toString() + " " + (0 - r.top).toString() + ")"
    ), v.push("scale(-1 1)"), r.top = r.left = 0) : w && (v.push(
      "translate(" + (0 - r.left).toString() + " " + (r.height + r.top).toString() + ")"
    ), v.push("scale(1 -1)"), r.top = r.left = 0);
    let b;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        b = r.height / 2 + r.top, v.unshift(
          "rotate(90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
      case 2:
        v.unshift(
          "rotate(180 " + (r.width / 2 + r.left).toString() + " " + (r.height / 2 + r.top).toString() + ")"
        );
        break;
      case 3:
        b = r.width / 2 + r.left, v.unshift(
          "rotate(-90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
    }
    x % 2 === 1 && (r.left !== r.top && (b = r.left, r.left = r.top, r.top = b), r.width !== r.height && (b = r.width, r.width = r.height, r.height = b)), v.length && (i = LK(
      i,
      '<g transform="' + v.join(" ") + '">',
      "</g>"
    ));
  });
  const s = o.width, a = o.height, l = r.width, c = r.height;
  let u, d;
  s === null ? (d = a === null ? "1em" : a === "auto" ? c : a, u = Hb(d, l / c)) : (u = s === "auto" ? l : s, d = a === null ? Hb(u, c / l) : a === "auto" ? c : a);
  const f = {}, p = (g, v) => {
    DK(v) || (f[g] = v.toString());
  };
  p("width", u), p("height", d);
  const m = [r.left, r.top, l, c];
  return f.viewBox = m.join(" "), {
    attributes: f,
    viewBox: m,
    body: i
  };
}
const BK = /\sid="(\S+)"/g, FK = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let zK = 0;
function HK(t, e = FK) {
  const n = [];
  let o;
  for (; o = BK.exec(t); )
    n.push(o[1]);
  if (!n.length)
    return t;
  const r = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((i) => {
    const s = typeof e == "function" ? e(i) : e + (zK++).toString(), a = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"),
      "$1" + s + r + "$3"
    );
  }), t = t.replace(new RegExp(r, "g"), ""), t;
}
const $m = /* @__PURE__ */ Object.create(null);
function VK(t, e) {
  $m[t] = e;
}
function Pm(t) {
  return $m[t] || $m[""];
}
function Q1(t) {
  let e;
  if (typeof t.resources == "string")
    e = [t.resources];
  else if (e = t.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: t.path || "/",
    // URL length limit
    maxURL: t.maxURL || 500,
    // Timeout before next host is used.
    rotate: t.rotate || 750,
    // Timeout before failing query.
    timeout: t.timeout || 5e3,
    // Randomise default API end point.
    random: t.random === !0,
    // Start index
    index: t.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: t.dataAfterTimeout !== !1
  };
}
const ev = /* @__PURE__ */ Object.create(null), xa = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], gu = [];
for (; xa.length > 0; )
  xa.length === 1 || Math.random() > 0.5 ? gu.push(xa.shift()) : gu.push(xa.pop());
ev[""] = Q1({
  resources: ["https://api.iconify.design"].concat(gu)
});
function UK(t, e) {
  const n = Q1(e);
  return n === null ? !1 : (ev[t] = n, !0);
}
function tv(t) {
  return ev[t];
}
const jK = () => {
  let t;
  try {
    if (t = fetch, typeof t == "function")
      return t;
  } catch {
  }
};
let Vb = jK();
function WK(t, e) {
  const n = tv(t);
  if (!n)
    return 0;
  let o;
  if (!n.maxURL)
    o = 0;
  else {
    let r = 0;
    n.resources.forEach((s) => {
      r = Math.max(r, s.length);
    });
    const i = e + ".json?icons=";
    o = n.maxURL - r - n.path.length - i.length;
  }
  return o;
}
function KK(t) {
  return t === 404;
}
const GK = (t, e, n) => {
  const o = [], r = WK(t, e), i = "icons";
  let s = {
    type: i,
    provider: t,
    prefix: e,
    icons: []
  }, a = 0;
  return n.forEach((l, c) => {
    a += l.length + 1, a >= r && c > 0 && (o.push(s), s = {
      type: i,
      provider: t,
      prefix: e,
      icons: []
    }, a = l.length), s.icons.push(l);
  }), o.push(s), o;
};
function qK(t) {
  if (typeof t == "string") {
    const e = tv(t);
    if (e)
      return e.path;
  }
  return "/";
}
const YK = (t, e, n) => {
  if (!Vb) {
    n("abort", 424);
    return;
  }
  let o = qK(e.provider);
  switch (e.type) {
    case "icons": {
      const i = e.prefix, a = e.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      o += i + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const i = e.uri;
      o += i.slice(0, 1) === "/" ? i.slice(1) : i;
      break;
    }
    default:
      n("abort", 400);
      return;
  }
  let r = 503;
  Vb(t + o).then((i) => {
    const s = i.status;
    if (s !== 200) {
      setTimeout(() => {
        n(KK(s) ? "abort" : "next", s);
      });
      return;
    }
    return r = 501, i.json();
  }).then((i) => {
    if (typeof i != "object" || i === null) {
      setTimeout(() => {
        i === 404 ? n("abort", i) : n("next", r);
      });
      return;
    }
    setTimeout(() => {
      n("success", i);
    });
  }).catch(() => {
    n("next", r);
  });
}, JK = {
  prepare: GK,
  send: YK
};
function XK(t) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, n = /* @__PURE__ */ Object.create(null);
  t.sort((r, i) => r.provider !== i.provider ? r.provider.localeCompare(i.provider) : r.prefix !== i.prefix ? r.prefix.localeCompare(i.prefix) : r.name.localeCompare(i.name));
  let o = {
    provider: "",
    prefix: "",
    name: ""
  };
  return t.forEach((r) => {
    if (o.name === r.name && o.prefix === r.prefix && o.provider === r.provider)
      return;
    o = r;
    const i = r.provider, s = r.prefix, a = r.name, l = n[i] || (n[i] = /* @__PURE__ */ Object.create(null)), c = l[s] || (l[s] = Ms(i, s));
    let u;
    a in c.icons ? u = e.loaded : s === "" || c.missing.has(a) ? u = e.missing : u = e.pending;
    const d = {
      provider: i,
      prefix: s,
      name: a
    };
    u.push(d);
  }), e;
}
function qk(t, e) {
  t.forEach((n) => {
    const o = n.loaderCallbacks;
    o && (n.loaderCallbacks = o.filter((r) => r.id !== e));
  });
}
function ZK(t) {
  t.pendingCallbacksFlag || (t.pendingCallbacksFlag = !0, setTimeout(() => {
    t.pendingCallbacksFlag = !1;
    const e = t.loaderCallbacks ? t.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let n = !1;
    const o = t.provider, r = t.prefix;
    e.forEach((i) => {
      const s = i.icons, a = s.pending.length;
      s.pending = s.pending.filter((l) => {
        if (l.prefix !== r)
          return !0;
        const c = l.name;
        if (t.icons[c])
          s.loaded.push({
            provider: o,
            prefix: r,
            name: c
          });
        else if (t.missing.has(c))
          s.missing.push({
            provider: o,
            prefix: r,
            name: c
          });
        else
          return n = !0, !0;
        return !1;
      }), s.pending.length !== a && (n || qk([t], i.id), i.callback(
        s.loaded.slice(0),
        s.missing.slice(0),
        s.pending.slice(0),
        i.abort
      ));
    });
  }));
}
let QK = 0;
function eG(t, e, n) {
  const o = QK++, r = qk.bind(null, n, o);
  if (!e.pending.length)
    return r;
  const i = {
    id: o,
    icons: e,
    callback: t,
    abort: r
  };
  return n.forEach((s) => {
    (s.loaderCallbacks || (s.loaderCallbacks = [])).push(i);
  }), r;
}
function tG(t, e = !0, n = !1) {
  const o = [];
  return t.forEach((r) => {
    const i = typeof r == "string" ? Vf(r, e, n) : r;
    i && o.push(i);
  }), o;
}
var nG = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function oG(t, e, n, o) {
  const r = t.resources.length, i = t.random ? Math.floor(Math.random() * r) : t.index;
  let s;
  if (t.random) {
    let k = t.resources.slice(0);
    for (s = []; k.length > 1; ) {
      const A = Math.floor(Math.random() * k.length);
      s.push(k[A]), k = k.slice(0, A).concat(k.slice(A + 1));
    }
    s = s.concat(k);
  } else
    s = t.resources.slice(i).concat(t.resources.slice(0, i));
  const a = Date.now();
  let l = "pending", c = 0, u, d = null, f = [], p = [];
  typeof o == "function" && p.push(o);
  function m() {
    d && (clearTimeout(d), d = null);
  }
  function g() {
    l === "pending" && (l = "aborted"), m(), f.forEach((k) => {
      k.status === "pending" && (k.status = "aborted");
    }), f = [];
  }
  function v(k, A) {
    A && (p = []), typeof k == "function" && p.push(k);
  }
  function y() {
    return {
      startTime: a,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: f.length,
      subscribe: v,
      abort: g
    };
  }
  function w() {
    l = "failed", p.forEach((k) => {
      k(void 0, u);
    });
  }
  function x() {
    f.forEach((k) => {
      k.status === "pending" && (k.status = "aborted");
    }), f = [];
  }
  function b(k, A, $) {
    const O = A !== "success";
    switch (f = f.filter((M) => M !== k), l) {
      case "pending":
        break;
      case "failed":
        if (O || !t.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (A === "abort") {
      u = $, w();
      return;
    }
    if (O) {
      u = $, f.length || (s.length ? S() : w());
      return;
    }
    if (m(), x(), !t.random) {
      const M = t.resources.indexOf(k.resource);
      M !== -1 && M !== t.index && (t.index = M);
    }
    l = "completed", p.forEach((M) => {
      M($);
    });
  }
  function S() {
    if (l !== "pending")
      return;
    m();
    const k = s.shift();
    if (k === void 0) {
      if (f.length) {
        d = setTimeout(() => {
          m(), l === "pending" && (x(), w());
        }, t.timeout);
        return;
      }
      w();
      return;
    }
    const A = {
      status: "pending",
      resource: k,
      callback: ($, O) => {
        b(A, $, O);
      }
    };
    f.push(A), c++, d = setTimeout(S, t.rotate), n(k, e, A.callback);
  }
  return setTimeout(S), y;
}
function Yk(t) {
  const e = {
    ...nG,
    ...t
  };
  let n = [];
  function o() {
    n = n.filter((a) => a().status === "pending");
  }
  function r(a, l, c) {
    const u = oG(
      e,
      a,
      l,
      (d, f) => {
        o(), c && c(d, f);
      }
    );
    return n.push(u), u;
  }
  function i(a) {
    return n.find((l) => a(l)) || null;
  }
  return {
    query: r,
    find: i,
    setIndex: (a) => {
      e.index = a;
    },
    getIndex: () => e.index,
    cleanup: o
  };
}
function Ub() {
}
const Kp = /* @__PURE__ */ Object.create(null);
function rG(t) {
  if (!Kp[t]) {
    const e = tv(t);
    if (!e)
      return;
    const n = Yk(e), o = {
      config: e,
      redundancy: n
    };
    Kp[t] = o;
  }
  return Kp[t];
}
function iG(t, e, n) {
  let o, r;
  if (typeof t == "string") {
    const i = Pm(t);
    if (!i)
      return n(void 0, 424), Ub;
    r = i.send;
    const s = rG(t);
    s && (o = s.redundancy);
  } else {
    const i = Q1(t);
    if (i) {
      o = Yk(i);
      const s = t.resources ? t.resources[0] : "", a = Pm(s);
      a && (r = a.send);
    }
  }
  return !o || !r ? (n(void 0, 424), Ub) : o.query(e, r, n)().abort;
}
function jb() {
}
function sG(t) {
  t.iconsLoaderFlag || (t.iconsLoaderFlag = !0, setTimeout(() => {
    t.iconsLoaderFlag = !1, ZK(t);
  }));
}
function aG(t) {
  const e = [], n = [];
  return t.forEach((o) => {
    (o.match(Fk) ? e : n).push(o);
  }), {
    valid: e,
    invalid: n
  };
}
function Ca(t, e, n) {
  function o() {
    const r = t.pendingIcons;
    e.forEach((i) => {
      r && r.delete(i), t.icons[i] || t.missing.add(i);
    });
  }
  if (n && typeof n == "object")
    try {
      if (!Uk(t, n).length) {
        o();
        return;
      }
    } catch (r) {
      console.error(r);
    }
  o(), sG(t);
}
function Wb(t, e) {
  t instanceof Promise ? t.then((n) => {
    e(n);
  }).catch(() => {
    e(null);
  }) : e(t);
}
function lG(t, e) {
  t.iconsToLoad ? t.iconsToLoad = t.iconsToLoad.concat(e).sort() : t.iconsToLoad = e, t.iconsQueueFlag || (t.iconsQueueFlag = !0, setTimeout(() => {
    t.iconsQueueFlag = !1;
    const { provider: n, prefix: o } = t, r = t.iconsToLoad;
    if (delete t.iconsToLoad, !r || !r.length)
      return;
    const i = t.loadIcon;
    if (t.loadIcons && (r.length > 1 || !i)) {
      Wb(
        t.loadIcons(r, o, n),
        (u) => {
          Ca(t, r, u);
        }
      );
      return;
    }
    if (i) {
      r.forEach((u) => {
        const d = i(u, o, n);
        Wb(d, (f) => {
          const p = f ? {
            prefix: o,
            icons: {
              [u]: f
            }
          } : null;
          Ca(t, [u], p);
        });
      });
      return;
    }
    const { valid: s, invalid: a } = aG(r);
    if (a.length && Ca(t, a, null), !s.length)
      return;
    const l = o.match(Fk) ? Pm(n) : null;
    if (!l) {
      Ca(t, s, null);
      return;
    }
    l.prepare(n, o, s).forEach((u) => {
      iG(n, u, (d) => {
        Ca(t, u.icons, d);
      });
    });
  }));
}
const cG = (t, e) => {
  const n = tG(t, !0, jk()), o = XK(n);
  if (!o.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        o.loaded,
        o.missing,
        o.pending,
        jb
      );
    }), () => {
      l = !1;
    };
  }
  const r = /* @__PURE__ */ Object.create(null), i = [];
  let s, a;
  return o.pending.forEach((l) => {
    const { provider: c, prefix: u } = l;
    if (u === a && c === s)
      return;
    s = c, a = u, i.push(Ms(c, u));
    const d = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
    d[u] || (d[u] = []);
  }), o.pending.forEach((l) => {
    const { provider: c, prefix: u, name: d } = l, f = Ms(c, u), p = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    p.has(d) || (p.add(d), r[c][u].push(d));
  }), i.forEach((l) => {
    const c = r[l.provider][l.prefix];
    c.length && lG(l, c);
  }), e ? eG(e, o, i) : jb;
};
function uG(t, e) {
  const n = {
    ...t
  };
  for (const o in e) {
    const r = e[o], i = typeof r;
    o in Kk ? (r === null || r && (i === "string" || i === "number")) && (n[o] = r) : i === typeof n[o] && (n[o] = o === "rotate" ? r % 4 : r);
  }
  return n;
}
const dG = /[\s,]+/;
function fG(t, e) {
  e.split(dG).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        t.hFlip = !0;
        break;
      case "vertical":
        t.vFlip = !0;
        break;
    }
  });
}
function pG(t, e = 0) {
  const n = t.replace(/^-?[0-9.]*/, "");
  function o(r) {
    for (; r < 0; )
      r += 4;
    return r % 4;
  }
  if (n === "") {
    const r = parseInt(t);
    return isNaN(r) ? 0 : o(r);
  } else if (n !== t) {
    let r = 0;
    switch (n) {
      case "%":
        r = 25;
        break;
      case "deg":
        r = 90;
    }
    if (r) {
      let i = parseFloat(t.slice(0, t.length - n.length));
      return isNaN(i) ? 0 : (i = i / r, i % 1 === 0 ? o(i) : 0);
    }
  }
  return e;
}
function hG(t, e) {
  let n = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const o in e)
    n += " " + o + '="' + e[o] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + t + "</svg>";
}
function mG(t) {
  return t.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function gG(t) {
  return "data:image/svg+xml," + mG(t);
}
function vG(t) {
  return 'url("' + gG(t) + '")';
}
const Kb = {
  ...Gk,
  inline: !1
}, yG = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, bG = {
  display: "inline-block"
}, Lm = {
  backgroundColor: "currentColor"
}, Jk = {
  backgroundColor: "transparent"
}, Gb = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, qb = {
  webkitMask: Lm,
  mask: Lm,
  background: Jk
};
for (const t in qb) {
  const e = qb[t];
  for (const n in Gb)
    e[t + n] = Gb[n];
}
const vu = {};
["horizontal", "vertical"].forEach((t) => {
  const e = t.slice(0, 1) + "Flip";
  vu[t + "-flip"] = e, vu[t.slice(0, 1) + "-flip"] = e, vu[t + "Flip"] = e;
});
function Yb(t) {
  return t + (t.match(/^[-0-9.]+$/) ? "px" : "");
}
const Jb = (t, e) => {
  const n = uG(Kb, e), o = { ...yG }, r = e.mode || "svg", i = {}, s = e.style, a = typeof s == "object" && !(s instanceof Array) ? s : {};
  for (let g in e) {
    const v = e[g];
    if (v !== void 0)
      switch (g) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
        case "ssr":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          n[g] = v === !0 || v === "true" || v === 1;
          break;
        case "flip":
          typeof v == "string" && fG(n, v);
          break;
        case "color":
          i.color = v;
          break;
        case "rotate":
          typeof v == "string" ? n[g] = pG(v) : typeof v == "number" && (n[g] = v);
          break;
        case "ariaHidden":
        case "aria-hidden":
          v !== !0 && v !== "true" && delete o["aria-hidden"];
          break;
        default: {
          const y = vu[g];
          y ? (v === !0 || v === "true" || v === 1) && (n[y] = !0) : Kb[g] === void 0 && (o[g] = v);
        }
      }
  }
  const l = NK(t, n), c = l.attributes;
  if (n.inline && (i.verticalAlign = "-0.125em"), r === "svg") {
    o.style = {
      ...i,
      ...a
    }, Object.assign(o, c);
    let g = 0, v = e.id;
    return typeof v == "string" && (v = v.replace(/-/g, "_")), o.innerHTML = HK(l.body, v ? () => v + "ID" + g++ : "iconifyVue"), Ot("svg", o);
  }
  const { body: u, width: d, height: f } = t, p = r === "mask" || (r === "bg" ? !1 : u.indexOf("currentColor") !== -1), m = hG(u, {
    ...c,
    width: d + "",
    height: f + ""
  });
  return o.style = {
    ...i,
    "--svg": vG(m),
    width: Yb(c.width),
    height: Yb(c.height),
    ...bG,
    ...p ? Lm : Jk,
    ...a
  }, Ot("span", o);
};
jk(!0);
VK("", JK);
if (typeof document < "u" && typeof window < "u") {
  const t = window;
  if (t.IconifyPreload !== void 0) {
    const e = t.IconifyPreload, n = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((o) => {
      try {
        // Check if item is an object and not null/array
        (typeof o != "object" || o === null || o instanceof Array || // Check for 'icons' and 'prefix'
        typeof o.icons != "object" || typeof o.prefix != "string" || // Add icon set
        !Wk(o)) && console.error(n);
      } catch {
        console.error(n);
      }
    });
  }
  if (t.IconifyProviders !== void 0) {
    const e = t.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let n in e) {
        const o = "IconifyProviders[" + n + "] is invalid.";
        try {
          const r = e[n];
          if (typeof r != "object" || !r || r.resources === void 0)
            continue;
          UK(n, r) || console.error(o);
        } catch {
          console.error(o);
        }
      }
  }
}
const wG = {
  ...Uf,
  body: ""
}, xG = I({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Set initial data
  data() {
    return {
      // Current icon name
      _name: "",
      // Loading
      _loadingIcon: null,
      // Mounted status
      iconMounted: !1,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this.iconMounted = !0;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(t, e, n) {
      if (typeof t == "object" && t !== null && typeof t.body == "string")
        return this._name = "", this.abortLoading(), {
          data: t
        };
      let o;
      if (typeof t != "string" || (o = Vf(t, !1, !0)) === null)
        return this.abortLoading(), null;
      let r = OK(o);
      if (!r)
        return (!this._loadingIcon || this._loadingIcon.name !== t) && (this.abortLoading(), this._name = "", r !== null && (this._loadingIcon = {
          name: t,
          abort: cG([o], () => {
            this.counter++;
          })
        })), null;
      if (this.abortLoading(), this._name !== t && (this._name = t, e && e(t)), n) {
        r = Object.assign({}, r);
        const s = n(r.body, o.name, o.prefix, o.provider);
        typeof s == "string" && (r.body = s);
      }
      const i = ["iconify"];
      return o.prefix !== "" && i.push("iconify--" + o.prefix), o.provider !== "" && i.push("iconify--" + o.provider), { data: r, classes: i };
    }
  },
  // Render icon
  render() {
    this.counter;
    const t = this.$attrs, e = this.iconMounted || t.ssr ? this.getIcon(t.icon, t.onLoad, t.customise) : null;
    if (!e)
      return Jb(wG, t);
    let n = t;
    return e.classes && (n = {
      ...t,
      class: (typeof t.class == "string" ? t.class + " " : "") + e.classes.join(" ")
    }), Jb({
      ...Uf,
      ...e.data
    }, n);
  }
}), ye = /* @__PURE__ */ I({
  __name: "Icon",
  props: {
    name: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => CK[e.name]);
    return n.value || console.error(`Icon ${e.name} not found`), (o, r) => (E(), T(h(xG), {
      icon: n.value,
      class: He(h(Yo)("w-4 h-4", e.class))
    }, null, 8, ["icon", "class"]));
  }
}), Mr = /* @__PURE__ */ I({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, r = dz(n, "modelValue", e, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (i, s) => Vn((E(), W("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (a) => No(r) ? r.value = a : null),
      class: He(h(ve)("flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50", n.class))
    }, null, 2)), [
      [i_, h(r)]
    ]);
  }
}), Ua = /* @__PURE__ */ I({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(uj), j(n.value, {
      class: h(ve)(
        "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        e.class
      )
    }), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Xb = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, Zb = C1, nv = (t, e) => (n) => {
  var o;
  if ((e == null ? void 0 : e.variants) == null) return Zb(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: r, defaultVariants: i } = e, s = Object.keys(r).map((c) => {
    const u = n == null ? void 0 : n[c], d = i == null ? void 0 : i[c];
    if (u === null) return null;
    const f = Xb(u) || Xb(d);
    return r[c][f];
  }), a = n && Object.entries(n).reduce((c, u) => {
    let [d, f] = u;
    return f === void 0 || (c[d] = f), c;
  }, {}), l = e == null || (o = e.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((c, u) => {
    let { class: d, className: f, ...p } = u;
    return Object.entries(p).every((m) => {
      let [g, v] = m;
      return Array.isArray(v) ? v.includes({
        ...i,
        ...a
      }[g]) : {
        ...i,
        ...a
      }[g] === v;
    }) ? [
      ...c,
      d,
      f
    ] : c;
  }, []);
  return Zb(t, s, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
}, Rt = /* @__PURE__ */ I({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(ae), {
      as: n.as,
      "as-child": n.asChild,
      class: He(h(ve)(h(CG)({ variant: n.variant, size: n.size }), e.class))
    }, {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), CG = nv(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), SG = { class: "flex w-full max-w-sm items-center gap-1.5" }, kG = { class: "relative w-full max-w-sm items-center" }, EG = { class: "flex w-full max-w-sm items-center gap-1.5" }, _G = { class: "relative w-full max-w-sm items-center" }, AG = { class: "absolute start-0 inset-y-0 flex items-center justify-center px-2" }, TG = { class: "flex items-center space-x-2 mt-1" }, Xk = /* @__PURE__ */ I({
  __name: "LinkEditBlock",
  props: {
    editor: {}
  },
  emits: ["onSetLink", "onClickOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, { t: r } = Ge();
    let i = hn({
      text: "",
      link: ""
    });
    const s = R(null), { focused: a } = b1(s), l = R(!1), c = R(null);
    GF(c, (d) => o("onClickOutside", d)), Ve(() => {
      const { href: d, target: f } = n.editor.getAttributes("link"), { from: p, to: m } = n.editor.state.selection, g = n.editor.state.doc.textBetween(p, m, " ");
      i = {
        link: d,
        text: g
      }, l.value = f === "_blank";
    });
    function u() {
      o("onSetLink", i.link, i.text, l.value);
    }
    return be(() => {
      a.value = !0;
    }), (d, f) => {
      const p = Bk;
      return E(), W("div", {
        ref_key: "target",
        ref: c,
        class: "p-2 bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800"
      }, [
        N("form", {
          onSubmit: mt(u, ["prevent"]),
          class: "flex flex-col gap-2"
        }, [
          _(h(Ua), null, {
            default: C(() => [
              ue(Y(h(r)("editor.link.dialog.text")), 1)
            ]),
            _: 1
          }),
          N("div", SG, [
            N("div", kG, [
              _(h(Mr), {
                type: "text",
                modelValue: h(i).text,
                "onUpdate:modelValue": f[0] || (f[0] = (m) => h(i).text = m),
                required: "",
                class: "w-80",
                placeholder: "输入文本"
              }, null, 8, ["modelValue"])
            ])
          ]),
          _(h(Ua), null, {
            default: C(() => [
              ue(Y(h(r)("editor.link.dialog.link")), 1)
            ]),
            _: 1
          }),
          N("div", EG, [
            N("div", _G, [
              _(h(Mr), {
                type: "url",
                ref_key: "inputRef",
                ref: s,
                modelValue: h(i).link,
                "onUpdate:modelValue": f[1] || (f[1] = (m) => h(i).link = m),
                required: "",
                class: "pl-10"
              }, null, 8, ["modelValue"]),
              N("span", AG, [
                _(h(ye), {
                  class: "size-5 text-muted-foreground",
                  name: "Link"
                })
              ])
            ])
          ]),
          N("div", TG, [
            _(p, {
              checked: l.value,
              "onUpdate:checked": f[2] || (f[2] = (m) => l.value = m),
              id: "openInNewTab"
            }, null, 8, ["checked"]),
            _(h(Ua), { for: "openInNewTab" }, {
              default: C(() => [
                ue(Y(h(r)("editor.link.dialog.openInNewTab")), 1)
              ]),
              _: 1
            })
          ]),
          _(h(Rt), {
            type: "submit",
            class: "mt-2 self-end"
          }, {
            default: C(() => [
              ue(Y(h(r)("editor.link.dialog.button.apply")), 1)
            ]),
            _: 1
          })
        ], 32)
      ], 512);
    };
  }
});
let Gp;
function qp() {
  return Gp === void 0 && (Gp = navigator.platform.includes("Mac")), Gp;
}
function jf(t) {
  return t.toLowerCase() === "mod" ? qp() ? "⌘" : "Ctrl" : t.toLowerCase() === "alt" ? qp() ? "⌥" : "Alt" : t.toLowerCase() === "shift" ? qp() ? "⇧" : "Shift" : t;
}
function Ro(t) {
  return t.map(jf).join(" ");
}
const Zk = /* @__PURE__ */ I({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, size: a, variant: l, ...c } = n;
      return c;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h($k), j(h(i), {
      class: h(ve)(h(Qk)({ variant: s.variant, size: s.size }), n.class)
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Qk = nv(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Nn = /* @__PURE__ */ I({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(cK), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Bn = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(pK), null, {
      default: C(() => [
        _(h(fK), j({ ...h(i), ...s.$attrs }, {
          class: h(ve)("z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", n.class)
        }), {
          default: C(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Fn = /* @__PURE__ */ I({
  __name: "TooltipProvider",
  props: {
    delayDuration: {},
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(aK), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zn = /* @__PURE__ */ I({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(uK), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), OG = { key: 0 }, MG = {
  key: 1,
  class: "flex gap-1 items-center"
}, IG = {
  key: 2,
  class: "ml-1 font-normal"
}, RG = { class: "max-w-24 text-center flex flex-col items-center" }, $G = {
  key: 0,
  style: { display: "flex", gap: "4px" }
}, ge = /* @__PURE__ */ I({
  __name: "ActionButton",
  props: {
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    customClass: { default: "" },
    loading: { type: Boolean, default: !1 },
    tooltipOptions: { default: void 0 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 },
    editor: {},
    class: {}
  },
  setup(t) {
    return (e, n) => (E(), T(h(Fn), null, {
      default: C(() => [
        _(h(Nn), { "delay-duration": 0 }, {
          default: C(() => [
            _(h(zn), null, {
              default: C(() => {
                var o;
                return [
                  _(h(Zk), {
                    size: "sm",
                    class: He(["h-[32px]", [e.customClass, e.title ? "w-auto" : "w-[32px]"]]),
                    "model-value": ((o = e.isActive) == null ? void 0 : o.call(e)) || !1,
                    disabled: e.disabled,
                    onClick: e.action
                  }, {
                    default: C(() => [
                      e.loading ? (E(), W("div", OG, [
                        _(h(ye), {
                          class: "animate-spin",
                          name: "LoaderCircle"
                        })
                      ])) : (E(), W("div", MG, [
                        e.icon ? (E(), T(h(ye), {
                          key: 0,
                          name: e.icon
                        }, null, 8, ["name"])) : oe("", !0),
                        D(e.$slots, "icon")
                      ])),
                      e.title ? (E(), W("div", IG, Y(e.title), 1)) : oe("", !0),
                      D(e.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["model-value", "disabled", "class", "onClick"])
                ];
              }),
              _: 3
            }),
            e.tooltip ? (E(), T(h(Bn), _e(j({ key: 0 }, e.tooltipOptions)), {
              default: C(() => [
                N("div", RG, [
                  N("div", null, Y(e.tooltip), 1),
                  e.shortcutKeys && e.shortcutKeys.length ? (E(), W("div", $G, [
                    (E(!0), W(me, null, Oe(e.shortcutKeys, (o, r) => (E(), W("span", { key: r }, Y(h(jf)(o)), 1))), 128))
                  ])) : oe("", !0)
                ])
              ]),
              _: 1
            }, 16)) : oe("", !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), PG = { class: "flex items-center gap-2 p-2 bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800" }, LG = ["href"], DG = { class: "flex flex-nowrap" }, NG = /* @__PURE__ */ I({
  __name: "LinkViewBlock",
  props: {
    editor: {},
    link: { default: void 0 }
  },
  emits: ["clear", "edit"],
  setup(t, { emit: e }) {
    const { t: n } = Ge(), o = e;
    function r() {
      o("clear");
    }
    function i() {
      o("edit");
    }
    return (s, a) => (E(), W("div", PG, [
      N("a", {
        href: s.link,
        target: "_blank",
        rel: "noopener noreferrer",
        class: "text-sm underline break-all"
      }, Y(h(SF)(s.link, {
        length: 50,
        omission: "…"
      })), 9, LG),
      s.link ? (E(), T(h(Ho), {
        key: 0,
        orientation: "vertical",
        class: "h-4"
      })) : oe("", !0),
      N("div", DG, [
        _(ge, {
          icon: "Pencil",
          tooltip: h(n)("editor.link.edit.tooltip"),
          action: i,
          "tooltip-options": { sideOffset: 15 }
        }, null, 8, ["tooltip"]),
        _(ge, {
          icon: "Unlink",
          tooltip: h(n)("editor.link.unlink.tooltip"),
          action: r,
          "tooltip-options": { sideOffset: 15 }
        }, null, 8, ["tooltip"])
      ])
    ]));
  }
}), BG = /* @__PURE__ */ I({
  __name: "LinkBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = R(!1), o = L(() => {
      const { href: l } = e.editor.getAttributes("link");
      return l;
    }), r = L(() => e.editor.isActive("link"));
    function i(l, c, u) {
      e.editor.chain().extendMarkRange("link").insertContent({
        type: "text",
        text: c,
        marks: [
          {
            type: "link",
            attrs: {
              href: l,
              target: u ? "_blank" : ""
            }
          }
        ]
      }).setLink({ href: l }).focus().run(), n.value = !1;
    }
    function s() {
      e.editor.chain().extendMarkRange("link").unsetLink().focus().run(), n.value = !1;
    }
    function a() {
      const { state: l, view: c } = e.editor, { tr: u, selection: d } = l, f = u.setSelection(ce.create(l.doc, d.from));
      c.dispatch(f), n.value = !1;
    }
    return (l, c) => Vn((E(), T(h(zs), {
      editor: l.editor,
      "update-delay": 0,
      "tippy-options": {
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        appendTo: "parent",
        placement: "bottom-start",
        offset: [-2, 16],
        zIndex: 99,
        onHidden: () => {
          n.value = !1;
        }
      }
    }, {
      default: C(() => [
        n.value ? (E(), T(Xk, {
          key: 0,
          onOnSetLink: i,
          onOnClickOutside: a,
          editor: l.editor
        }, null, 8, ["editor"])) : (E(), T(NG, {
          key: 1,
          editor: l.editor,
          onClear: s,
          onEdit: c[0] || (c[0] = (u) => n.value = !0),
          link: o.value
        }, null, 8, ["editor", "link"]))
      ]),
      _: 1
    }, 8, ["editor", "tippy-options"])), [
      [no, r.value]
    ]);
  }
}), Vr = /* @__PURE__ */ I({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(FU), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ur = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(HU), null, {
      default: C(() => [
        _(h(jU), j({ ...h(i), ...s.$attrs }, {
          class: h(ve)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: C(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), jr = /* @__PURE__ */ I({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(zU), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), FG = { class: "flex flex-col" }, zG = { class: "w-6 h-6 p-0.5 inline-block rounded-sm border cursor-pointer hover:border-border hover:shadow-sm relative after:border-b-2 after:border-b-red-500 after:top-[10px] after:h-0 after:left-0 after:w-6 after:absolute after:block after:rotate-[45deg]" }, HG = { style: { "background-color": "transparent" } }, VG = {
  viewBox: "0 0 18 18",
  style: { fill: "rgba(0, 0, 0, 0.4)", display: "none" }
}, UG = { class: "text-sm ml-1" }, jG = { class: "w-6 h-6 p-0.5 inline-block rounded-sm border border-transparent cursor-pointer" }, WG = {
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "none" }
}, KG = { class: "text-sm ml-1" }, GG = ["onClick"], qG = {
  key: 0,
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "none" }
}, YG = {
  key: 1,
  class: "absolute top-[-1px] left-[1px] w-3 h-3",
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "block" }
}, JG = { class: "text-sm my-1" }, XG = { class: "flex p-0 w-full h-auto relative last:pb-2" }, ZG = ["onClick"], QG = {
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "none" }
}, eq = { class: "relative" }, e3 = /* @__PURE__ */ I({
  __name: "ColorPicker",
  props: {
    modelValue: { default: "" },
    highlight: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const { t: n } = Ge(), o = FO.reduce((f, p, m) => {
      const g = Math.floor(m / 10);
      return f[g] || (f[g] = []), f[g].push(p), f;
    }, []), r = t, i = R(null), s = uz(r.highlight ? "recentColorsHighlight" : "recentColors", []), a = e;
    function l(f) {
      const p = s.value.indexOf(f);
      p !== -1 && s.value.splice(p, 1), s.value.unshift(f), s.value.length > 10 && s.value.pop();
    }
    const c = L(() => s.value.slice(0, 10));
    function u(f) {
      if (f === void 0) {
        a("update:modelValue", f), a("change", f);
        return;
      }
      /^#([0-9A-F]{3}){1,2}$/i.test(f) && (a("update:modelValue", f), a("change", f), l(f));
    }
    const d = () => {
      var f;
      (f = i.value) == null || f.click();
    };
    return (f, p) => (E(), T(h(Vr), null, {
      default: C(() => [
        _(h(jr), { disabled: f.disabled }, {
          default: C(() => [
            D(f.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"]),
        _(h(Ur), {
          hideWhenDetached: "",
          class: "p-2 w-full h-full",
          align: "start",
          side: "bottom"
        }, {
          default: C(() => [
            N("div", FG, [
              f.highlight ? (E(), W("div", {
                key: 0,
                class: "flex items-center p-1 rd-1 cursor-pointer hover:bg-accent",
                onClick: p[0] || (p[0] = (m) => u(void 0))
              }, [
                N("span", zG, [
                  N("span", HG, [
                    (E(), W("svg", VG, p[3] || (p[3] = [
                      N("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1)
                    ])))
                  ])
                ]),
                N("span", UG, Y(h(n)("editor.nofill")), 1)
              ])) : (E(), W("div", {
                key: 1,
                class: "flex items-center p-1 rd-1 cursor-pointer hover:bg-accent",
                onClick: p[1] || (p[1] = (m) => u(void 0))
              }, [
                N("span", jG, [
                  N("span", {
                    style: pt({ backgroundColor: h(BO) }),
                    class: "relative w-[18px] h-[18px] block rounded-[2px] border-transparent"
                  }, [
                    (E(), W("svg", WG, p[4] || (p[4] = [
                      N("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1)
                    ])))
                  ], 4)
                ]),
                N("span", KG, Y(h(n)("editor.default")), 1)
              ])),
              (E(!0), W(me, null, Oe(h(o), (m, g) => (E(), W("span", {
                class: "flex p-0 w-full h-auto relative last:pb-2",
                key: g
              }, [
                (E(!0), W(me, null, Oe(m, (v, y) => (E(), W("span", {
                  class: "w-6 h-6 p-0.5 inline-block rounded-sm border border-transparent flex-[0 0 auto] cursor-pointer hover:border-border hover:shadow-sm",
                  key: y,
                  onClick: (w) => u(v)
                }, [
                  N("span", {
                    style: pt({ backgroundColor: v }),
                    class: "relative w-[18px] h-[18px] block rounded-[2px] border-transparent"
                  }, [
                    v !== f.modelValue ? (E(), W("svg", qG, p[5] || (p[5] = [
                      N("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1)
                    ]))) : (E(), W("svg", YG, p[6] || (p[6] = [
                      N("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1)
                    ])))
                  ], 4)
                ], 8, GG))), 128))
              ]))), 128)),
              Vn(N("div", null, [
                N("div", JG, Y(h(n)("editor.recent")), 1),
                N("span", XG, [
                  (E(!0), W(me, null, Oe(c.value, (m, g) => (E(), W("span", {
                    class: "w-6 h-6 p-0.5 inline-block rounded-sm border border-transparent flex-[0 0 auto] cursor-pointer hover:border-border hover:shadow-sm",
                    key: g,
                    onClick: (v) => u(m)
                  }, [
                    N("span", {
                      class: "relative w-[18px] h-[18px] block rounded-[2px] border-transparent",
                      style: pt({ backgroundColor: m })
                    }, [
                      (E(), W("svg", QG, p[7] || (p[7] = [
                        N("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1)
                      ])))
                    ], 4)
                  ], 8, ZG))), 128))
                ])
              ], 512), [
                [no, c.value.length]
              ]),
              N("div", eq, [
                N("div", {
                  class: "text-sm hover:cursor-pointer hover:bg-accent py-1.5 px-1.5",
                  onClick: d
                }, Y(h(n)("editor.color.more")) + "... ", 1),
                N("input", {
                  type: "color",
                  ref_key: "html5Color",
                  ref: i,
                  onChange: p[2] || (p[2] = (m) => {
                    u(m.target.value);
                  }),
                  class: "absolute left-0 top-4",
                  style: { visibility: "hidden" }
                }, null, 544)
              ])
            ])
          ]),
          _: 1
        })
      ]),
      _: 3
    }));
  }
}), tq = { class: "flex items-center h-[32px] hover:bg-muted rounded-md" }, nq = { class: "text-sm flex items-center justify-center" }, oq = {
  width: "18px",
  height: "18px",
  viewBox: "0 0 256 256",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, rq = {
  id: "icon/填充色",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, iq = { id: "icon/背景颜色" }, sq = ["fill"], t3 = /* @__PURE__ */ I({
  __name: "HighlightActionButton",
  props: {
    editor: {},
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 },
    tooltipOptions: { default: void 0 }
  },
  setup(t) {
    const e = t, n = R(void 0), { state: o } = vn();
    function r(s) {
      var a;
      (a = e.action) == null || a.call(e, s);
    }
    function i(s) {
      var a;
      (a = e.action) == null || a.call(e, n.value);
    }
    return Ve(() => {
      const { color: s } = e.editor.getAttributes("highlight");
      o.highlight = s;
    }), (s, a) => (E(), W("div", tq, [
      _(ge, {
        tooltip: s.tooltip,
        disabled: s.disabled,
        action: i,
        "tooltip-options": s.tooltipOptions
      }, {
        icon: C(() => [
          N("span", nq, [
            (E(), W("svg", oq, [
              N("g", rq, [
                N("g", iq, [
                  a[1] || (a[1] = N("g", {
                    id: "编组",
                    fill: "currentColor"
                  }, [
                    N("g", {
                      transform: "translate(119.502295, 137.878331) rotate(-135.000000) translate(-119.502295, -137.878331) translate(48.002295, 31.757731)",
                      id: "矩形"
                    }, [
                      N("path", {
                        d: "M100.946943,60.8084699 L43.7469427,60.8084699 C37.2852111,60.8084699 32.0469427,66.0467383 32.0469427,72.5084699 L32.0469427,118.70847 C32.0469427,125.170201 37.2852111,130.40847 43.7469427,130.40847 L100.946943,130.40847 C107.408674,130.40847 112.646943,125.170201 112.646943,118.70847 L112.646943,72.5084699 C112.646943,66.0467383 107.408674,60.8084699 100.946943,60.8084699 Z M93.646,79.808 L93.646,111.408 L51.046,111.408 L51.046,79.808 L93.646,79.808 Z",
                        "fill-rule": "nonzero"
                      }),
                      N("path", {
                        d: "M87.9366521,16.90916 L87.9194966,68.2000001 C87.9183543,69.4147389 86.9334998,70.399264 85.7187607,70.4 L56.9423078,70.4 C55.7272813,70.4 54.7423078,69.4150264 54.7423078,68.2 L54.7423078,39.4621057 C54.7423078,37.2523513 55.5736632,35.1234748 57.0711706,33.4985176 L76.4832996,12.4342613 C78.9534987,9.75382857 83.1289108,9.5834005 85.8093436,12.0535996 C87.1658473,13.303709 87.9372691,15.0644715 87.9366521,16.90916 Z",
                        "fill-rule": "evenodd"
                      }),
                      N("path", {
                        d: "M131.3,111.241199 L11.7,111.241199 C5.23826843,111.241199 0,116.479467 0,122.941199 L0,200.541199 C0,207.002931 5.23826843,212.241199 11.7,212.241199 L131.3,212.241199 C137.761732,212.241199 143,207.002931 143,200.541199 L143,122.941199 C143,116.479467 137.761732,111.241199 131.3,111.241199 Z M124,130.241 L124,193.241 L19,193.241 L19,130.241 L124,130.241 Z",
                        "fill-rule": "nonzero"
                      })
                    ])
                  ], -1)),
                  N("path", {
                    d: "M51,218 L205,218 C211.075132,218 216,222.924868 216,229 C216,235.075132 211.075132,240 205,240 L51,240 C44.9248678,240 40,235.075132 40,229 C40,222.924868 44.9248678,218 51,218 Z",
                    id: "矩形",
                    fill: n.value || "#FBDE28"
                  }, null, 8, sq)
                ])
              ])
            ]))
          ])
        ]),
        _: 1
      }, 8, ["tooltip", "disabled", "tooltip-options"]),
      _(e3, {
        modelValue: n.value,
        "onUpdate:modelValue": a[0] || (a[0] = (l) => n.value = l),
        onChange: r,
        highlight: "",
        disabled: s.disabled
      }, {
        default: C(() => [
          _(h(Rt), {
            variant: "ghost",
            size: "icon",
            class: "w-3 h-[32px] rounded-l-none hover:bg-muted-foreground/20",
            disabled: s.disabled
          }, {
            default: C(() => [
              _(h(ye), {
                class: "w-3 h-3 text-zinc-500",
                name: "MenuDown"
              })
            ]),
            _: 1
          }, 8, ["disabled"])
        ]),
        _: 1
      }, 8, ["modelValue", "disabled"])
    ]));
  }
}), aq = { class: "min-w-32 flex flex-row h-full items-center leading-none gap-0.5 p-2 w-full bg-background rounded-lg shadow-sm border border-border" }, lq = /* @__PURE__ */ I({
  __name: "TableBubbleMenu",
  props: {
    editor: {}
  },
  setup(t) {
    const e = t, n = ({ editor: g }) => df(g.view.state, "table"), { t: o } = Ge();
    function r() {
      e.editor.chain().focus().addColumnBefore().run();
    }
    function i() {
      e.editor.chain().focus().addColumnAfter().run();
    }
    function s() {
      e.editor.chain().focus().deleteColumn().run();
    }
    function a() {
      e.editor.chain().focus().addRowBefore().run();
    }
    function l() {
      e.editor.chain().focus().addRowAfter().run();
    }
    function c() {
      e.editor.chain().focus().deleteRow().run();
    }
    function u() {
      e.editor.chain().focus().mergeCells().run();
    }
    function d() {
      var g;
      (g = e.editor) == null || g.chain().focus().splitCell().run();
    }
    function f() {
      e.editor.chain().focus().deleteTable().run();
    }
    function p(g) {
      e.editor.chain().focus().setTableCellBackground(g).run();
    }
    const m = () => {
      const {
        view: g,
        state: {
          selection: { from: v }
        }
      } = e.editor, y = g.domAtPos(v).node;
      if (!y) return new DOMRect(-1e3, -1e3, 0, 0);
      const w = y == null ? void 0 : y.closest(".tableWrapper");
      return w ? w.getBoundingClientRect() : new DOMRect(-1e3, -1e3, 0, 0);
    };
    return (g, v) => (E(), T(h(zs), {
      editor: g.editor,
      pluginKey: "table",
      shouldShow: n,
      updateDelay: 0,
      "tippy-options": {
        offset: [0, 8],
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        maxWidth: "auto",
        getReferenceClientRect: m,
        plugins: [h(s1)],
        sticky: "popper"
      }
    }, {
      default: C(() => {
        var y, w, x, b, S, k, A, $, O;
        return [
          N("div", aq, [
            _(ge, {
              icon: "BetweenHorizonalEnd",
              tooltip: h(o)("editor.table.menu.insertColumnBefore"),
              action: r,
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((y = g.editor) != null && y.can().addColumnBefore())
            }, null, 8, ["tooltip", "disabled"]),
            _(ge, {
              icon: "BetweenHorizonalStart",
              tooltip: h(o)("editor.table.menu.insertColumnAfter"),
              action: i,
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((w = g.editor) != null && w.can().addColumnAfter())
            }, null, 8, ["tooltip", "disabled"]),
            _(ge, {
              icon: "ColumnDelete",
              action: s,
              tooltip: h(o)("editor.table.menu.deleteColumn"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((x = g.editor) != null && x.can().deleteColumn())
            }, null, 8, ["tooltip", "disabled"]),
            _(h(Ho), {
              orientation: "vertical",
              class: "mx-1 me-2 h-[16px]"
            }),
            _(ge, {
              icon: "BetweenVerticalEnd",
              action: a,
              tooltip: h(o)("editor.table.menu.insertRowAbove"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((b = g.editor) != null && b.can().addRowBefore())
            }, null, 8, ["tooltip", "disabled"]),
            _(ge, {
              icon: "BetweenVerticalStart",
              action: l,
              tooltip: h(o)("editor.table.menu.insertRowBelow"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((S = g.editor) != null && S.can().addRowAfter())
            }, null, 8, ["tooltip", "disabled"]),
            _(ge, {
              icon: "RowDelete",
              action: c,
              tooltip: h(o)("editor.table.menu.deleteRow"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((k = g.editor) != null && k.can().deleteRow())
            }, null, 8, ["tooltip", "disabled"]),
            _(h(Ho), {
              orientation: "vertical",
              class: "mx-1 me-2 h-[16px]"
            }),
            _(ge, {
              icon: "TableCellsMerge",
              action: u,
              tooltip: h(o)("editor.table.menu.mergeCells"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((A = g.editor) != null && A.can().mergeCells())
            }, null, 8, ["tooltip", "disabled"]),
            _(ge, {
              icon: "TableCellsSplit",
              action: d,
              tooltip: h(o)("editor.table.menu.splitCells"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !(($ = g.editor) != null && $.can().splitCell())
            }, null, 8, ["tooltip", "disabled"]),
            _(h(Ho), {
              orientation: "vertical",
              class: "mx-1 me-2 h-[16px]"
            }),
            _(t3, {
              editor: g.editor,
              tooltip: h(o)("editor.table.menu.setCellsBgColor"),
              action: p,
              "tooltip-options": {
                sideOffset: 15
              }
            }, null, 8, ["editor", "tooltip"]),
            _(ge, {
              icon: "Trash2",
              tooltip: h(o)("editor.table.menu.deleteTable"),
              action: f,
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((O = g.editor) != null && O.can().deleteTable())
            }, null, 8, ["tooltip", "disabled"])
          ])
        ];
      }),
      _: 1
    }, 8, ["editor", "tippy-options"]));
  }
}), cq = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, uq = /* @__PURE__ */ I({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(ZU), j(h(i), {
      class: h(ve)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: C(() => [
        N("span", cq, [
          _(h(QU), null, {
            default: C(() => [
              _(h(rc), { class: "w-4 h-4" })
            ]),
            _: 1
          })
        ]),
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ao = () => /* @__PURE__ */ new Map(), Dm = (t) => {
  const e = ao();
  return t.forEach((n, o) => {
    e.set(o, n);
  }), e;
}, Zs = (t, e, n) => {
  let o = t.get(e);
  return o === void 0 && t.set(e, o = n()), o;
}, dq = (t, e) => {
  const n = [];
  for (const [o, r] of t)
    n.push(e(r, o));
  return n;
}, fq = (t, e) => {
  for (const [n, o] of t)
    if (e(o, n))
      return !0;
  return !1;
}, Is = () => /* @__PURE__ */ new Set(), Yp = (t) => t[t.length - 1], Rs = Array.from, pq = Array.isArray;
class hq {
  constructor() {
    this._observers = ao();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return Zs(
      this._observers,
      /** @type {string} */
      e,
      Is
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const o = (...r) => {
      this.off(
        e,
        /** @type {any} */
        o
      ), n(...r);
    };
    this.on(
      e,
      /** @type {any} */
      o
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const o = this._observers.get(e);
    o !== void 0 && (o.delete(n), o.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return Rs((this._observers.get(e) || ao()).values()).forEach((o) => o(...n));
  }
  destroy() {
    this._observers = ao();
  }
}
const _i = Math.floor, yu = Math.abs, n3 = (t, e) => t < e ? t : e, Qs = (t, e) => t > e ? t : e, mq = (t) => t !== 0 ? t < 0 : 1 / t < 0, Qb = 1, ew = 2, Jp = 4, Xp = 8, gq = 32, o3 = 64, rd = 128, vq = 31, tw = 63, ja = 127, yq = 2147483647, bq = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && _i(t) === t), wq = (t) => t.toLowerCase(), xq = /^\s*/g, Cq = (t) => t.replace(xq, ""), Sq = /([A-Z])/g, nw = (t, e) => Cq(t.replace(Sq, (n) => `${e}${wq(n)}`)), kq = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, o = new Uint8Array(n);
  for (let r = 0; r < n; r++)
    o[r] = /** @type {number} */
    e.codePointAt(r);
  return o;
}, kl = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Eq = (t) => kl.encode(t), _q = kl ? Eq : kq;
let Zp = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Zp && Zp.decode(new Uint8Array()).length === 1 && (Zp = null);
class ic {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const ov = () => new ic(), Aq = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Lo = (t) => {
  const e = new Uint8Array(Aq(t));
  let n = 0;
  for (let o = 0; o < t.bufs.length; o++) {
    const r = t.bufs[o];
    e.set(r, n), n += r.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, Tq = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(Qs(n, e) * 2), t.cpos = 0);
}, yt = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, Nm = yt, Ye = (t, e) => {
  for (; e > ja; )
    yt(t, rd | ja & e), e = _i(e / 128);
  yt(t, ja & e);
}, rv = (t, e) => {
  const n = mq(e);
  for (n && (e = -e), yt(t, (e > tw ? rd : 0) | (n ? o3 : 0) | tw & e), e = _i(e / 64); e > 0; )
    yt(t, (e > ja ? rd : 0) | ja & e), e = _i(e / 128);
}, Bm = new Uint8Array(3e4), Oq = Bm.length / 3, Mq = (t, e) => {
  if (e.length < Oq) {
    const n = kl.encodeInto(e, Bm).written || 0;
    Ye(t, n);
    for (let o = 0; o < n; o++)
      yt(t, Bm[o]);
  } else
    sn(t, _q(e));
}, Iq = (t, e) => {
  const n = unescape(encodeURIComponent(e)), o = n.length;
  Ye(t, o);
  for (let r = 0; r < o; r++)
    yt(
      t,
      /** @type {number} */
      n.codePointAt(r)
    );
}, ms = kl && /** @type {any} */
kl.encodeInto ? Mq : Iq, iv = (t, e) => {
  const n = t.cbuf.length, o = t.cpos, r = n3(n - o, e.length), i = e.length - r;
  t.cbuf.set(e.subarray(0, r), o), t.cpos += r, i > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(Qs(n * 2, i)), t.cbuf.set(e.subarray(r)), t.cpos = i);
}, sn = (t, e) => {
  Ye(t, e.byteLength), iv(t, e);
}, sv = (t, e) => {
  Tq(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, Rq = (t, e) => sv(t, 4).setFloat32(0, e, !1), $q = (t, e) => sv(t, 8).setFloat64(0, e, !1), Pq = (t, e) => (
  /** @type {any} */
  sv(t, 8).setBigInt64(0, e, !1)
), ow = new DataView(new ArrayBuffer(4)), Lq = (t) => (ow.setFloat32(0, t), ow.getFloat32(0) === t), El = (t, e) => {
  switch (typeof e) {
    case "string":
      yt(t, 119), ms(t, e);
      break;
    case "number":
      bq(e) && yu(e) <= yq ? (yt(t, 125), rv(t, e)) : Lq(e) ? (yt(t, 124), Rq(t, e)) : (yt(t, 123), $q(t, e));
      break;
    case "bigint":
      yt(t, 122), Pq(t, e);
      break;
    case "object":
      if (e === null)
        yt(t, 126);
      else if (pq(e)) {
        yt(t, 117), Ye(t, e.length);
        for (let n = 0; n < e.length; n++)
          El(t, e[n]);
      } else if (e instanceof Uint8Array)
        yt(t, 116), sn(t, e);
      else {
        yt(t, 118);
        const n = Object.keys(e);
        Ye(t, n.length);
        for (let o = 0; o < n.length; o++) {
          const r = n[o];
          ms(t, r), El(t, e[r]);
        }
      }
      break;
    case "boolean":
      yt(t, e ? 120 : 121);
      break;
    default:
      yt(t, 127);
  }
};
class rw extends ic {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && Ye(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const iw = (t) => {
  t.count > 0 && (rv(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && Ye(t.encoder, t.count - 2));
};
class bu {
  constructor() {
    this.encoder = new ic(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (iw(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return iw(this), Lo(this.encoder);
  }
}
const sw = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    rv(t.encoder, e), t.count > 1 && Ye(t.encoder, t.count - 2);
  }
};
class Qp {
  constructor() {
    this.encoder = new ic(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (sw(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return sw(this), Lo(this.encoder);
  }
}
class Dq {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new bu();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new ic();
    return this.sarr.push(this.s), this.s = "", ms(e, this.sarr.join("")), iv(e, this.lensE.toUint8Array()), Lo(e);
  }
}
const $s = (t) => new Error(t), lo = () => {
  throw $s("Method unimplemented");
}, Ir = () => {
  throw $s("Unexpected case");
}, Nq = crypto.getRandomValues.bind(crypto), r3 = () => Nq(new Uint32Array(1))[0], Bq = "10000000-1000-4000-8000" + -1e11, Fq = () => Bq.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ r3() & 15 >> t / 4).toString(16)
), aw = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const lw = (t) => t === void 0 ? null : t;
class zq {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let i3 = new zq(), Hq = !0;
try {
  typeof localStorage < "u" && localStorage && (i3 = localStorage, Hq = !1);
} catch {
}
const Vq = i3, Uq = Object.assign, jq = Object.keys, Wq = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, cw = (t) => jq(t).length, Kq = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, Gq = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, qq = (t, e) => Object.prototype.hasOwnProperty.call(t, e), Yq = (t, e) => t === e || cw(t) === cw(e) && Gq(t, (n, o) => (n !== void 0 || qq(e, o)) && e[o] === n), Jq = Object.freeze, s3 = (t) => {
  for (const e in t) {
    const n = t[e];
    (typeof n == "object" || typeof n == "function") && s3(t[e]);
  }
  return Jq(t);
}, av = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && av(t, e, n + 1);
  }
}, Xq = (t, e) => e.includes(t), _l = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let Jn;
const Zq = () => {
  if (Jn === void 0)
    if (_l) {
      Jn = ao();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const o = t[n];
        o[0] === "-" ? (e !== null && Jn.set(e, ""), e = o) : e !== null && (Jn.set(e, o), e = null);
      }
      e !== null && Jn.set(e, "");
    } else typeof location == "object" ? (Jn = ao(), (location.search || "?").slice(1).split("&").forEach((t) => {
      if (t.length !== 0) {
        const [e, n] = t.split("=");
        Jn.set(`--${nw(e, "-")}`, n), Jn.set(`-${nw(e, "-")}`, n);
      }
    })) : Jn = ao();
  return Jn;
}, Fm = (t) => Zq().has(t), id = (t) => lw(_l ? process.env[t.toUpperCase().replaceAll("-", "_")] : Vq.getItem(t)), a3 = (t) => Fm("--" + t) || id(t) !== null;
a3("production");
const Qq = _l && Xq(process.env.FORCE_COLOR, ["true", "1", "2"]), eY = Qq || !Fm("--no-colors") && // @todo deprecate --no-colors
!a3("no-color") && (!_l || process.stdout.isTTY) && (!_l || Fm("--color") || id("COLORTERM") !== null || (id("TERM") || "").includes("color"));
class tY {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const So = (t, e) => new tY(t, e);
typeof DOMParser < "u" && new DOMParser();
const nY = (t) => dq(t, (e, n) => `${n}:${e};`).join(""), Jo = Symbol, l3 = Jo(), c3 = Jo(), oY = Jo(), rY = Jo(), iY = Jo(), u3 = Jo(), sY = Jo(), lv = Jo(), aY = Jo(), lY = (t) => {
  var r;
  t.length === 1 && ((r = t[0]) == null ? void 0 : r.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [];
  let o = 0;
  for (; o < t.length; o++) {
    const i = t[o];
    if (i === void 0)
      break;
    if (i.constructor === String || i.constructor === Number)
      e.push(i);
    else if (i.constructor === Object)
      break;
  }
  for (o > 0 && n.push(e.join("")); o < t.length; o++) {
    const i = t[o];
    i instanceof Symbol || n.push(i);
  }
  return n;
}, cY = {
  [l3]: So("font-weight", "bold"),
  [c3]: So("font-weight", "normal"),
  [oY]: So("color", "blue"),
  [iY]: So("color", "green"),
  [rY]: So("color", "grey"),
  [u3]: So("color", "red"),
  [sY]: So("color", "purple"),
  [lv]: So("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [aY]: So("color", "black")
}, uY = (t) => {
  var s;
  t.length === 1 && ((s = t[0]) == null ? void 0 : s.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], o = ao();
  let r = [], i = 0;
  for (; i < t.length; i++) {
    const a = t[i], l = cY[a];
    if (l !== void 0)
      o.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = nY(o);
        i > 0 || c.length > 0 ? (e.push("%c" + a), n.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (i > 0 && (r = n, r.unshift(e.join(""))); i < t.length; i++) {
    const a = t[i];
    a instanceof Symbol || r.push(a);
  }
  return r;
}, d3 = eY ? uY : lY, dY = (...t) => {
  console.log(...d3(t)), f3.forEach((e) => e.print(t));
}, fY = (...t) => {
  console.warn(...d3(t)), t.unshift(lv), f3.forEach((e) => e.print(t));
}, f3 = Is(), p3 = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), pY = (t, e) => p3(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), eh = (t, e) => p3(() => {
  const { done: n, value: o } = t.next();
  return { done: n, value: n ? void 0 : e(o) };
});
class hY {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class mY {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const h3 = (t, e, n) => e.clients.forEach((o, r) => {
  const i = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(r)
  );
  for (let s = 0; s < o.length; s++) {
    const a = o[s];
    x3(t, i, a.clock, a.len, n);
  }
}), gY = (t, e) => {
  let n = 0, o = t.length - 1;
  for (; n <= o; ) {
    const r = _i((n + o) / 2), i = t[r], s = i.clock;
    if (s <= e) {
      if (e < s + i.len)
        return r;
      n = r + 1;
    } else
      o = r - 1;
  }
  return null;
}, m3 = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && gY(n, e.clock) !== null;
}, g3 = (t) => {
  t.clients.forEach((e) => {
    e.sort((r, i) => r.clock - i.clock);
    let n, o;
    for (n = 1, o = 1; n < e.length; n++) {
      const r = e[o - 1], i = e[n];
      r.clock + r.len >= i.clock ? r.len = Qs(r.len, i.clock + i.len - r.clock) : (o < n && (e[o] = i), o++);
    }
    e.length = o;
  });
}, v3 = (t, e, n, o) => {
  Zs(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new hY(n, o));
}, vY = (t, e) => {
  Ye(t.restEncoder, e.clients.size), Rs(e.clients.entries()).sort((n, o) => o[0] - n[0]).forEach(([n, o]) => {
    t.resetDsCurVal(), Ye(t.restEncoder, n);
    const r = o.length;
    Ye(t.restEncoder, r);
    for (let i = 0; i < r; i++) {
      const s = o[i];
      t.writeDsClock(s.clock), t.writeDsLen(s.len);
    }
  });
}, y3 = r3;
class sc extends hq {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = Fq(), collectionid: n = null, gc: o = !0, gcFilter: r = () => !0, meta: i = null, autoLoad: s = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = o, this.gcFilter = r, this.clientID = y3(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new _Y(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = s, this.meta = i, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = aw((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => aw((c) => {
      const u = (d) => {
        (d === void 0 || d === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && nt(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Rs(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return nt(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    Mt
  )) {
    const o = Zs(this.share, e, () => {
      const i = new n();
      return i._integrate(this, null), i;
    }), r = o.constructor;
    if (n !== Mt && r !== n)
      if (r === Mt) {
        const i = new n();
        i._map = o._map, o._map.forEach(
          /** @param {Item?} n */
          (s) => {
            for (; s !== null; s = s.left)
              s.parent = i;
          }
        ), i._start = o._start;
        for (let s = i._start; s !== null; s = s.right)
          s.parent = i;
        return i._length = o._length, this.share.set(e, i), i._integrate(this, null), /** @type {InstanceType<Type>} */
        i;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      o
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, Wa)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, Ml);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, cd)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Il)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, Ps);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, o) => {
      e[o] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, Rs(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new sc({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, nt(
        /** @type {any} */
        e.parent.doc,
        (o) => {
          const r = n.doc;
          e.deleted || o.subdocsAdded.add(r), o.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class yY {
  constructor() {
    this.restEncoder = ov();
  }
  toUint8Array() {
    return Lo(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    Ye(this.restEncoder, e);
  }
}
class bY extends yY {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    Ye(this.restEncoder, e.client), Ye(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    Ye(this.restEncoder, e.client), Ye(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    Nm(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    ms(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    Ye(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    El(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    sn(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    ms(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    ms(this.restEncoder, e);
  }
}
class wY {
  constructor() {
    this.restEncoder = ov(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Lo(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, Ye(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && Ir(), Ye(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class xY extends wY {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Qp(), this.clientEncoder = new bu(), this.leftClockEncoder = new Qp(), this.rightClockEncoder = new Qp(), this.infoEncoder = new rw(Nm), this.stringEncoder = new Dq(), this.parentInfoEncoder = new rw(Nm), this.typeRefEncoder = new bu(), this.lenEncoder = new bu();
  }
  toUint8Array() {
    const e = ov();
    return Ye(e, 0), sn(e, this.keyClockEncoder.toUint8Array()), sn(e, this.clientEncoder.toUint8Array()), sn(e, this.leftClockEncoder.toUint8Array()), sn(e, this.rightClockEncoder.toUint8Array()), sn(e, Lo(this.infoEncoder)), sn(e, this.stringEncoder.toUint8Array()), sn(e, Lo(this.parentInfoEncoder)), sn(e, this.typeRefEncoder.toUint8Array()), sn(e, this.lenEncoder.toUint8Array()), iv(e, Lo(this.restEncoder)), Lo(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    El(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    sn(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    El(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const CY = (t, e, n, o) => {
  o = Qs(o, e[0].id.clock);
  const r = Wo(e, o);
  Ye(t.restEncoder, e.length - r), t.writeClient(n), Ye(t.restEncoder, o);
  const i = e[r];
  i.write(t, o - i.id.clock);
  for (let s = r + 1; s < e.length; s++)
    e[s].write(t, 0);
}, SY = (t, e, n) => {
  const o = /* @__PURE__ */ new Map();
  n.forEach((r, i) => {
    Qt(e, i) > r && o.set(i, r);
  }), cv(e).forEach((r, i) => {
    n.has(i) || o.set(i, 0);
  }), Ye(t.restEncoder, o.size), Rs(o.entries()).sort((r, i) => i[0] - r[0]).forEach(([r, i]) => {
    CY(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(r),
      r,
      i
    );
  });
}, kY = (t, e) => SY(t, e.doc.store, e.beforeState);
class EY {
  constructor() {
    this.l = [];
  }
}
const uw = () => new EY(), dw = (t, e) => t.l.push(e), fw = (t, e) => {
  const n = t.l, o = n.length;
  t.l = n.filter((r) => e !== r), o === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, b3 = (t, e, n) => av(t.l, [e, n]);
class wu {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const Hc = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, ot = (t, e) => new wu(t, e), Al = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw Ir();
};
class sd {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, n, o, r = 0) {
    this.type = e, this.tname = n, this.item = o, this.assoc = r;
  }
}
const Vc = (t, e, n) => {
  let o = null, r = null;
  return t._item === null ? r = Al(t) : o = ot(t._item.id.client, t._item.id.clock), new sd(o, r, e, n);
}, th = (t, e, n = 0) => {
  let o = t._start;
  if (n < 0) {
    if (e === 0)
      return Vc(t, null, n);
    e--;
  }
  for (; o !== null; ) {
    if (!o.deleted && o.countable) {
      if (o.length > e)
        return Vc(t, ot(o.id.client, o.id.clock + e), n);
      e -= o.length;
    }
    if (o.right === null && n < 0)
      return Vc(t, o.lastId, n);
    o = o.right;
  }
  return Vc(t, null, n);
}, ns = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !m3(e.ds, t.id), zm = (t, e) => {
  const n = Zs(t.meta, zm, Is), o = t.doc.store;
  n.has(e) || (e.sv.forEach((r, i) => {
    r < Qt(o, i) && Rr(t, ot(i, r));
  }), h3(t, e.ds, (r) => {
  }), n.add(e));
};
class _Y {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const cv = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, o) => {
    const r = n[n.length - 1];
    e.set(o, r.id.clock + r.length);
  }), e;
}, Qt = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const o = n[n.length - 1];
  return o.id.clock + o.length;
}, w3 = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const o = n[n.length - 1];
    if (o.id.clock + o.length !== e.id.clock)
      throw Ir();
  }
  n.push(e);
}, Wo = (t, e) => {
  let n = 0, o = t.length - 1, r = t[o], i = r.id.clock;
  if (i === e)
    return o;
  let s = _i(e / (i + r.length - 1) * o);
  for (; n <= o; ) {
    if (r = t[s], i = r.id.clock, i <= e) {
      if (e < i + r.length)
        return s;
      n = s + 1;
    } else
      o = s - 1;
    s = _i((n + o) / 2);
  }
  throw Ir();
}, AY = (t, e) => {
  const n = t.clients.get(e.client);
  return n[Wo(n, e.clock)];
}, nh = (
  /** @type {function(StructStore,ID):Item} */
  AY
), Hm = (t, e, n) => {
  const o = Wo(e, n), r = e[o];
  return r.id.clock < n && r instanceof fn ? (e.splice(o + 1, 0, F3(t, r, n - r.id.clock)), o + 1) : o;
}, Rr = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[Hm(t, n, e.clock)];
}, pw = (t, e, n) => {
  const o = e.clients.get(n.client), r = Wo(o, n.clock), i = o[r];
  return n.clock !== i.id.clock + i.length - 1 && i.constructor !== dr && o.splice(r + 1, 0, F3(t, i, n.clock - i.id.clock + 1)), i;
}, TY = (t, e, n) => {
  const o = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  o[Wo(o, e.id.clock)] = n;
}, x3 = (t, e, n, o, r) => {
  if (o === 0)
    return;
  const i = n + o;
  let s = Hm(t, e, n), a;
  do
    a = e[s++], i < a.id.clock + a.length && Hm(t, e, i), r(a);
  while (s < e.length && e[s].id.clock < i);
};
class OY {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, o) {
    this.doc = e, this.deleteSet = new mY(), this.beforeState = cv(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = o, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const hw = (t, e) => e.deleteSet.clients.size === 0 && !fq(e.afterState, (n, o) => e.beforeState.get(o) !== n) ? !1 : (g3(e.deleteSet), kY(t, e), vY(t, e.deleteSet), !0), mw = (t, e, n) => {
  const o = e._item;
  (o === null || o.id.clock < (t.beforeState.get(o.id.client) || 0) && !o.deleted) && Zs(t.changed, e, Is).add(n);
}, xu = (t, e) => {
  let n = t[e], o = t[e - 1], r = e;
  for (; r > 0; n = o, o = t[--r - 1]) {
    if (o.deleted === n.deleted && o.constructor === n.constructor && o.mergeWith(n)) {
      n instanceof fn && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        o
      );
      continue;
    }
    break;
  }
  const i = e - r;
  return i && t.splice(e + 1 - i, i), i;
}, MY = (t, e, n) => {
  for (const [o, r] of t.clients.entries()) {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(o)
    );
    for (let s = r.length - 1; s >= 0; s--) {
      const a = r[s], l = a.clock + a.len;
      for (let c = Wo(i, a.clock), u = i[c]; c < i.length && u.id.clock < l; u = i[++c]) {
        const d = i[c];
        if (a.clock + a.len <= d.id.clock)
          break;
        d instanceof fn && d.deleted && !d.keep && n(d) && d.gc(e, !1);
      }
    }
  }
}, IY = (t, e) => {
  t.clients.forEach((n, o) => {
    const r = (
      /** @type {Array<GC|Item>} */
      e.clients.get(o)
    );
    for (let i = n.length - 1; i >= 0; i--) {
      const s = n[i], a = n3(r.length - 1, 1 + Wo(r, s.clock + s.len - 1));
      for (let l = a, c = r[l]; l > 0 && c.id.clock >= s.clock; c = r[l])
        l -= 1 + xu(r, l);
    }
  });
}, C3 = (t, e) => {
  if (e < t.length) {
    const n = t[e], o = n.doc, r = o.store, i = n.deleteSet, s = n._mergeStructs;
    try {
      g3(i), n.afterState = cv(n.doc.store), o.emit("beforeObserverCalls", [n, o]);
      const a = [];
      n.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, d) => u.path.length - d.path.length), b3(c._dEH, l, n));
        });
      }), a.push(() => o.emit("afterTransaction", [n, o])), av(a, []), n._needFormattingCleanup && UY(n);
    } finally {
      o.gc && MY(i, r, o.gcFilter), IY(i, r), n.afterState.forEach((u, d) => {
        const f = n.beforeState.get(d) || 0;
        if (f !== u) {
          const p = (
            /** @type {Array<GC|Item>} */
            r.clients.get(d)
          ), m = Qs(Wo(p, f), 1);
          for (let g = p.length - 1; g >= m; )
            g -= 1 + xu(p, g);
        }
      });
      for (let u = s.length - 1; u >= 0; u--) {
        const { client: d, clock: f } = s[u].id, p = (
          /** @type {Array<GC|Item>} */
          r.clients.get(d)
        ), m = Wo(p, f);
        m + 1 < p.length && xu(p, m + 1) > 1 || m > 0 && xu(p, m);
      }
      if (!n.local && n.afterState.get(o.clientID) !== n.beforeState.get(o.clientID) && (dY(lv, l3, "[yjs] ", c3, u3, "Changed the client-id because another client seems to be using it."), o.clientID = y3()), o.emit("afterTransactionCleanup", [n, o]), o._observers.has("update")) {
        const u = new bY();
        hw(u, n) && o.emit("update", [u.toUint8Array(), n.origin, o, n]);
      }
      if (o._observers.has("updateV2")) {
        const u = new xY();
        hw(u, n) && o.emit("updateV2", [u.toUint8Array(), n.origin, o, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = o.clientID, u.collectionid == null && (u.collectionid = o.collectionid), o.subdocs.add(u);
      }), c.forEach((u) => o.subdocs.delete(u)), o.emit("subdocs", [{ loaded: l, added: a, removed: c }, o, n]), c.forEach((u) => u.destroy())), t.length <= e + 1 ? (o._transactionCleanups = [], o.emit("afterAllTransactions", [o, t])) : C3(t, e + 1);
    }
  }
}, nt = (t, e, n = null, o = !0) => {
  const r = t._transactionCleanups;
  let i = !1, s = null;
  t._transaction === null && (i = !0, t._transaction = new OY(t, n, o), r.push(t._transaction), r.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    s = e(t._transaction);
  } finally {
    if (i) {
      const a = t._transaction === r[0];
      t._transaction = null, a && C3(r, 0);
    }
  }
  return s;
}, gw = "You must not compute changes after the event-handler fired.";
class Wf {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = RY(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return m3(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw $s(gw);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((r) => {
        if (r !== null) {
          const i = (
            /** @type {Item} */
            n._map.get(r)
          );
          let s, a;
          if (this.adds(i)) {
            let l = i.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(i))
              if (l !== null && this.deletes(l))
                s = "delete", a = Yp(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (s = "update", a = Yp(l.content.getContent())) : (s = "add", a = void 0);
          } else if (this.deletes(i))
            s = "delete", a = Yp(
              /** @type {Item} */
              i.content.getContent()
            );
          else
            return;
          e.set(r, { action: s, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw $s(gw);
      const n = this.target, o = Is(), r = Is(), i = [];
      if (e = {
        added: o,
        deleted: r,
        delta: i,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && i.push(a);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, r.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), o.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const RY = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let o = 0, r = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; r !== e._item && r !== null; )
        !r.deleted && r.countable && (o += r.length), r = r.right;
      n.unshift(o);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, Lt = () => {
  fY("Invalid access: Add Yjs type to a document before reading data.");
}, S3 = 80;
let uv = 0;
class $Y {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = uv++;
  }
}
const PY = (t) => {
  t.timestamp = uv++;
}, k3 = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = uv++;
}, LY = (t, e, n) => {
  if (t.length >= S3) {
    const o = t.reduce((r, i) => r.timestamp < i.timestamp ? r : i);
    return k3(o, e, n), o;
  } else {
    const o = new $Y(e, n);
    return t.push(o), o;
  }
}, Kf = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((i, s) => yu(e - i.index) < yu(e - s.index) ? i : s);
  let o = t._start, r = 0;
  for (n !== null && (o = n.p, r = n.index, PY(n)); o.right !== null && r < e; ) {
    if (!o.deleted && o.countable) {
      if (e < r + o.length)
        break;
      r += o.length;
    }
    o = o.right;
  }
  for (; o.left !== null && r > e; )
    o = o.left, !o.deleted && o.countable && (r -= o.length);
  for (; o.left !== null && o.left.id.client === o.id.client && o.left.id.clock + o.left.length === o.id.clock; )
    o = o.left, !o.deleted && o.countable && (r -= o.length);
  return n !== null && yu(n.index - r) < /** @type {YText|YArray<any>} */
  o.parent.length / S3 ? (k3(n, o, r), n) : LY(t._searchMarker, o, r);
}, Tl = (t, e, n) => {
  for (let o = t.length - 1; o >= 0; o--) {
    const r = t[o];
    if (n > 0) {
      let i = r.p;
      for (i.marker = !1; i && (i.deleted || !i.countable); )
        i = i.left, i && !i.deleted && i.countable && (r.index -= i.length);
      if (i === null || i.marker === !0) {
        t.splice(o, 1);
        continue;
      }
      r.p = i, i.marker = !0;
    }
    (e < r.index || n > 0 && e === r.index) && (r.index = Qs(e, r.index + n));
  }
}, Gf = (t, e, n) => {
  const o = t, r = e.changedParentTypes;
  for (; Zs(r, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  b3(o._eH, n, e);
};
class Mt {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = uw(), this._dEH = uw(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw lo();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw lo();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    dw(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    dw(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    fw(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    fw(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const E3 = (t, e, n) => {
  t.doc ?? Lt(), e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let o = n - e;
  const r = [];
  let i = t._start;
  for (; i !== null && o > 0; ) {
    if (i.countable && !i.deleted) {
      const s = i.content.getContent();
      if (s.length <= e)
        e -= s.length;
      else {
        for (let a = e; a < s.length && o > 0; a++)
          r.push(s[a]), o--;
        e = 0;
      }
    }
    i = i.right;
  }
  return r;
}, _3 = (t) => {
  t.doc ?? Lt();
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const o = n.content.getContent();
      for (let r = 0; r < o.length; r++)
        e.push(o[r]);
    }
    n = n.right;
  }
  return e;
}, Ol = (t, e) => {
  let n = 0, o = t._start;
  for (t.doc ?? Lt(); o !== null; ) {
    if (o.countable && !o.deleted) {
      const r = o.content.getContent();
      for (let i = 0; i < r.length; i++)
        e(r[i], n++, t);
    }
    o = o.right;
  }
}, A3 = (t, e) => {
  const n = [];
  return Ol(t, (o, r) => {
    n.push(e(o, r, t));
  }), n;
}, DY = (t) => {
  let e = t._start, n = null, o = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), o = 0, e = e.right;
      }
      const r = n[o++];
      return n.length <= o && (n = null), {
        done: !1,
        value: r
      };
    }
  };
}, T3 = (t, e) => {
  t.doc ?? Lt();
  const n = Kf(t, e);
  let o = t._start;
  for (n !== null && (o = n.p, e -= n.index); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (e < o.length)
        return o.content.getContent()[e];
      e -= o.length;
    }
}, ad = (t, e, n, o) => {
  let r = n;
  const i = t.doc, s = i.clientID, a = i.store, l = n === null ? e._start : n.right;
  let c = [];
  const u = () => {
    c.length > 0 && (r = new fn(ot(s, Qt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new Ls(c)), r.integrate(t, 0), c = []);
  };
  o.forEach((d) => {
    if (d === null)
      c.push(d);
    else
      switch (d.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(d);
          break;
        default:
          switch (u(), d.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              r = new fn(ot(s, Qt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new qf(new Uint8Array(
                /** @type {Uint8Array} */
                d
              ))), r.integrate(t, 0);
              break;
            case sc:
              r = new fn(ot(s, Qt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new Yf(
                /** @type {Doc} */
                d
              )), r.integrate(t, 0);
              break;
            default:
              if (d instanceof Mt)
                r = new fn(ot(s, Qt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new Wr(d)), r.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, O3 = () => $s("Length exceeded!"), M3 = (t, e, n, o) => {
  if (n > e._length)
    throw O3();
  if (n === 0)
    return e._searchMarker && Tl(e._searchMarker, n, o.length), ad(t, e, null, o);
  const r = n, i = Kf(e, n);
  let s = e._start;
  for (i !== null && (s = i.p, n -= i.index, n === 0 && (s = s.prev, n += s && s.countable && !s.deleted ? s.length : 0)); s !== null; s = s.right)
    if (!s.deleted && s.countable) {
      if (n <= s.length) {
        n < s.length && Rr(t, ot(s.id.client, s.id.clock + n));
        break;
      }
      n -= s.length;
    }
  return e._searchMarker && Tl(e._searchMarker, r, o.length), ad(t, e, s, o);
}, NY = (t, e, n) => {
  let r = (e._searchMarker || []).reduce((i, s) => s.index > i.index ? s : i, { index: 0, p: e._start }).p;
  if (r)
    for (; r.right; )
      r = r.right;
  return ad(t, e, r, n);
}, I3 = (t, e, n, o) => {
  if (o === 0)
    return;
  const r = n, i = o, s = Kf(e, n);
  let a = e._start;
  for (s !== null && (a = s.p, n -= s.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && Rr(t, ot(a.id.client, a.id.clock + n)), n -= a.length);
  for (; o > 0 && a !== null; )
    a.deleted || (o < a.length && Rr(t, ot(a.id.client, a.id.clock + o)), a.delete(t), o -= a.length), a = a.right;
  if (o > 0)
    throw O3();
  e._searchMarker && Tl(
    e._searchMarker,
    r,
    -i + o
    /* in case we remove the above exception */
  );
}, ld = (t, e, n) => {
  const o = e._map.get(n);
  o !== void 0 && o.delete(t);
}, dv = (t, e, n, o) => {
  const r = e._map.get(n) || null, i = t.doc, s = i.clientID;
  let a;
  if (o == null)
    a = new Ls([o]);
  else
    switch (o.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new Ls([o]);
        break;
      case Uint8Array:
        a = new qf(
          /** @type {Uint8Array} */
          o
        );
        break;
      case sc:
        a = new Yf(
          /** @type {Doc} */
          o
        );
        break;
      default:
        if (o instanceof Mt)
          a = new Wr(o);
        else
          throw new Error("Unexpected content type");
    }
  new fn(ot(s, Qt(i.store, s)), r, r && r.lastId, null, null, e, n, a).integrate(t, 0);
}, fv = (t, e) => {
  t.doc ?? Lt();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, R3 = (t) => {
  const e = {};
  return t.doc ?? Lt(), t._map.forEach((n, o) => {
    n.deleted || (e[o] = n.content.getContent()[n.length - 1]);
  }), e;
}, $3 = (t, e) => {
  t.doc ?? Lt();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, BY = (t, e) => {
  const n = {};
  return t._map.forEach((o, r) => {
    let i = o;
    for (; i !== null && (!e.sv.has(i.id.client) || i.id.clock >= (e.sv.get(i.id.client) || 0)); )
      i = i.left;
    i !== null && ns(i, e) && (n[r] = i.content.getContent()[i.length - 1]);
  }), n;
}, Uc = (t) => (t.doc ?? Lt(), pY(
  t._map.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
));
class FY extends Wf {
}
class Wa extends Mt {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new Wa();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new Wa();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new Wa();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof Mt ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this.doc ?? Lt(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), Gf(this, e, new FY(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? nt(this.doc, (o) => {
      M3(
        o,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? nt(this.doc, (n) => {
      NY(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? nt(this.doc, (o) => {
      I3(o, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return T3(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return _3(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return E3(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof Mt ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return A3(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Ol(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return DY(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(YY);
  }
}
class zY extends Wf {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, o) {
    super(e, n), this.keysChanged = o;
  }
}
class cd extends Mt {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((o, r) => {
      this.set(r, o);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new cd();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new cd();
    return this.forEach((n, o) => {
      e.set(o, n instanceof Mt ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Gf(this, e, new zY(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? Lt();
    const e = {};
    return this._map.forEach((n, o) => {
      if (!n.deleted) {
        const r = n.content.getContent()[n.length - 1];
        e[o] = r instanceof Mt ? r.toJSON() : r;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...Uc(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return eh(
      Uc(this),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return eh(
      Uc(this),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return eh(
      Uc(this),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this.doc ?? Lt(), this._map.forEach((n, o) => {
      n.deleted || e(n.content.getContent()[n.length - 1], o, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? nt(this.doc, (n) => {
      ld(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? nt(this.doc, (o) => {
      dv(
        o,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      fv(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return $3(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? nt(this.doc, (e) => {
      this.forEach(function(n, o, r) {
        ld(e, r, o);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(JY);
  }
}
const vr = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && Yq(t, e);
class Vm {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, o, r) {
    this.left = e, this.right = n, this.index = o, this.currentAttributes = r;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Ir(), this.right.content.constructor) {
      case kt:
        this.right.deleted || ea(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const vw = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case kt:
        e.right.deleted || ea(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && Rr(t, ot(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, jc = (t, e, n, o) => {
  const r = /* @__PURE__ */ new Map(), i = o ? Kf(e, n) : null;
  if (i) {
    const s = new Vm(i.p.left, i.p, i.index, r);
    return vw(t, s, n - i.index);
  } else {
    const s = new Vm(null, e._start, 0, r);
    return vw(t, s, n);
  }
}, P3 = (t, e, n, o) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === kt && vr(
    o.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || o.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const r = t.doc, i = r.clientID;
  o.forEach((s, a) => {
    const l = n.left, c = n.right, u = new fn(ot(i, Qt(r.store, i)), l, l && l.lastId, c, c && c.id, e, null, new kt(a, s));
    u.integrate(t, 0), n.right = u, n.forward();
  });
}, ea = (t, e) => {
  const { key: n, value: o } = e;
  o === null ? t.delete(n) : t.set(n, o);
}, L3 = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === kt && vr(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    ))) break;
    t.forward();
  }
}, D3 = (t, e, n, o) => {
  const r = t.doc, i = r.clientID, s = /* @__PURE__ */ new Map();
  for (const a in o) {
    const l = o[a], c = n.currentAttributes.get(a) ?? null;
    if (!vr(c, l)) {
      s.set(a, c);
      const { left: u, right: d } = n;
      n.right = new fn(ot(i, Qt(r.store, i)), u, u && u.lastId, d, d && d.id, e, null, new kt(a, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return s;
}, oh = (t, e, n, o, r) => {
  n.currentAttributes.forEach((f, p) => {
    r[p] === void 0 && (r[p] = null);
  });
  const i = t.doc, s = i.clientID;
  L3(n, r);
  const a = D3(t, e, n, r), l = o.constructor === String ? new Ko(
    /** @type {string} */
    o
  ) : o instanceof Mt ? new Wr(o) : new ta(o);
  let { left: c, right: u, index: d } = n;
  e._searchMarker && Tl(e._searchMarker, n.index, l.getLength()), u = new fn(ot(s, Qt(i.store, s)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(t, 0), n.right = u, n.index = d, n.forward(), P3(t, e, n, a);
}, yw = (t, e, n, o, r) => {
  const i = t.doc, s = i.clientID;
  L3(n, r);
  const a = D3(t, e, n, r);
  e: for (; n.right !== null && (o > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === kt)); ) {
    if (!n.right.deleted)
      switch (n.right.content.constructor) {
        case kt: {
          const { key: l, value: c } = (
            /** @type {ContentFormat} */
            n.right.content
          ), u = r[l];
          if (u !== void 0) {
            if (vr(u, c))
              a.delete(l);
            else {
              if (o === 0)
                break e;
              a.set(l, c);
            }
            n.right.delete(t);
          } else
            n.currentAttributes.set(l, c);
          break;
        }
        default:
          o < n.right.length && Rr(t, ot(n.right.id.client, n.right.id.clock + o)), o -= n.right.length;
          break;
      }
    n.forward();
  }
  if (o > 0) {
    let l = "";
    for (; o > 0; o--)
      l += `
`;
    n.right = new fn(ot(s, Qt(i.store, s)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new Ko(l)), n.right.integrate(t, 0), n.forward();
  }
  P3(t, e, n, a);
}, N3 = (t, e, n, o, r) => {
  let i = e;
  const s = ao();
  for (; i && (!i.countable || i.deleted); ) {
    if (!i.deleted && i.content.constructor === kt) {
      const c = (
        /** @type {ContentFormat} */
        i.content
      );
      s.set(c.key, c);
    }
    i = i.right;
  }
  let a = 0, l = !1;
  for (; e !== i; ) {
    if (n === e && (l = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case kt: {
          const { key: u, value: d } = (
            /** @type {ContentFormat} */
            c
          ), f = o.get(u) ?? null;
          (s.get(u) !== c || f === d) && (e.delete(t), a++, !l && (r.get(u) ?? null) === d && f !== d && (f === null ? r.delete(u) : r.set(u, f))), !l && !e.deleted && ea(
            r,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, HY = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === kt) {
      const o = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(o) ? e.delete(t) : n.add(o);
    }
    e = e.left;
  }
}, VY = (t) => {
  let e = 0;
  return nt(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let o = (
        /** @type {Item} */
        t._start
      ), r = t._start, i = ao();
      const s = Dm(i);
      for (; r; ) {
        if (r.deleted === !1)
          switch (r.content.constructor) {
            case kt:
              ea(
                s,
                /** @type {ContentFormat} */
                r.content
              );
              break;
            default:
              e += N3(n, o, r, i, s), i = Dm(s), o = r;
              break;
          }
        r = r.right;
      }
    }
  ), e;
}, UY = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [o, r] of t.afterState.entries()) {
    const i = t.beforeState.get(o) || 0;
    r !== i && x3(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(o),
      i,
      r,
      (s) => {
        !s.deleted && /** @type {Item} */
        s.content.constructor === kt && s.constructor !== dr && e.add(
          /** @type {any} */
          s.parent
        );
      }
    );
  }
  nt(n, (o) => {
    h3(t, t.deleteSet, (r) => {
      if (r instanceof dr || !/** @type {YText} */
      r.parent._hasFormatting || e.has(
        /** @type {YText} */
        r.parent
      ))
        return;
      const i = (
        /** @type {YText} */
        r.parent
      );
      r.content.constructor === kt ? e.add(i) : HY(o, r);
    });
    for (const r of e)
      VY(r);
  });
}, bw = (t, e, n) => {
  const o = n, r = Dm(e.currentAttributes), i = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Wr:
        case ta:
        case Ko:
          n < e.right.length && Rr(t, ot(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  i && N3(t, i, e.right, r, e.currentAttributes);
  const s = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return s._searchMarker && Tl(s._searchMarker, e.index, -o + n), e;
};
class jY extends Wf {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, o) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), o.forEach((r) => {
      r === null ? this.childListChanged = !0 : this.keysChanged.add(r);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      nt(e, (o) => {
        const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
        let s = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, d = 0;
        const f = () => {
          if (a !== null) {
            let p = null;
            switch (a) {
              case "delete":
                d > 0 && (p = { delete: d }), d = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (p = { insert: c }, r.size > 0 && (p.attributes = {}, r.forEach((m, g) => {
                  m !== null && (p.attributes[g] = m);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (p = { retain: u }, Kq(l) || (p.attributes = Uq({}, l))), u = 0;
                break;
            }
            p && n.push(p), a = null;
          }
        };
        for (; s !== null; ) {
          switch (s.content.constructor) {
            case Wr:
            case ta:
              this.adds(s) ? this.deletes(s) || (f(), a = "insert", c = s.content.getContent()[0], f()) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), d += 1) : s.deleted || (a !== "retain" && (f(), a = "retain"), u += 1);
              break;
            case Ko:
              this.adds(s) ? this.deletes(s) || (a !== "insert" && (f(), a = "insert"), c += /** @type {ContentString} */
              s.content.str) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), d += s.length) : s.deleted || (a !== "retain" && (f(), a = "retain"), u += s.length);
              break;
            case kt: {
              const { key: p, value: m } = (
                /** @type {ContentFormat} */
                s.content
              );
              if (this.adds(s)) {
                if (!this.deletes(s)) {
                  const g = r.get(p) ?? null;
                  vr(g, m) ? m !== null && s.delete(o) : (a === "retain" && f(), vr(m, i.get(p) ?? null) ? delete l[p] : l[p] = m);
                }
              } else if (this.deletes(s)) {
                i.set(p, m);
                const g = r.get(p) ?? null;
                vr(g, m) || (a === "retain" && f(), l[p] = g);
              } else if (!s.deleted) {
                i.set(p, m);
                const g = l[p];
                g !== void 0 && (vr(g, m) ? g !== null && s.delete(o) : (a === "retain" && f(), m === null ? delete l[p] : l[p] = m));
              }
              s.deleted || (a === "insert" && f(), ea(
                r,
                /** @type {ContentFormat} */
                s.content
              ));
              break;
            }
          }
          s = s.right;
        }
        for (f(); n.length > 0; ) {
          const p = n[n.length - 1];
          if (p.retain !== void 0 && p.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class Ml extends Mt {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? Lt(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((o) => o());
    } catch (o) {
      console.error(o);
    }
    this._pending = null;
  }
  _copy() {
    return new Ml();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new Ml();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const o = new jY(this, e, n);
    Gf(this, e, o), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? Lt();
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === Ko && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? nt(this.doc, (o) => {
      const r = new Vm(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (s.insert !== void 0) {
          const a = !n && typeof s.insert == "string" && i === e.length - 1 && r.right === null && s.insert.slice(-1) === `
` ? s.insert.slice(0, -1) : s.insert;
          (typeof a != "string" || a.length > 0) && oh(o, this, r, a, s.attributes || {});
        } else s.retain !== void 0 ? yw(o, this, r, s.retain, s.attributes || {}) : s.delete !== void 0 && bw(o, r, s.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, o) {
    this.doc ?? Lt();
    const r = [], i = /* @__PURE__ */ new Map(), s = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const d = {};
        let f = !1;
        i.forEach((m, g) => {
          f = !0, d[g] = m;
        });
        const p = { insert: a };
        f && (p.attributes = d), r.push(p), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (ns(l, e) || n !== void 0 && ns(l, n))
          switch (l.content.constructor) {
            case Ko: {
              const d = i.get("ychange");
              e !== void 0 && !ns(l, e) ? (d === void 0 || d.user !== l.id.client || d.type !== "removed") && (c(), i.set("ychange", o ? o("removed", l.id) : { type: "removed" })) : n !== void 0 && !ns(l, n) ? (d === void 0 || d.user !== l.id.client || d.type !== "added") && (c(), i.set("ychange", o ? o("added", l.id) : { type: "added" })) : d !== void 0 && (c(), i.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case Wr:
            case ta: {
              c();
              const d = {
                insert: l.content.getContent()[0]
              };
              if (i.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                d.attributes = f, i.forEach((p, m) => {
                  f[m] = p;
                });
              }
              r.push(d);
              break;
            }
            case kt:
              ns(l, e) && (c(), ea(
                i,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || n ? nt(s, (d) => {
      e && zm(d, e), n && zm(d, n), u();
    }, "cleanup") : u(), r;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, o) {
    if (n.length <= 0)
      return;
    const r = this.doc;
    r !== null ? nt(r, (i) => {
      const s = jc(i, this, e, !o);
      o || (o = {}, s.currentAttributes.forEach((a, l) => {
        o[l] = a;
      })), oh(i, this, s, n, o);
    }) : this._pending.push(() => this.insert(e, n, o));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, o) {
    const r = this.doc;
    r !== null ? nt(r, (i) => {
      const s = jc(i, this, e, !o);
      oh(i, this, s, n, o || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, o || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const o = this.doc;
    o !== null ? nt(o, (r) => {
      bw(r, jc(r, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, o) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? nt(r, (i) => {
      const s = jc(i, this, e, !1);
      s.right !== null && yw(i, this, s, n, o);
    }) : this._pending.push(() => this.format(e, n, o));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? nt(this.doc, (n) => {
      ld(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? nt(this.doc, (o) => {
      dv(o, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      fv(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return R3(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(XY);
  }
}
class rh {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0, e.doc ?? Lt();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === Il || n.constructor === Ps) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; ) {
            const o = e.next;
            if (o !== null) {
              e = o;
              break;
            } else e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
            e.parent._item;
          }
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class Ps extends Mt {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new Ps();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new Ps();
    return e.insert(0, this.toArray().map((n) => n instanceof Mt ? n.clone() : n)), e;
  }
  get length() {
    return this.doc ?? Lt(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new rh(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const o = new rh(this, (r) => r.nodeName && r.nodeName.toUpperCase() === e).next();
    return o.done ? null : o.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), Rs(new rh(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Gf(this, e, new WY(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return A3(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, o) {
    const r = e.createDocumentFragment();
    return o !== void 0 && o._createAssociation(r, this), Ol(this, (i) => {
      r.insertBefore(i.toDOM(e, n, o), null);
    }), r;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? nt(this.doc, (o) => {
      M3(o, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      nt(this.doc, (o) => {
        const r = e && e instanceof Mt ? e._item : e;
        ad(o, this, r, n);
      });
    else {
      const o = (
        /** @type {Array<any>} */
        this._prelimContent
      ), r = e === null ? 0 : o.findIndex((i) => i === e) + 1;
      if (r === 0 && e !== null)
        throw $s("Reference item not found");
      o.splice(r, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? nt(this.doc, (o) => {
      I3(o, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return _3(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return T3(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return E3(this, e, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Ol(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(QY);
  }
}
class Il extends Ps {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((o, r) => {
      this.setAttribute(r, o);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Il(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Il(this.nodeName), n = this.getAttributes();
    return Wq(n, (o, r) => {
      typeof o == "string" && e.setAttribute(r, o);
    }), e.insert(0, this.toArray().map((o) => o instanceof Mt ? o.clone() : o)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], o = [];
    for (const a in e)
      o.push(a);
    o.sort();
    const r = o.length;
    for (let a = 0; a < r; a++) {
      const l = o[a];
      n.push(l + '="' + e[l] + '"');
    }
    const i = this.nodeName.toLocaleLowerCase(), s = n.length > 0 ? " " + n.join(" ") : "";
    return `<${i}${s}>${super.toString()}</${i}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? nt(this.doc, (n) => {
      ld(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? nt(this.doc, (o) => {
      dv(o, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      fv(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      $3(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? BY(this, e) : R3(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, o) {
    const r = e.createElement(this.nodeName), i = this.getAttributes();
    for (const s in i) {
      const a = i[s];
      typeof a == "string" && r.setAttribute(s, a);
    }
    return Ol(this, (s) => {
      r.appendChild(s.toDOM(e, n, o));
    }), o !== void 0 && o._createAssociation(r, this), r;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(ZY), e.writeKey(this.nodeName);
  }
}
class WY extends Wf {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(e, n, o) {
    super(e, o), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((r) => {
      r === null ? this.childListChanged = !0 : this.attributesChanged.add(r);
    });
  }
}
class Rl extends Ml {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new Rl();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new Rl();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n, o) {
    const r = e.createTextNode(this.toString());
    return o !== void 0 && o._createAssociation(r, this), r;
  }
  toString() {
    return this.toDelta().map((e) => {
      const n = [];
      for (const r in e.attributes) {
        const i = [];
        for (const s in e.attributes[r])
          i.push({ key: s, value: e.attributes[r][s] });
        i.sort((s, a) => s.key < a.key ? -1 : 1), n.push({ nodeName: r, attrs: i });
      }
      n.sort((r, i) => r.nodeName < i.nodeName ? -1 : 1);
      let o = "";
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        o += `<${i.nodeName}`;
        for (let s = 0; s < i.attrs.length; s++) {
          const a = i.attrs[s];
          o += ` ${a.key}="${a.value}"`;
        }
        o += ">";
      }
      o += e.insert;
      for (let r = n.length - 1; r >= 0; r--)
        o += `</${n[r].nodeName}>`;
      return o;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(eJ);
  }
}
class B3 {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw lo();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, o) {
    throw lo();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw lo();
  }
}
const KY = 0;
class dr extends B3 {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), w3(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(KY), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class qf {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new qf(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw lo();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class ud {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ud(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new ud(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    v3(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const GY = (t, e) => new sc({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class Yf {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new Yf(GY(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw lo();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class ta {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ta(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw lo();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class kt {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new kt(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw lo();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const o = (
      /** @type {YText} */
      n.parent
    );
    o._searchMarker = null, o._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const qY = id("node_env") === "development";
class Ls {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e, qY && s3(e);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Ls(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new Ls(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const o = this.arr.length;
    e.writeLen(o - n);
    for (let r = n; r < o; r++) {
      const i = this.arr[r];
      e.writeAny(i);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class Ko {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Ko(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new Ko(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const o = this.str.charCodeAt(e - 1);
    return o >= 55296 && o <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", n.str = "�" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const YY = 0, JY = 1, XY = 2, ZY = 3, QY = 4, eJ = 6;
class Wr {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new Wr(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw lo();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((o) => {
      o.deleted ? o.id.clock < (e.beforeState.get(o.id.client) || 0) && e._mergeStructs.push(o) : o.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (o) => {
        for (; o !== null; )
          o.gc(e, !0), o = o.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const F3 = (t, e, n) => {
  const { client: o, clock: r } = e.id, i = new fn(
    ot(o, r + n),
    e,
    ot(o, r + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && i.markDeleted(), e.keep && (i.keep = !0), e.redone !== null && (i.redone = ot(e.redone.client, e.redone.clock + n)), e.right = i, i.right !== null && (i.right.left = i), t._mergeStructs.push(i), i.parentSub !== null && i.right === null && i.parent._map.set(i.parentSub, i), e.length = n, i;
};
let fn = class Um extends B3 {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, o, r, i, s, a, l) {
    super(e, l.getLength()), this.origin = o, this.left = n, this.right = r, this.rightOrigin = i, this.parent = s, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? ew : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & Xp) > 0 !== e && (this.info ^= Xp);
  }
  get marker() {
    return (this.info & Xp) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & Qb) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= Qb);
  }
  get countable() {
    return (this.info & ew) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Jp) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= Jp);
  }
  markDeleted() {
    this.info |= Jp;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Qt(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Qt(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === wu && this.id.client !== this.parent.client && this.parent.clock >= Qt(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = pw(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Rr(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === dr || this.right && this.right.constructor === dr)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === Um ? (this.parent = this.left.parent, this.parentSub = this.left.parentSub) : this.right && this.right.constructor === Um && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === wu) {
      const o = nh(n, this.parent);
      o.constructor === dr ? this.parent = null : this.parent = /** @type {ContentType} */
      o.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = pw(e, e.doc.store, ot(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let o = this.left, r;
        if (o !== null)
          r = o.right;
        else if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start;
        const i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
        for (; r !== null && r !== this.right; ) {
          if (s.add(r), i.add(r), Hc(this.origin, r.origin)) {
            if (r.id.client < this.id.client)
              o = r, i.clear();
            else if (Hc(this.rightOrigin, r.rightOrigin))
              break;
          } else if (r.origin !== null && s.has(nh(e.doc.store, r.origin)))
            i.has(nh(e.doc.store, r.origin)) || (o = r, i.clear());
          else
            break;
          r = r.right;
        }
        this.left = o;
      }
      if (this.left !== null) {
        const o = this.left.right;
        this.right = o, this.left.right = this;
      } else {
        let o;
        if (this.parentSub !== null)
          for (o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; o !== null && o.left !== null; )
            o = o.left;
        else
          o = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = o;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), w3(e.doc.store, this), this.content.integrate(e, this), mw(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new dr(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : ot(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Hc(e.origin, this.lastId) && this.right === e && Hc(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((o) => {
        o.p === e && (o.p = this, !this.deleted && this.countable && (o.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), v3(e.deleteSet, this.id.client, this.id.clock, this.length), mw(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw Ir();
    this.content.gc(e), n ? TY(e, this, new dr(this.id, this.length)) : this.content = new ud(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const o = n > 0 ? ot(this.id.client, this.id.clock + n - 1) : this.origin, r = this.rightOrigin, i = this.parentSub, s = this.content.getRef() & vq | (o === null ? 0 : rd) | // origin is defined
    (r === null ? 0 : o3) | // right origin is defined
    (i === null ? 0 : gq);
    if (e.writeInfo(s), o !== null && e.writeLeftID(o), r !== null && e.writeRightID(r), o === null && r === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = Al(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === wu ? (e.writeParentInfo(!1), e.writeLeftID(a)) : Ir();
      i !== null && e.writeString(i);
    }
    this.content.write(e, n);
  }
};
const z3 = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), H3 = "__ $YJS$ __";
z3[H3] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
z3[H3] = !0;
const tJ = new Ne("y-sync");
new Ne("y-undo");
new Ne("yjs-cursor");
const nJ = (t, e, n) => {
  if (t === 0)
    return th(e, 0, -1);
  let o = e._first === null ? null : (
    /** @type {Y.ContentType} */
    e._first.content.type
  );
  for (; o !== null && e !== o; ) {
    if (o instanceof Rl) {
      if (o._length >= t)
        return th(o, t, -1);
      if (t -= o._length, o._item !== null && o._item.next !== null)
        o = /** @type {Y.ContentType} */
        o._item.next.content.type;
      else {
        do
          o = o._item === null ? null : o._item.parent, t--;
        while (o !== e && o !== null && o._item !== null && o._item.next === null);
        o !== null && o !== e && (o = o._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          o._item.next.content.type
        ));
      }
    } else {
      const r = (
        /** @type {any} */
        (n.get(o) || { nodeSize: 0 }).nodeSize
      );
      if (o._first !== null && t < r)
        o = /** @type {Y.ContentType} */
        o._first.content.type, t--;
      else {
        if (t === 1 && o._length === 0 && r > 1)
          return new sd(o._item === null ? null : o._item.id, o._item === null ? Al(o) : null, null);
        if (t -= r, o._item !== null && o._item.next !== null)
          o = /** @type {Y.ContentType} */
          o._item.next.content.type;
        else {
          if (t === 0)
            return o = o._item === null ? o : o._item.parent, new sd(o._item === null ? null : o._item.id, o._item === null ? Al(o) : null, null);
          do
            o = /** @type {Y.Item} */
            o._item.parent, t--;
          while (o !== e && /** @type {Y.Item} */
          o._item.next === null);
          o !== e && (o = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          o._item.next.content.type);
        }
      }
    }
    if (o === null)
      throw Ir();
    if (t === 0 && o.constructor !== Rl && o !== e)
      return oJ(o._item.parent, o._item);
  }
  return th(e, e._length, -1);
}, oJ = (t, e) => {
  let n = null, o = null;
  return t._item === null ? o = Al(t) : n = ot(t._item.id.client, t._item.id.clock), new sd(n, o, e.id);
};
function pv(t, e, n) {
  const o = [], r = t.node(0);
  n = typeof n == "number" && n >= 0 ? n : t.sameParent(e) ? Math.max(0, t.sharedDepth(e.pos) - 1) : t.sharedDepth(e.pos);
  const i = new nl(t, e, n), s = i.depth === 0 ? 0 : r.resolve(i.start).posAtIndex(0);
  return i.parent.forEach((a, l) => {
    const c = s + l, u = c + a.nodeSize;
    if (c < i.start || c >= i.end) return;
    const d = new Og(r.resolve(c), r.resolve(u));
    o.push(d);
  }), o;
}
class hv {
  constructor(e, n) {
    fa(this, "anchor");
    fa(this, "head");
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new hv(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), o = e.resolve(this.head);
    return new eo(n, o);
  }
}
class eo extends fe {
  constructor(n, o, r, i = 1) {
    const { doc: s } = n, a = n === o, l = n.pos === s.content.size && o.pos === s.content.size, c = a && !l ? s.resolve(o.pos + (i > 0 ? 1 : -1)) : o, u = a && l ? s.resolve(n.pos - (i > 0 ? 1 : -1)) : n, d = pv(u.min(c), u.max(c), r);
    super(
      c.pos >= n.pos ? d[0].$from : d[d.length - 1].$to,
      c.pos >= n.pos ? d[d.length - 1].$to : d[0].$from,
      d
    );
    fa(this, "depth");
    this.depth = r;
  }
  get $to() {
    return this.ranges[this.ranges.length - 1].$to;
  }
  eq(n) {
    return n instanceof eo && n.$from.pos === this.$from.pos && n.$to.pos === this.$to.pos;
  }
  map(n, o) {
    const r = n.resolve(o.map(this.anchor)), i = n.resolve(o.map(this.head));
    return new eo(r, i);
  }
  toJSON() {
    return { type: "nodeRange", anchor: this.anchor, head: this.head };
  }
  get isForwards() {
    return this.head >= this.anchor;
  }
  get isBackwards() {
    return !this.isForwards;
  }
  extendBackwards() {
    const { doc: n } = this.$from;
    if (this.isForwards && this.ranges.length > 1) {
      const i = this.ranges.slice(0, -1), s = i[0].$from, a = i[i.length - 1].$to;
      return new eo(s, a, this.depth);
    }
    const o = this.ranges[0], r = n.resolve(Math.max(0, o.$from.pos - 1));
    return new eo(this.$anchor, r, this.depth);
  }
  extendForwards() {
    const { doc: n } = this.$from;
    if (this.isBackwards && this.ranges.length > 1) {
      const i = this.ranges.slice(1), s = i[0].$from, a = i[i.length - 1].$to;
      return new eo(a, s, this.depth);
    }
    const o = this.ranges[this.ranges.length - 1], r = n.resolve(Math.min(n.content.size, o.$to.pos + 1));
    return new eo(this.$anchor, r, this.depth);
  }
  static fromJSON(n, o) {
    return new eo(n.resolve(o.anchor), n.resolve(o.head));
  }
  static create(n, o, r, i, s = 1) {
    return new this(n.resolve(o), n.resolve(r), i, s);
  }
  getBookmark() {
    return new hv(this.anchor, this.head);
  }
}
function rJ(t) {
  const e = t.cloneNode(!0), n = [t, ...Array.from(t.getElementsByTagName("*"))], o = [e, ...Array.from(e.getElementsByTagName("*"))];
  return n.forEach((r, i) => {
    o[i].style.cssText = function(s) {
      let a = "";
      const l = getComputedStyle(s);
      for (let c = 0; c < l.length; c += 1)
        a += `${l[c]}:${l.getPropertyValue(l[c])};`;
      return a;
    }(r);
  }), e;
}
function Wc(t, e) {
  return window.getComputedStyle(t)[e];
}
function iJ(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function ww(t) {
  t.parentNode !== null && t.parentNode !== void 0 && t.parentNode.removeChild(t);
}
const V3 = (t) => {
  const { x: e, y: n, direction: o, editor: r } = t;
  let i = null, s = null, a = null, l = e;
  for (; s === null && l < window.innerWidth && l > 0; ) {
    const c = document.elementsFromPoint(l, n), u = c.findIndex((f) => f.classList.contains("ProseMirror")), d = c.slice(0, u);
    if (d.length > 0) {
      const f = d[0];
      if (i = f, a = r.view.posAtDOM(f, 0), a >= 0) {
        s = r.state.doc.nodeAt(Math.max(a - 1, 0)), (s === null || s.isText) && (s = r.state.doc.nodeAt(Math.max(a - 1, 0))), s || (s = r.state.doc.nodeAt(Math.max(a, 0)));
        break;
      }
    }
    o === "left" ? l -= 1 : l += 1;
  }
  return {
    resultElement: i,
    resultNode: s,
    pos: a !== null ? a : null
  };
};
function sJ(t, e) {
  const { doc: n } = e.view.state, o = V3({ editor: e, x: t.clientX, y: t.clientY, direction: "right" });
  if (!o.resultNode || o.pos === null) return [];
  const r = t.clientX, i = function(u, d, f) {
    const p = parseInt(Wc(u.dom, "paddingLeft"), 10), m = parseInt(Wc(u.dom, "paddingRight"), 10), g = parseInt(Wc(u.dom, "borderLeftWidth"), 10), v = parseInt(Wc(u.dom, "borderLeftWidth"), 10), y = u.dom.getBoundingClientRect();
    return {
      left: iJ(
        d,
        y.left + p + g,
        y.right - m - v
      ),
      top: f
    };
  }(e.view, r, t.clientY), s = e.view.posAtCoords(i);
  if (!s) return [];
  const { pos: a } = s;
  if (!n.resolve(a).parent) return [];
  const l = n.resolve(o.pos), c = n.resolve(o.pos + 1);
  return pv(l, c, 0);
}
const xw = (t, e) => {
  const n = t.resolve(e), { depth: o } = n;
  return o === 0 ? e : n.pos - n.parentOffset - 1;
}, Cw = (t, e) => {
  const n = t.nodeAt(e), o = t.resolve(e);
  let { depth: r } = o, i = n;
  for (; r > 0; ) {
    const s = o.node(r);
    r -= 1, r === 0 && (i = s);
  }
  return i;
}, ih = (t, e) => {
  const n = tJ.getState(t);
  return n ? nJ(e, n.type, n.binding.mapping) : null;
}, Sw = (t, e) => {
  let n = e;
  for (; n && n.parentNode && n.parentNode !== t.dom; ) n = n.parentNode;
  return n;
}, aJ = new Ne("dragHandle"), lJ = ({
  pluginKey: t = aJ,
  element: e,
  editor: n,
  tippyOptions: o,
  onNodeChange: r
}) => {
  const i = document.createElement("div");
  let s = null, a = !1, l = null, c = -1;
  return e.addEventListener("dragstart", (u) => {
    const { view: d } = n;
    if (!u.dataTransfer) return;
    const { empty: f, $from: p, $to: m } = d.state.selection, g = sJ(u, n), v = pv(p, m, 0), y = v.some((O) => g.find((M) => M.$from === O.$from && M.$to === O.$to)), w = f || !y ? g : v;
    if (!w.length) return;
    const { tr: x } = d.state, b = document.createElement("div"), S = w[0].$from.pos, k = w[w.length - 1].$to.pos, A = eo.create(d.state.doc, S, k), $ = A.content();
    w.forEach((O) => {
      const M = rJ(d.nodeDOM(O.$from.pos));
      b.append(M);
    }), b.style.position = "absolute", b.style.top = "-10000px", document.body.append(b), u.dataTransfer.clearData(), u.dataTransfer.setDragImage(b, 0, 0), d.dragging = { slice: $, move: !0 }, x.setSelection(A), d.dispatch(x), document.addEventListener("drop", () => ww(b), { once: !0 }), setTimeout(() => {
      e && (e.style.pointerEvents = "none");
    }, 0);
  }), e.addEventListener("dragend", () => {
    e && (e.style.pointerEvents = "auto");
  }), new De({
    key: typeof t == "string" ? new Ne(t) : t,
    state: {
      init: () => ({ locked: !1 }),
      apply(u, d, f, p) {
        const m = u.getMeta("lockDragHandle"), g = u.getMeta("hideDragHandle");
        if (m !== void 0 && (a = m), g && s)
          return s.hide(), a = !1, l = null, c = -1, r == null || r({ editor: n, node: null, pos: -1 }), d;
        if (u.docChanged && c !== -1 && e && s) {
          const v = u.mapping.map(c);
          v !== c && (c = v, ih(p.doc, c));
        }
        return d;
      }
    },
    view: (u) => {
      return d(), f(n.view.dom), s = Fr(u.dom, {
        ...p(),
        ...o
      }), {
        update(b, S) {
          if (!m(e, s) || (e.draggable = !a, !g(b, S)))
            return;
          const k = v(b);
          k && y(b, k);
        },
        destroy() {
          x();
        }
      };
      function d() {
        e.draggable = !0, e.style.pointerEvents = "auto";
      }
      function f(b) {
        var S;
        (S = b.parentElement) == null || S.appendChild(i), i.appendChild(e), Object.assign(i.style, {
          pointerEvents: "none",
          position: "absolute",
          top: "0",
          left: "0"
        });
      }
      function p() {
        return {
          getReferenceClientRect: null,
          interactive: !0,
          trigger: "manual",
          placement: "left-start",
          hideOnClick: !1,
          duration: 100,
          zIndex: 10,
          appendTo: i,
          content: e,
          popperOptions: {
            modifiers: [
              { name: "flip", enabled: !1 },
              {
                name: "preventOverflow",
                options: {
                  rootBoundary: "document",
                  mainAxis: !1
                }
              }
            ]
          }
        };
      }
      function m(b, S) {
        return b && S;
      }
      function g(b, S) {
        return !b.state.doc.eq(S.doc) && c !== -1;
      }
      function v(b) {
        let S = b.nodeDOM(c);
        return S = Sw(b, S), S === b.dom || (S == null ? void 0 : S.nodeType) !== 1 ? null : S;
      }
      function y(b, S) {
        const k = b.posAtDOM(S, 0), A = Cw(n.state.doc, k);
        if (A === l)
          return;
        const $ = xw(n.state.doc, k);
        l = A, c = $, ih(n.state.doc, c), r == null || r({
          editor: n,
          node: l,
          pos: c
        }), w(S);
      }
      function w(b) {
        s.setProps({
          getReferenceClientRect: () => b.getBoundingClientRect()
        }), s.show();
      }
      function x() {
        s == null || s.destroy(), e && ww(i);
      }
    },
    props: {
      handleDOMEvents: {
        mouseleave: (u, d) => {
          if (a || !f(d)) return !1;
          return p(), m(), !1;
          function f(g) {
            return g.target && !i.contains(g.relatedTarget);
          }
          function p() {
            s == null || s.hide();
          }
          function m() {
            l = null, c = -1, r == null || r({
              editor: n,
              node: null,
              pos: -1
            });
          }
        },
        mousemove: HS((u, d) => {
          if (!e || !s || a)
            return !1;
          const f = V3({
            x: d.clientX,
            y: d.clientY,
            direction: "right",
            editor: n
          });
          if (!f.resultElement || f.resultElement === u.dom)
            return !1;
          const p = Sw(u, f.resultElement);
          if (p === u.dom || (p == null ? void 0 : p.nodeType) !== 1)
            return !1;
          const m = u.posAtDOM(p, 0), g = Cw(n.state.doc, m);
          if (g === l)
            return !1;
          const v = xw(n.state.doc, m);
          return l = g, c = v, ih(u.state, c), r == null || r({
            editor: n,
            node: l,
            pos: c
          }), s.setProps({
            getReferenceClientRect: () => p.getBoundingClientRect()
          }), s.show(), !1;
        }, 100)
      }
    }
  });
}, cJ = /* @__PURE__ */ I({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(GU), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uJ = /* @__PURE__ */ I({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(Em), null, {
      default: C(() => [
        _(h(YU), j(h(i), {
          class: h(ve)("z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", n.class)
        }), {
          default: C(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), qi = /* @__PURE__ */ I({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(JU), j(h(o), {
      class: h(ve)(
        "relative flex cursor-default select-none items-center rounded-sm gap-2 px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50  [&>svg]:size-4 [&>svg]:shrink-0",
        r.inset && "pl-8",
        e.class
      )
    }), {
      default: C(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dJ = /* @__PURE__ */ I({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(XU), j(n.value, {
      class: h(ve)("-mx-1 my-1 h-px bg-muted", e.class)
    }), null, 16, ["class"]));
  }
}), kw = /* @__PURE__ */ I({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(ej), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ew = /* @__PURE__ */ I({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(tj), j(h(i), {
      class: h(ve)("z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", n.class)
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _w = /* @__PURE__ */ I({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(nj), j(h(o), {
      class: h(ve)(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        e.class
      )
    }), {
      default: C(() => [
        D(r.$slots, "default"),
        _(h(bK), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fJ = /* @__PURE__ */ I({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const n = vt(t);
    return (o, r) => (E(), T(h(qU), j({ class: "outline-none" }, h(n)), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Io = /* @__PURE__ */ ((t) => (t[t.max = 7] = "max", t[t.min = 0] = "min", t[t.more = 1] = "more", t[t.less = -1] = "less", t))(Io || {});
function pJ(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
function hJ(t, e, n, o) {
  const { doc: r, selection: i } = t;
  if (!r || !i || !(i instanceof ce || i instanceof Wt))
    return t;
  const { from: s, to: a } = i;
  return r.nodesBetween(s, a, (l, c) => {
    const u = l.type;
    return n.includes(u.name) ? (t = jm(t, c, e), !1) : !Yh(l.type.name, o.extensionManager.extensions);
  }), t;
}
function jm(t, e, n) {
  if (!t.doc) return t;
  const o = t.doc.nodeAt(e);
  if (!o) return t;
  const s = pJ((o.attrs.indent || 0) + n, 0, 7);
  if (s === o.attrs.indent) return t;
  const a = {
    ...o.attrs,
    indent: s
  };
  return t.setNodeMarkup(e, o.type, a, o.marks);
}
function Aw({ delta: t, types: e }) {
  return ({ state: n, dispatch: o, editor: r }) => {
    const { selection: i } = n;
    let { tr: s } = n;
    return s = s.setSelection(i), s = hJ(s, t, e, r), s.docChanged ? (o && o(s), !0) : !1;
  };
}
const mJ = {
  class: "flex items-center gap-0.5",
  style: { "transition-property": "top, left", "transition-timing-function": "ease-in-out", "transition-duration": "0.2s" }
}, gJ = { class: "ml-auto text-xs text-neutral-400" }, vJ = { class: "ml-auto text-xs text-neutral-400" }, yJ = { class: "ml-auto text-xs text-neutral-400" }, bJ = { class: "ml-auto text-xs text-neutral-400" }, wJ = { class: "ml-auto text-xs text-neutral-400" }, xJ = /* @__PURE__ */ I({
  __name: "ContentMenu",
  props: {
    className: { default: "drag-handle" },
    editor: {},
    disabled: { type: Boolean, default: !1 },
    pluginKey: { default: "ContentItemMenu" }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = R(null), r = R(null), i = R(null), s = R(-1), a = R(!1);
    be(() => {
      o.value && !e.editor.isDestroyed && (r.value = lJ({
        editor: e.editor,
        element: o.value,
        pluginKey: e.pluginKey,
        tippyOptions: {
          offset: [-2, 16],
          zIndex: 9,
          moveTransition: "transform 0.15s ease-out"
        },
        onNodeChange: g
      }), e.editor.registerPlugin(r.value));
    }), Nt(() => {
      r.value && e.editor.unregisterPlugin(e.pluginKey);
    });
    function l() {
      var w;
      const y = e.editor.chain();
      y.setNodeSelection(s.value).unsetAllMarks(), ((w = i.value) == null ? void 0 : w.type.name) !== "paragraph" && y.setParagraph(), y.run();
    }
    function c() {
      e.editor.commands.setNodeSelection(s.value), document.execCommand("copy");
    }
    function u() {
      var x;
      e.editor.commands.setNodeSelection(s.value);
      const { $anchor: y } = e.editor.state.selection, w = y.node(1) || e.editor.state.selection.node;
      e.editor.chain().setMeta("hideDragHandle", !0).insertContentAt(s.value + (((x = i.value) == null ? void 0 : x.nodeSize) || 0), w.toJSON()).focus().run();
    }
    function d(y) {
      e.editor.chain().setTextAlign(y).run();
    }
    function f() {
      const y = jm(e.editor.state.tr, s.value, 1);
      y.setMeta("hideDragHandle", !0), e.editor.view.dispatch && e.editor.view.dispatch(y);
    }
    function p() {
      const y = jm(e.editor.state.tr, s.value, -1);
      e.editor.view.dispatch && e.editor.view.dispatch(y);
    }
    function m() {
      e.editor.chain().setMeta("hideDragHandle", !0).setNodeSelection(s.value).deleteSelection().run();
    }
    function g(y) {
      y.node && (i.value = y.node), s.value = y.pos;
    }
    function v() {
      var y, w, x, b;
      if (e.editor.isEditable && s.value !== -1) {
        const S = ((y = i.value) == null ? void 0 : y.nodeSize) || 0, k = s.value + S, A = ((w = i.value) == null ? void 0 : w.type.name) === "paragraph" && ((b = (x = i.value) == null ? void 0 : x.content) == null ? void 0 : b.size) === 0, $ = A ? s.value + 2 : k + 2;
        e.editor.chain().command(({ dispatch: O, tr: M, state: P }) => O ? (A ? M.insertText("/", s.value, s.value + 1) : M.insert(k, P.schema.nodes.paragraph.create(null, [P.schema.text("/")])), O(M)) : !0).focus($).run();
      }
    }
    return le(
      () => a.value,
      (y) => {
        y ? (e.editor.commands.setHighlightParagraph(s.value), e.editor.commands.setMeta("lockDragHandle", !0)) : (e.editor.commands.clearHighlightParagraph(), e.editor.commands.setMeta("lockDragHandle", !1));
      }
    ), le(
      () => e.editor.isDestroyed,
      (y) => {
        y && r.value && (e.editor.unregisterPlugin(e.pluginKey), r.value = null);
      }
    ), (y, w) => {
      const x = uq;
      return Vn((E(), W("div", {
        class: He(y.className),
        ref_key: "dragElement",
        ref: o,
        style: { "transition-property": "top, left", "transition-timing-function": "ease-in-out", "transition-duration": "0.2s" }
      }, [
        N("div", mJ, [
          h(Fe)(y.editor, "slashCommand") ? (E(), T(h(Rt), {
            key: 0,
            variant: "ghost",
            onClick: v,
            size: "icon",
            class: "w-7 h-7 cursor-grab rounded-sm",
            disabled: y.disabled
          }, {
            default: C(() => [
              _(h(ye), {
                name: "Plus",
                class: "text-lg text-neutral-600 dark:text-neutral-200"
              })
            ]),
            _: 1
          }, 8, ["disabled"])) : oe("", !0),
          _(h(cJ), {
            open: a.value,
            "onUpdate:open": w[3] || (w[3] = (b) => a.value = b)
          }, {
            default: C(() => [
              _(h(fJ), { disable: y.disabled }, {
                default: C(() => [
                  _(h(Fn), { "delay-duration": 0 }, {
                    default: C(() => [
                      _(h(Nn), null, {
                        default: C(() => [
                          _(h(zn), { "as-child": "" }, {
                            default: C(() => [
                              _(h(Rt), {
                                variant: "ghost",
                                size: "icon",
                                class: "w-6 h-7 cursor-grab rounded-sm",
                                disabled: y.disabled
                              }, {
                                default: C(() => [
                                  _(h(ye), {
                                    name: "Grip",
                                    class: "text-sm dark:text-neutral-200 text-neutral-600"
                                  })
                                ]),
                                _: 1
                              }, 8, ["disabled"])
                            ]),
                            _: 1
                          }),
                          _(h(Bn), null, {
                            default: C(() => [
                              N("p", null, Y(h(n)("editor.draghandle.tooltip")), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["disable"]),
              _(h(uJ), {
                class: "w-48",
                align: "start",
                side: "bottom"
              }, {
                default: C(() => [
                  _(h(qi), {
                    onClick: m,
                    class: "flex gap-3 focus:text-red-500 focus:bg-red-400 hover:bg-red-400 dark:hover:text-red-500 bg-opacity-10 hover:bg-opacity-20 focus:bg-opacity-30 dark:hover:bg-opacity-20"
                  }, {
                    default: C(() => [
                      _(h(ye), { name: "Trash2" }),
                      N("span", null, Y(h(n)("editor.remove")), 1)
                    ]),
                    _: 1
                  }),
                  _(h(qi), {
                    class: "flex gap-3",
                    onClick: l
                  }, {
                    default: C(() => [
                      _(h(ye), { name: "PaintRoller" }),
                      N("span", null, Y(h(n)("editor.clear.tooltip")), 1)
                    ]),
                    _: 1
                  }),
                  _(h(qi), {
                    class: "flex gap-3",
                    onClick: c
                  }, {
                    default: C(() => [
                      _(h(ye), { name: "Clipboard" }),
                      N("span", null, Y(h(n)("editor.copyToClipboard")), 1)
                    ]),
                    _: 1
                  }),
                  _(h(qi), {
                    class: "flex gap-3",
                    onClick: u
                  }, {
                    default: C(() => [
                      _(h(ye), { name: "Copy" }),
                      N("span", null, Y(h(n)("editor.copy")), 1)
                    ]),
                    _: 1
                  }),
                  h(Fe)(y.editor, "textAlign") || h(Fe)(y.editor, "indent") ? (E(), T(h(dJ), { key: 0 })) : oe("", !0),
                  h(Fe)(y.editor, "textAlign") ? (E(), T(h(kw), { key: 1 }, {
                    default: C(() => [
                      _(h(_w), { class: "flex gap-3" }, {
                        default: C(() => [
                          _(h(ye), { name: "AlignCenter" }),
                          N("span", null, Y(h(n)("editor.textalign.tooltip")), 1)
                        ]),
                        _: 1
                      }),
                      _(h(Em), null, {
                        default: C(() => [
                          _(h(Ew), null, {
                            default: C(() => [
                              _(x, {
                                "model-value": y.editor.isActive({ textAlign: "left" }) ?? !1,
                                class: "flex gap-3",
                                onClick: w[0] || (w[0] = (b) => d("left"))
                              }, {
                                default: C(() => [
                                  _(h(ye), { name: "AlignLeft" }),
                                  N("span", null, Y(h(n)("editor.textalign.left.tooltip")), 1),
                                  N("span", gJ, Y(h(Ro)(["Mod", "Shift", "L"])), 1)
                                ]),
                                _: 1
                              }, 8, ["model-value"]),
                              _(x, {
                                "model-value": y.editor.isActive({ textAlign: "center" }) ?? !1,
                                class: "flex gap-3",
                                onClick: w[1] || (w[1] = (b) => d("center"))
                              }, {
                                default: C(() => [
                                  _(h(ye), { name: "AlignCenter" }),
                                  N("span", null, Y(h(n)("editor.textalign.center.tooltip")), 1),
                                  N("span", vJ, Y(h(Ro)(["Mod", "Shift", "E"])), 1)
                                ]),
                                _: 1
                              }, 8, ["model-value"]),
                              _(x, {
                                "model-value": y.editor.isActive({ textAlign: "right" }) ?? !1,
                                class: "flex gap-3",
                                onClick: w[2] || (w[2] = (b) => d("right"))
                              }, {
                                default: C(() => [
                                  _(h(ye), { name: "AlignRight" }),
                                  N("span", null, Y(h(n)("editor.textalign.right.tooltip")), 1),
                                  N("span", yJ, Y(h(Ro)(["Mod", "Shift", "R"])), 1)
                                ]),
                                _: 1
                              }, 8, ["model-value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : oe("", !0),
                  h(Fe)(y.editor, "indent") ? (E(), T(h(kw), { key: 2 }, {
                    default: C(() => [
                      _(h(_w), { class: "flex gap-3" }, {
                        default: C(() => [
                          _(h(ye), { name: "IndentIncrease" }),
                          N("span", null, Y(h(n)("editor.indent")), 1)
                        ]),
                        _: 1
                      }),
                      _(h(Em), null, {
                        default: C(() => [
                          _(h(Ew), null, {
                            default: C(() => {
                              var b, S, k, A;
                              return [
                                _(h(qi), {
                                  class: "flex gap-3",
                                  onClick: f,
                                  disabled: ((S = (b = i.value) == null ? void 0 : b.attrs) == null ? void 0 : S.indent) >= h(Io).max
                                }, {
                                  default: C(() => [
                                    _(h(ye), { name: "IndentIncrease" }),
                                    N("span", null, Y(h(n)("editor.indent.tooltip")), 1),
                                    N("span", bJ, Y(h(Ro)(["Tab"])), 1)
                                  ]),
                                  _: 1
                                }, 8, ["disabled"]),
                                _(h(qi), {
                                  class: "flex gap-3",
                                  onClick: p,
                                  disabled: ((A = (k = i.value) == null ? void 0 : k.attrs) == null ? void 0 : A.indent) <= h(Io).min
                                }, {
                                  default: C(() => [
                                    _(h(ye), { name: "IndentDecrease" }),
                                    N("span", null, Y(h(n)("editor.outdent.tooltip")), 1),
                                    N("span", wJ, Y(h(Ro)(["Shift", "Tab"])), 1)
                                  ]),
                                  _: 1
                                }, 8, ["disabled"])
                              ];
                            }),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : oe("", !0)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["open"])
        ])
      ], 2)), [
        [no, !y.disabled]
      ]);
    };
  }
}), CJ = Ze.create({
  name: "column",
  content: "block+",
  isolating: !0,
  addAttributes() {
    return {
      position: {
        default: "",
        parseHTML: (t) => t.getAttribute("data-position"),
        renderHTML: (t) => ({ "data-position": t.position })
      }
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", Le(t, { "data-type": "column" }), 0];
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="column"]'
      }
    ];
  }
});
var oi = /* @__PURE__ */ ((t) => (t.SidebarLeft = "sidebar-left", t.SidebarRight = "sidebar-right", t.TwoColumn = "two-column", t))(oi || {});
const cre = Ze.create({
  name: "columns",
  group: "columns",
  content: "column+",
  defining: !0,
  isolating: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      layout: "two-column"
      /* TwoColumn */
    };
  },
  addAttributes() {
    return {
      layout: {
        default: "two-column"
        /* TwoColumn */
      }
    };
  },
  addCommands() {
    return {
      setColumns: () => ({ commands: t }) => (t.insertContent(
        '<div data-type="columns"><div data-type="column" data-position="left"><p></p></div><div data-type="column" data-position="right"><p></p></div></div>'
      ), !0),
      setLayout: (t) => ({ commands: e }) => e.updateAttributes("columns", { layout: t })
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", { "data-type": "columns", class: `layout-${t.layout}` }, 0];
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="columns"]'
      }
    ];
  },
  addExtensions() {
    return [CJ.configure(this.options.columnOptions)];
  }
}), U3 = (t, e) => {
  const {
    view: n,
    state: {
      selection: { from: o }
    }
  } = t, r = document.querySelectorAll(".focus"), i = r.length, a = r[i - 1];
  if (a && a.getAttribute("data-type") && a.getAttribute("data-type") === e || a && a.classList && a.classList.contains(e))
    return a;
  const l = n.domAtPos(o).node;
  let c = l;
  for (c.tagName || (c = l.parentElement); c && !(c.getAttribute("data-type") && c.getAttribute("data-type") === e) && !c.classList.contains(e); )
    c = c.parentElement;
  return c;
}, SJ = { class: "p-2 bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800" }, kJ = { class: "flex gap-1 items-center" }, EJ = /* @__PURE__ */ I({
  __name: "ColumnsBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = ({ editor: a }) => df(a.view.state, "columns"), o = () => {
      const a = U3(e.editor, "columns");
      return (a == null ? void 0 : a.getBoundingClientRect()) || new DOMRect(-1e3, -1e3, 0, 0);
    }, r = () => {
      e.editor.chain().focus().setLayout(oi.SidebarLeft).run();
    }, i = () => {
      e.editor.chain().focus().setLayout(oi.SidebarRight).run();
    }, s = () => {
      e.editor.chain().focus().setLayout(oi.TwoColumn).run();
    };
    return (a, l) => (E(), T(h(zs), {
      editor: a.editor,
      pluginKey: "columns",
      shouldShow: n,
      updateDelay: 0,
      "tippy-options": {
        offset: [0, 8],
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        getReferenceClientRect: o,
        plugins: [h(s1)],
        sticky: "popper"
      }
    }, {
      default: C(() => [
        N("div", SJ, [
          N("div", kJ, [
            _(ge, {
              icon: "PanelLeft",
              tooltip: "左侧边栏",
              action: r,
              isActive: () => a.editor.isActive("columns", { layout: h(oi).SidebarLeft }),
              "tooltip-options": { sideOffset: 15 }
            }, null, 8, ["isActive"]),
            _(ge, {
              icon: "Columns",
              tooltip: "两栏布局",
              action: s,
              isActive: () => a.editor.isActive("columns", { layout: h(oi).TwoColumn }),
              "tooltip-options": { sideOffset: 15 }
            }, null, 8, ["isActive"]),
            _(ge, {
              icon: "PanelRight",
              tooltip: "右侧边栏",
              action: i,
              isActive: () => a.editor.isActive("columns", { layout: h(oi).SidebarRight }),
              "tooltip-options": { sideOffset: 15 }
            }, null, 8, ["isActive"])
          ])
        ])
      ]),
      _: 1
    }, 8, ["editor", "tippy-options"]));
  }
}), mv = /* @__PURE__ */ I({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(LW), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gv = /* @__PURE__ */ I({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(DW), j(n.value, {
      class: h(ve)(
        "inline-flex items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        e.class
      )
    }), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _J = { class: "truncate" }, $l = /* @__PURE__ */ I({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(BW), j(h(o), {
      class: h(ve)(
        "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        e.class
      )
    }), {
      default: C(() => [
        N("span", _J, [
          D(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), AJ = { class: "border border-neutral-200 dark:border-neutral-800 px-3 py-2 transition-all select-none pointer-events-auto shadow-sm rounded-sm w-auto bg-background" }, TJ = { class: "flex items-center flex-nowrap whitespace-nowrap h-[26px] justify-start relative gap-0.5" }, OJ = { class: "flex items-center gap-2" }, MJ = { class: "mt-3" }, IJ = /* @__PURE__ */ I({
  __name: "ImageBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = R("100"), r = R(), i = R(), s = R(), a = ["left", "center", "right"], l = {
      left: "AlignLeft",
      center: "AlignCenter",
      right: "AlignRight"
    };
    function c(b) {
      b == null || b.preventDefault(), e.editor.getAttributes("image").src && e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
        width: r.value ? `${r.value}px` : null
      }).run();
    }
    function u(b) {
      const S = Math.max(0, Math.min(100, parseInt(o.value)));
      e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({ width: `${S}%` }).run();
    }
    const d = ({ editor: b }) => df(b.view.state, "image"), f = L(() => {
      const b = U3(e.editor, "node-image");
      return (b == null ? void 0 : b.getBoundingClientRect()) || new DOMRect(-1e3, -1e3, 0, 0);
    });
    function p(b) {
      e.editor.chain().focus().setTextAlign(b).run();
    }
    le(o, () => {
      o.value && u();
    }), le(
      () => e.editor.getAttributes("image"),
      (b) => {
        b && (r.value = Math.round(parseFloat(b.originWidth)), i.value = Math.round(parseFloat(b.originHeight)), s.value = b.originWidth / b.originHeight);
      }
    );
    function m() {
      i.value && s.value ? r.value = Math.max(30, Math.round(i.value * s.value)) : r.value = null;
    }
    function g() {
      r.value && s.value ? i.value = Math.max(20, Math.round(r.value / s.value)) : i.value = null;
    }
    function v(b) {
      p(b);
    }
    function y() {
      const b = e.editor.getAttributes("image"), { flipX: S } = b;
      e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
        flipX: !S
      }).run();
    }
    function w() {
      const b = e.editor.getAttributes("image"), { flipY: S } = b;
      e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
        flipY: !S
      }).run();
    }
    function x() {
      const { state: b, dispatch: S } = e.editor.view;
      zl(b, S);
    }
    return (b, S) => {
      const k = ge, A = Ho, $ = jr, O = Ua, M = Mr, P = $l, F = gv, J = mv, Q = Ur, G = Vr;
      return E(), T(h(zs), {
        editor: b.editor,
        pluginKey: "image-menus-123",
        shouldShow: d,
        updateDelay: 0,
        "tippy-options": {
          offset: [0, 8],
          zIndex: 10,
          popperOptions: {
            modifiers: [{ name: "flip", enabled: !1 }]
          },
          appendTo: "parent",
          getReferenceClientRect: h(f).value,
          plugins: [h(s1)],
          sticky: "popper"
        }
      }, {
        default: C(() => [
          N("div", AJ, [
            N("div", TJ, [
              _(k, {
                tooltip: h(n)("editor.image.menu.flipX"),
                icon: "FlipVertical",
                action: y
              }, null, 8, ["tooltip"]),
              _(k, {
                tooltip: h(n)("editor.image.menu.flipY"),
                icon: "FlipHorizontal",
                action: w
              }, null, 8, ["tooltip"]),
              _(A, {
                orientation: "vertical",
                class: "mx-1 me-2 h-[16px]"
              }),
              _(G, null, {
                default: C(() => [
                  _($, null, {
                    default: C(() => [
                      _(k, {
                        title: h(n)("editor.image.menu.size"),
                        icon: "ImageSize"
                      }, null, 8, ["title"])
                    ]),
                    _: 1
                  }),
                  _(Q, { class: "w-84" }, {
                    default: C(() => [
                      N("div", OJ, [
                        _(O, {
                          for: "maxWidth",
                          class: "whitespace-nowrap"
                        }, {
                          default: C(() => [
                            ue(Y(h(n)("editor.image.menu.size.width")), 1)
                          ]),
                          _: 1
                        }),
                        _(M, {
                          id: "maxWidth",
                          modelValue: h(r),
                          "onUpdate:modelValue": S[0] || (S[0] = (V) => No(r) ? r.value = V : null),
                          type: "number",
                          onInput: g,
                          onKeyup: Sr(c, ["enter"]),
                          class: "w-20 h-8 [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                        }, null, 8, ["modelValue"]),
                        _(O, {
                          for: "maxWidth",
                          class: "whitespace-nowrap"
                        }, {
                          default: C(() => [
                            ue(Y(h(n)("editor.image.menu.size.height")), 1)
                          ]),
                          _: 1
                        }),
                        _(M, {
                          id: "maxWidth",
                          modelValue: h(i),
                          "onUpdate:modelValue": S[1] || (S[1] = (V) => No(i) ? i.value = V : null),
                          type: "number",
                          onInput: m,
                          onKeyup: Sr(c, ["enter"]),
                          class: "w-20 h-8 [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                        }, null, 8, ["modelValue"])
                      ]),
                      N("div", MJ, [
                        _(J, {
                          "model-value": h(o),
                          "onUpdate:modelValue": [
                            S[2] || (S[2] = (V) => No(o) ? o.value = V : null),
                            S[3] || (S[3] = (V) => {
                              o.value = V;
                            })
                          ]
                        }, {
                          default: C(() => [
                            _(F, null, {
                              default: C(() => [
                                (E(), W(me, null, Oe(["25", "50", "75", "100"], (V) => _(P, {
                                  key: V,
                                  value: V
                                }, {
                                  default: C(() => [
                                    ue(Y(V) + "% ", 1)
                                  ]),
                                  _: 2
                                }, 1032, ["value"])), 64))
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["model-value"])
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              _(A, {
                orientation: "vertical",
                class: "mx-1 me-2 h-[16px]"
              }),
              (E(), W(me, null, Oe(a, (V, B) => _(k, {
                key: B,
                tooltip: h(n)(`editor.textalign.${V}.tooltip`),
                icon: l[V],
                action: () => v(V),
                disabled: !b.editor.can().setTextAlign(V),
                "is-active": () => b.editor.isActive({ textAlign: V }) || !1
              }, null, 8, ["tooltip", "icon", "action", "disabled", "is-active"])), 64)),
              _(A, {
                orientation: "vertical",
                class: "mx-1 me-2 h-[16px]"
              }),
              _(k, {
                tooltip: h(n)("editor.remove"),
                icon: "Trash2",
                action: x,
                disabled: !b.editor.isEditable
              }, null, 8, ["tooltip", "disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["editor", "tippy-options"]);
    };
  }
}), ci = /* @__PURE__ */ I({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), W("div", j(h(o), {
      class: h(ve)(
        "relative flex select-none items-center p-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 hover:bg-accent rounded-sm gap-2",
        r.inset && "pl-8",
        e.class
      )
    }), [
      D(r.$slots, "default")
    ], 16));
  }
}), RJ = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, $J = { key: 0 }, na = /* @__PURE__ */ I({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: { type: Boolean },
    class: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    return (r, i) => (E(), W("div", {
      class: He(
        h(ve)(
          "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 hover:bg-accent",
          n.class
        )
      ),
      onClick: i[0] || (i[0] = (s) => o("select"))
    }, [
      N("span", RJ, [
        r.modelValue ? (E(), W("span", $J, [
          _(h(rc), { class: "h-4 w-4" })
        ])) : oe("", !0)
      ]),
      D(r.$slots, "default")
    ], 2));
  }
}), vv = /* @__PURE__ */ I({
  __name: "MenuSeparator",
  props: {
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), W("div", j(n.value, {
      class: h(ve)("-mx-1 my-1 h-px bg-muted", e.class)
    }), null, 16));
  }
}), j3 = /* @__PURE__ */ I({
  __name: "MenuShortcut",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), W("span", {
      class: He(h(ve)("ml-auto text-xs tracking-widest opacity-60", e.class))
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), PJ = { class: "bg-popover mt-3 text-foreground overflow-auto flex-wrap border rounded-md p-3 max-w-60" }, LJ = { class: "flex flex-col gap-1" }, DJ = /* @__PURE__ */ I({
  __name: "AiCompletion",
  props: {
    editor: {
      type: PC,
      required: !0
    },
    completion: {
      type: String,
      required: !0
    }
  },
  emits: ["generate", "close"],
  setup(t, { emit: e }) {
    const n = t, { t: o } = Ge(), r = e;
    function i() {
      const c = n.editor.view.state.selection;
      n.editor.chain().focus().deleteRange({
        from: c.from,
        to: c.to
      }).insertContent(n.completion, {
        parseOptions: {
          preserveWhitespace: !1
        },
        updateSelection: !0
      }).run();
    }
    function s() {
      const { to: c } = n.editor.view.state.selection;
      c && n.editor.chain().focus().insertContentAt(c + 1, n.completion).run();
    }
    function a() {
      r("generate");
    }
    function l() {
      r("close");
    }
    return (c, u) => (E(), W("div", PJ, [
      N("div", LJ, [
        _(h(ci), { onClick: i }, {
          default: C(() => [
            _(h(ye), { name: "Replace" }),
            ue(" " + Y(h(o)("editor.AI.replace")), 1)
          ]),
          _: 1
        }),
        _(h(ci), { onClick: s }, {
          default: C(() => [
            _(h(ye), { name: "TextQuote" }),
            ue(" " + Y(h(o)("editor.AI.insert")), 1)
          ]),
          _: 1
        }),
        _(h(Ho)),
        _(h(ci), { onClick: a }, {
          default: C(() => [
            _(h(ye), { name: "Redo2" }),
            ue(" " + Y(h(o)("editor.AI.regenerate")), 1)
          ]),
          _: 1
        }),
        _(h(ci), { onClick: l }, {
          default: C(() => [
            _(h(ye), { name: "Trash2" }),
            ue(" " + Y(h(o)("editor.AI.close")), 1)
          ]),
          _: 1
        })
      ])
    ]));
  }
}), NJ = 1, BJ = 1e6, Do = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST"
};
let sh = 0;
function FJ() {
  return sh = (sh + 1) % Number.MAX_VALUE, sh.toString();
}
const ah = /* @__PURE__ */ new Map();
function Tw(t) {
  if (ah.has(t))
    return;
  const e = setTimeout(() => {
    ah.delete(t), Ka({
      type: Do.REMOVE_TOAST,
      toastId: t
    });
  }, BJ);
  ah.set(t, e);
}
const $n = R({
  toasts: []
});
function Ka(t) {
  switch (t.type) {
    case Do.ADD_TOAST:
      $n.value.toasts = [t.toast, ...$n.value.toasts].slice(0, NJ);
      break;
    case Do.UPDATE_TOAST:
      $n.value.toasts = $n.value.toasts.map(
        (e) => e.id === t.toast.id ? { ...e, ...t.toast } : e
      );
      break;
    case Do.DISMISS_TOAST: {
      const { toastId: e } = t;
      e ? Tw(e) : $n.value.toasts.forEach((n) => {
        Tw(n.id);
      }), $n.value.toasts = $n.value.toasts.map(
        (n) => n.id === e || e === void 0 ? {
          ...n,
          open: !1
        } : n
      );
      break;
    }
    case Do.REMOVE_TOAST:
      t.toastId === void 0 ? $n.value.toasts = [] : $n.value.toasts = $n.value.toasts.filter((e) => e.id !== t.toastId);
      break;
  }
}
function oa() {
  return {
    toasts: L(() => $n.value.toasts),
    toast: zJ,
    dismiss: (t) => Ka({ type: Do.DISMISS_TOAST, toastId: t })
  };
}
function zJ(t) {
  const e = FJ(), n = (r) => Ka({
    type: Do.UPDATE_TOAST,
    toast: { ...r, id: e }
  }), o = () => Ka({ type: Do.DISMISS_TOAST, toastId: e });
  return Ka({
    type: Do.ADD_TOAST,
    toast: {
      ...t,
      id: e,
      open: !0,
      onOpenChange: (r) => {
        r || o();
      }
    }
  }), {
    id: e,
    dismiss: o,
    update: n
  };
}
const HJ = ["onMouseenter", "onClick"], VJ = {
  key: 1,
  class: "absolute left-full top-0 bg-background shadow-md rounded-sm border border-sm"
}, UJ = { class: "p-1 flex flex-col gap-1 min-w-32" }, jJ = ["onMouseenter", "onClick"], WJ = /* @__PURE__ */ I({
  __name: "menu",
  props: {
    items: {}
  },
  emits: ["itemClick"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, i = R(null), s = hn([]), a = R(0), l = R(-1), c = (v) => v.map((y, w) => {
      var x;
      return {
        ...y,
        isSelected: w === 0,
        // 默认选中第一项
        children: (x = y.children) == null ? void 0 : x.map((b) => ({
          ...b,
          isSelected: !1
        }))
      };
    });
    be(() => {
      s.splice(0, s.length, ...c(o.items)), ze(() => {
        var v;
        (v = i.value) == null || v.focus();
      });
    }), le(
      () => o.items,
      (v) => {
        s.splice(0, s.length, ...c(v));
      },
      { deep: !0 }
    ), e({ handleKeyDown: (v) => {
      var w, x;
      const y = l.value !== -1;
      switch (v.key) {
        case "ArrowDown":
          if (v.preventDefault(), y && s[a.value].children) {
            const S = s[a.value].children;
            l.value = (l.value + 1) % S.length, f();
          } else
            a.value = (a.value + 1) % s.length, l.value = -1, d();
          break;
        case "ArrowUp":
          if (v.preventDefault(), y && s[a.value].children) {
            const S = s[a.value].children;
            l.value = (l.value - 1 + S.length) % S.length, f();
          } else
            a.value = (a.value - 1 + s.length) % s.length, l.value = -1, d();
          break;
        case "ArrowRight":
          v.preventDefault(), !y && ((w = s[a.value].children) != null && w.length) && (l.value = 0, f());
          break;
        case "ArrowLeft":
          v.preventDefault(), y && (l.value = -1, d());
          break;
        case "Enter":
          v.preventDefault();
          const b = y ? (x = s[a.value].children) == null ? void 0 : x[l.value] : s[a.value];
          b && !b.children && g(b);
          break;
      }
    } });
    const d = () => {
      s.forEach((v, y) => {
        v.isSelected = y === a.value, v.children && v.children.forEach((w) => {
          w.isSelected = !1;
        });
      });
    }, f = () => {
      const v = s[a.value];
      v.children && v.children.forEach((y, w) => {
        y.isSelected = w === l.value;
      });
    }, p = (v) => {
      a.value = v, l.value = -1, d();
    }, m = (v, y) => {
      a.value = v, l.value = y, f();
    }, g = (v) => {
      v.children || r("itemClick", v);
    };
    return (v, y) => (E(), W("div", {
      class: "p-1 bg-background rounded-sm outline-none shadow-md border flex flex-col gap-1",
      tabindex: "0",
      ref_key: "menuRef",
      ref: i
    }, [
      (E(!0), W(me, null, Oe(s, (w, x) => (E(), W("div", {
        key: w.label,
        class: He([
          "relative flex items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors cursor-pointer",
          w.isSelected ? "bg-accent text-accent-foreground" : "",
          "hover:bg-accent hover:text-accent-foreground"
        ]),
        onMouseenter: (b) => p(x),
        onClick: (b) => g(w)
      }, [
        N("span", null, Y(w.label), 1),
        w.children && w.isSelected ? (E(), T(h(ye), {
          key: 0,
          name: "ChevronRight",
          class: "ml-auto h-4 w-4"
        })) : oe("", !0),
        w.children && w.isSelected ? (E(), W("div", VJ, [
          N("div", UJ, [
            (E(!0), W(me, null, Oe(w.children, (b, S) => (E(), W("div", {
              key: b.label,
              class: He([
                "flex items-center rounded-sm px-2 py-1.5 text-sm whitespace-nowrap outline-none transition-colors cursor-pointer",
                b.isSelected ? "bg-accent text-accent-foreground" : "",
                "hover:bg-accent hover:text-accent-foreground"
              ]),
              onMouseenter: (k) => m(x, S),
              onClick: (k) => g(b)
            }, [
              N("span", null, Y(b.label), 1)
            ], 42, jJ))), 128))
          ])
        ])) : oe("", !0)
      ], 42, HJ))), 128))
    ], 512));
  }
});
function KJ(t) {
  const e = R(""), n = R("init"), o = R([]), { toast: r } = oa(), i = R(null);
  async function s(c, u) {
    var f, p, m;
    n.value = "generating", e.value = "";
    const d = (f = t.extensionManager.extensions.find((g) => g.name === "AI")) == null ? void 0 : f.options;
    try {
      o.value.length === 0 ? o.value.push({
        role: "user",
        content: `Question: ${u} Context:${c}`
      }) : o.value.push({
        role: "user",
        content: u
      }), i.value = new AbortController();
      const g = await d.completions(o.value, i.value.signal);
      if (!g)
        throw new Error("Failed to create stream");
      let v = "";
      for await (const y of g) {
        const w = ((m = (p = y.choices[0]) == null ? void 0 : p.delta) == null ? void 0 : m.content) || "";
        e.value += w, v += w;
      }
      return o.value.push({
        role: "assistant",
        content: v
      }), n.value = "completed", v;
    } catch (g) {
      throw g.name === "AbortError" ? n.value = "init" : r({
        title: (g == null ? void 0 : g.message) || "Failed to generate AI completion",
        variant: "destructive"
      }), g;
    }
  }
  function a() {
    e.value = "", n.value = "init", o.value = [], i.value = null;
  }
  return {
    result: e,
    status: n,
    conversationHistory: o,
    handleCompletion: s,
    resetConversation: a,
    stopGeneration: () => {
      i.value && (i.value.abort(), i.value = null);
    }
  };
}
const GJ = [
  {
    label: "editor.AI.shortcuts.generate.title",
    children: [
      {
        label: "editor.AI.shortcuts.generate.improve",
        prompt: "Rewrite this content with no spelling mistakes, proper grammar, and with more descriptive language, using best writing practices without losing the original meaning."
      },
      {
        label: "editor.AI.shortcuts.generate.shorter",
        prompt: "Remove any repetitive, redundant, or non-essential writing in this content without changing the meaning or losing any key information."
      },
      {
        label: "editor.AI.shortcuts.generate.longer",
        prompt: "Expand upon this content with descriptive language and more detailed explanations, to make the writing easier to understand and increase the length of the content."
      },
      {
        label: "editor.AI.shortcuts.generate.summarize",
        prompt: "Provide the key points and concepts in this content in a succinct summary."
      },
      {
        label: "editor.AI.shortcuts.generate.continue",
        prompt: "Expand and continue this content, maintaining the original tone and style. Ensure that the continuation flows naturally from the existing writing while adding new ideas, further details, or continuing the narrative or argument in a coherent manner."
      }
    ]
  },
  {
    label: "editor.AI.shortcuts.tone.title",
    children: [
      {
        label: "editor.AI.shortcuts.tone.professional",
        prompt: "Rewrite this content using polished, formal, and respectful language to convey professional expertise and competence."
      },
      {
        label: "editor.AI.shortcuts.tone.casual",
        prompt: "Rewrite this content with casual, informal language to convey a casual conversation with a real person."
      },
      {
        label: "editor.AI.shortcuts.tone.direct",
        prompt: "Rewrite this content with direct language using only the essential information."
      },
      {
        label: "editor.AI.shortcuts.tone.confident",
        prompt: "Rewrite this content using compelling, optimistic language to convey confidence in the writing."
      },
      {
        label: "editor.AI.shortcuts.tone.friendly",
        prompt: "Rewrite this content using friendly, comforting language, to convey understanding and empathy."
      }
    ]
  },
  {
    label: "editor.AI.shortcuts.style.title",
    children: [
      {
        label: "editor.AI.shortcuts.style.business",
        prompt: "Rewrite this content as a business professional with formal language."
      },
      {
        label: "editor.AI.shortcuts.style.legal",
        prompt: "Rewrite this content as a legal professional using valid legal terminology."
      },
      {
        label: "editor.AI.shortcuts.style.journalism",
        prompt: "Rewrite this content as a journalist using engaging language to convey the importance of the information."
      },
      {
        label: "editor.AI.shortcuts.style.medical",
        prompt: "Rewrite this content as a medical professional using valid medical terminology."
      },
      {
        label: "editor.AI.shortcuts.style.poetic",
        prompt: "Rewrite this content as a poem using poetic techniques without losing the original meaning."
      }
    ]
  },
  {
    label: "editor.AI.shortcuts.translate.title",
    children: [
      {
        label: "editor.AI.shortcuts.translate.english",
        prompt: "Translate this content to English language."
      },
      {
        label: "editor.AI.shortcuts.translate.chinese",
        prompt: "Translate this content to Simplified Chinese language."
      },
      {
        label: "editor.AI.shortcuts.translate.spanish",
        prompt: "Translate this content to Spanish language."
      },
      {
        label: "editor.AI.shortcuts.translate.german",
        prompt: "Translate this content to German language."
      },
      {
        label: "editor.AI.shortcuts.translate.french",
        prompt: "Translate this content to French language."
      },
      {
        label: "editor.AI.shortcuts.translate.russian",
        prompt: "Translate this content to Russian language."
      },
      {
        label: "editor.AI.shortcuts.translate.portuguese",
        prompt: "Translate this content to Simplified Portuguese language."
      },
      {
        label: "editor.AI.shortcuts.translate.korean",
        prompt: "Translate this content to Simplified Korean language."
      },
      {
        label: "editor.AI.shortcuts.translate.japanese",
        prompt: "Translate this content to Simplified Japanese language."
      },
      {
        label: "editor.AI.shortcuts.translate.hindi",
        prompt: "Translate this content to Simplified Hindi language."
      },
      {
        label: "editor.AI.shortcuts.translate.arabic",
        prompt: "Translate this content to Simplified Arabic language."
      }
    ]
  }
], qJ = { class: "border rounded-sm shadow-sm bg-background" }, YJ = ["innerHTML"], JJ = {
  key: 0,
  class: "text_loading_animation border w-full rounded-md pl-10 pr-20 h-12 py-1 flex items-center text-sm text-foreground"
}, XJ = { class: "absolute start-0 inset-y-0 flex items-center justify-center px-2" }, ZJ = { class: "mt-3 max-w-56" }, QJ = /* @__PURE__ */ I({
  __name: "AIMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = vn(), o = R(""), r = R(null), i = R(null), { focused: s } = b1(i), a = R(null), { t: l } = Ge(), c = R(!1), u = R(null), d = R(), { result: f, status: p, handleCompletion: m, resetConversation: g, stopGeneration: v } = KJ(e.editor), { toast: y } = oa(), w = (G) => {
      const V = G.state.selection.content(), q = Pr.fromSchema(G.schema).serializeFragment(V.content), z = document.createElement("div");
      return z.appendChild(q), z.innerHTML;
    }, x = async () => {
      await ze(), a.value && (a.value.scrollTop = a.value.scrollHeight);
    };
    le(
      () => f.value,
      () => {
        x();
      }
    );
    async function b() {
      if (!e.editor) {
        y({
          title: l.value("editor.AI.error"),
          description: l.value("editor.AI.editorNotFound"),
          variant: "destructive"
        });
        return;
      }
      try {
        p.value = "generating";
        const G = w(e.editor);
        if (!G.trim()) {
          y({
            title: l.value("editor.AI.error"),
            description: l.value("editor.AI.noSelection"),
            variant: "destructive"
          });
          return;
        }
        await m(G, o.value), r.value = {
          context: G,
          prompt: o.value
        }, o.value = "", await ze(), s.value = !0;
      } catch (G) {
        y({
          title: l.value("editor.AI.error"),
          description: G instanceof Error ? G.message : l.value("editor.AI.unknownError"),
          variant: "destructive"
        }), O();
      }
    }
    const { bind: S, unbind: k } = x1("esc", () => {
      v(), O();
    }), A = hn({
      maxWidth: 600,
      zIndex: 99,
      appendTo: "parent",
      placement: "bottom-start",
      onShow(G) {
        u.value = G, S(), setTimeout(() => {
          s.value = !0;
        }, 30);
      },
      onHide() {
        k(), O();
      },
      onDestroy() {
        u.value = null, k();
      }
    }), $ = L(() => n == null ? void 0 : n.state.AIMenu);
    function O() {
      o.value = "", r.value = null, g(), n.state.AIMenu = !1;
    }
    function M() {
      var G, V;
      if (!((G = r.value) != null && G.context) || !((V = r.value) != null && V.prompt)) {
        y({
          title: l.value("editor.AI.error"),
          description: l.value("editor.AI.noCachedPrompt"),
          variant: "destructive"
        });
        return;
      }
      try {
        p.value = "generating", g(), m(r.value.context, r.value.prompt).then(() => {
          x();
        }).catch((B) => {
          y({
            title: l.value("editor.AI.error"),
            description: B instanceof Error ? B.message : l.value("editor.AI.regenerateError"),
            variant: "destructive"
          }), O();
        });
      } catch (B) {
        y({
          title: l.value("editor.AI.error"),
          description: B instanceof Error ? B.message : l.value("editor.AI.unknownError"),
          variant: "destructive"
        }), O();
      }
    }
    function P() {
      if (p.value === "init" && o.value === "") {
        O();
        return;
      }
      c.value = !0, setTimeout(() => {
        c.value = !1;
      }, 820);
    }
    function F(G) {
      if (!e.editor) {
        y({
          title: l.value("editor.AI.error"),
          description: l.value("editor.AI.editorNotFound"),
          variant: "destructive"
        });
        return;
      }
      try {
        const V = w(e.editor), B = G;
        r.value = {
          context: V,
          prompt: B.prompt
        }, p.value = "generating", m(V, B.prompt).then(() => {
          x(), s.value = !0;
        }).catch((q) => {
          y({
            title: l.value("editor.AI.error"),
            description: q instanceof Error ? q.message : l.value("editor.AI.shortcutError"),
            variant: "destructive"
          }), O();
        });
      } catch (V) {
        y({
          title: l.value("editor.AI.error"),
          description: V instanceof Error ? V.message : l.value("editor.AI.unknownError"),
          variant: "destructive"
        }), O();
      }
    }
    const J = L(() => {
      var B, q, z;
      const G = (z = (q = (B = e.editor) == null ? void 0 : B.extensionManager.extensions.find((H) => H.name === "AI")) == null ? void 0 : q.options) == null ? void 0 : z.shortcuts;
      return ((G == null ? void 0 : G.length) > 0 ? G : GJ).map((H) => {
        var Z;
        return {
          ...H,
          label: l.value(H.label),
          children: (Z = H.children) == null ? void 0 : Z.map((ne) => ({
            ...ne,
            label: l.value(ne.label)
          }))
        };
      });
    });
    function Q(G) {
      var V;
      p.value === "init" && J.value.length && !o.value && ((V = d.value) == null || V.handleKeyDown(G));
    }
    return (G, V) => Vn((E(), W("div", {
      class: "absolute left-0 right-0 top-0 bottom-0",
      style: pt({
        zIndex: h(p) === "init" && o.value === "" ? -1 : 98
      }),
      onClick: P
    }, [
      Vn(_(h(zs), {
        pluginKey: "AIMenu",
        "update-delay": 0,
        editor: G.editor,
        "tippy-options": A
      }, {
        default: C(() => [
          N("div", {
            onKeydown: Q,
            class: He(["relative w-[450px] z-[99]", { "shake-animation": c.value }])
          }, [
            Vn(N("div", qJ, [
              N("div", {
                ref_key: "resultContainer",
                ref: a,
                class: "p-4 line-height-none block overflow-y-auto",
                style: { "max-height": "210px" }
              }, [
                N("div", {
                  class: "text-sm text-foreground EchoContentView",
                  style: {
                    padding: 0,
                    minHeight: "auto"
                  },
                  innerHTML: h(f)
                }, null, 8, YJ)
              ], 512)
            ], 512), [
              [no, (h(p) === "generating" || h(p) === "completed") && h(f)]
            ]),
            N("form", {
              onSubmit: b,
              class: "relative w-full items-center flex bg-background mt-3 rounded-md shadow-sm"
            }, [
              h(p) === "generating" ? (E(), W("div", JJ, Y(h(l)("editor.AI.generating")), 1)) : (E(), T(h(Mr), {
                key: 1,
                modelValue: o.value,
                "onUpdate:modelValue": V[0] || (V[0] = (B) => o.value = B),
                ref_key: "inputRef",
                ref: i,
                placeholder: h(l)("editor.AI.placeholder"),
                class: "pl-10 pr-20 h-12 outline-none ring-0 focus-visible:ring-0"
              }, null, 8, ["modelValue", "placeholder"])),
              N("span", XJ, [
                _(h(ye), {
                  name: "Sparkles",
                  class: "w-5 h-5"
                })
              ]),
              h(p) === "generating" ? (E(), T(h(Rt), {
                key: 2,
                variant: "secondary",
                class: "absolute end-0 inset-y-0 flex items-center justify-center px-2 h-[32px] m-2",
                onClick: O
              }, {
                default: C(() => [
                  ue(Y(h(l)("editor.AI.stop")), 1)
                ]),
                _: 1
              })) : (E(), T(h(Rt), {
                key: 3,
                disabled: !o.value,
                onClick: b,
                class: "absolute end-0 inset-y-0 flex items-center justify-center px-2 w-[32px] h-[32px] m-2 rounded-full"
              }, {
                default: C(() => [
                  _(h(ye), {
                    name: "ArrowUp",
                    class: "w-5 h-5 font-bold"
                  })
                ]),
                _: 1
              }, 8, ["disabled"]))
            ], 32),
            Vn(N("div", ZJ, [
              _(WJ, {
                ref_key: "menuRef",
                ref: d,
                items: J.value,
                onItemClick: F
              }, null, 8, ["items"])
            ], 512), [
              [no, h(p) === "init" && J.value.length && !o.value]
            ]),
            h(p) === "completed" && o.value === "" ? (E(), T(DJ, {
              key: 0,
              onClose: O,
              onGenerate: M,
              editor: G.editor,
              completion: h(f)
            }, null, 8, ["editor", "completion"])) : oe("", !0)
          ], 34)
        ]),
        _: 1
      }, 8, ["editor", "tippy-options"]), [
        [no, $.value]
      ])
    ], 4)), [
      [no, $.value]
    ]);
  }
}), W3 = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [o, r] of e)
    n[o] = r;
  return n;
}, eX = /* @__PURE__ */ W3(QJ, [["__scopeId", "data-v-fb08a448"]]), tX = /* @__PURE__ */ I({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(fj), j(h(i), {
      class: h(ve)(
        "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
        n.class
      )
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nX = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, oX = /* @__PURE__ */ I({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(wj), j(h(i), {
      class: h(ve)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: C(() => [
        N("span", nX, [
          _(h(xj), null, {
            default: C(() => [
              _(h(rc), { class: "w-4 h-4" })
            ]),
            _: 1
          })
        ]),
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rX = /* @__PURE__ */ I({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    align: { default: "start" },
    alignOffset: { default: -4 },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(gj), null, {
      default: C(() => [
        _(h(vj), j(h(o), {
          class: h(ve)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            e.class
          )
        }), {
          default: C(() => [
            D(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), iX = /* @__PURE__ */ I({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(yj), j(h(i), {
      class: h(ve)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        s.inset && "pl-8",
        n.class
      )
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sX = /* @__PURE__ */ I({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(hj), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), aX = /* @__PURE__ */ I({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(bj), j({
      class: h(ve)("-mx-1 my-1 h-px bg-muted", e.class)
    }, h(o)), null, 16, ["class"]));
  }
}), Ow = /* @__PURE__ */ I({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), W("span", {
      class: He(h(ve)("ml-auto text-xs tracking-widest text-muted-foreground", e.class))
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), lX = /* @__PURE__ */ I({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(mj), j(h(o), {
      class: h(ve)(
        "flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.class
      )
    }), {
      default: C(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
function Wm(t) {
  const { from: e, to: n, empty: o } = t.state.selection;
  return o ? "" : t.state.doc.textBetween(e, n, "");
}
const Kc = "echo-editor-draft", cX = /* @__PURE__ */ I({
  __name: "Menubars",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const { t: e } = Ge(), n = t, o = vn(), r = L(() => n.editor.extensionManager.extensions.map((v) => v.name)), i = (v) => v ? v.every((y) => r.value.includes(y)) : !0, s = L(() => f.value.map((v) => {
      const y = v.children.filter((x) => i(x.requiredExtensions)), w = y.reduce((x, b, S) => {
        var k;
        return S === 0 && b.separator || S === y.length - 1 && b.separator || b.separator && ((k = x[x.length - 1]) != null && k.separator) || b.separator && !y.slice(S + 1).some(($) => !$.separator) || x.push(b), x;
      }, []);
      return {
        ...v,
        children: w
      };
    }).filter((v) => v.children.length > 0)), a = () => {
      const v = n.editor.getHTML();
      v && !n.editor.isEmpty && localStorage.setItem(Kc, v);
    }, l = () => {
      var y;
      const v = localStorage.getItem(Kc);
      v && ((y = n.editor) == null || y.chain().setContent(v, !0).focus().run());
    }, c = () => {
      n.editor.chain().clearContent(!0).focus().run();
    }, u = () => !!localStorage.getItem(Kc), d = () => {
      localStorage.removeItem(Kc);
    }, f = R([
      {
        title: "editor.menubar.file",
        children: [
          {
            title: "editor.menubar.menu.newDoc",
            icon: "File",
            disabled: () => !n.editor.isEditable,
            action: () => {
              a(), c();
            }
          },
          {
            title: "editor.menubar.menu.restoreLastDraft",
            icon: "Refresh",
            disabled: () => !u() || !n.editor.isEditable,
            action: () => {
              l(), d();
            }
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.preview",
            icon: "Eye",
            action: () => {
              var v;
              (v = n.editor) == null || v.chain().togglePreview().focus().run();
            },
            requiredExtensions: ["preview"]
          },
          {
            separator: !0
          },
          {
            title: "editor.importWord.tooltip",
            icon: "Word",
            disabled: () => !n.editor.isEditable,
            action: () => {
              n.editor.chain().toggleImportWord().focus().run();
            },
            requiredExtensions: ["importWord"]
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.print",
            icon: "Printer",
            shortcut: ["mod", "P"],
            requiredExtensions: ["printer"],
            action: () => {
              o.state.printer = !0;
            }
          }
        ]
      },
      {
        title: "editor.menubar.edit",
        children: [
          {
            title: "editor.undo.tooltip",
            icon: "Undo2",
            shortcut: ["mod", "Z"],
            disabled: () => !n.editor.can().undo() || !n.editor.isEditable,
            action: () => {
              n.editor.chain().undo().focus().run();
            },
            requiredExtensions: ["history"]
          },
          {
            title: "editor.redo.tooltip",
            icon: "Redo2",
            shortcut: ["shift", "mod", "Z"],
            disabled: () => !n.editor.can().redo() || !n.editor.isEditable,
            action: () => {
              n.editor.chain().redo().focus().run();
            },
            requiredExtensions: ["history"]
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.cut",
            icon: "Cut",
            shortcut: ["mod", "X"],
            disabled: () => !n.editor.isEditable,
            action: async () => {
              const v = Wm(n.editor);
              v && (await navigator.clipboard.writeText(v), n.editor.chain().deleteSelection().focus().run());
            }
          },
          {
            title: "editor.menubar.menu.copy",
            icon: "Copy",
            shortcut: ["mod", "C"],
            action: async () => {
              Wm(n.editor) && document.execCommand("copy");
            }
          },
          {
            title: "editor.menubar.menu.paste",
            icon: "Paste",
            shortcut: ["mod", "V"],
            disabled: () => !n.editor.isEditable,
            action: async () => {
              try {
                const v = await navigator.clipboard.read();
                let y = "", w = "";
                for (const x of v)
                  x.types.includes("text/html") && (y = await (await x.getType("text/html")).text()), x.types.includes("text/plain") && (w = await (await x.getType("text/plain")).text());
                y ? n.editor.chain().insertContent(y).focus().run() : w && n.editor.chain().insertContent(w).focus().run();
              } catch (v) {
                console.error("读取剪贴板内容时出错: ", v);
              }
            }
          },
          {
            title: "editor.menubar.menu.pasteAsText",
            icon: "Paste",
            disabled: () => !n.editor.isEditable,
            action: async () => {
              const v = await navigator.clipboard.readText();
              v && n.editor.chain().insertContent(v).focus().run();
            }
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.selectAll",
            disabled: () => !n.editor.isEditable,
            icon: "TextSelect",
            action: () => {
              var v;
              (v = n.editor) == null || v.chain().focus().selectAll().run();
            }
          },
          {
            separator: !0
          },
          {
            title: "editor.findAndReplace.tooltip",
            icon: "DocSearch",
            action: () => {
              o.toggleFindAndReplace();
            },
            requiredExtensions: ["findAndReplace"]
          }
        ]
      },
      {
        title: "editor.menubar.view",
        children: [
          {
            title: "editor.fullscreen.tooltip.fullscreen",
            icon: "Maximize",
            action: () => {
              var v;
              (v = n.editor) == null || v.chain().setFullscreen().focus().run();
            },
            requiredExtensions: ["fullscreen"]
          },
          {
            title: "editor.menubar.menu.preview",
            action: () => {
              n.editor.chain().togglePreview().focus().run();
            },
            icon: "Eye",
            requiredExtensions: ["preview"]
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.spellCheck",
            icon: "SpellCheck",
            checked: () => o.state.spellCheck,
            action: () => {
              o.toggleSpellCheck();
            }
          }
        ]
      },
      {
        title: "editor.menubar.insert",
        children: [
          {
            title: "editor.image.tooltip",
            icon: "ImageUp",
            disabled: () => !n.editor.isEditable || !n.editor.can().setImage({}),
            action: () => {
              var v;
              (v = n.editor.chain()) == null || v.setImageUpload().run();
            },
            requiredExtensions: ["image", "imageUpload"]
          },
          {
            title: "editor.video.tooltip",
            icon: "Video",
            disabled: () => !n.editor.isEditable || !n.editor.can().setVideo({}),
            action: () => {
              var v;
              (v = n.editor.chain()) == null || v.setVideoUpload().run();
            },
            requiredExtensions: ["video", "videoUpload"]
          },
          {
            title: "editor.link.tooltip",
            icon: "Link",
            disabled: () => !n.editor.isEditable || !n.editor.can().setLink({ href: "" }),
            action: () => {
              n.editor.chain().extendMarkRange("link").insertContent({
                type: "text",
                text: "link",
                marks: [
                  {
                    type: "link",
                    attrs: {
                      href: "",
                      target: "_blank"
                    }
                  }
                ]
              }).setLink({ href: "" }).focus().run();
            },
            requiredExtensions: ["link"]
          }
        ]
      },
      {
        title: "editor.menubar.format",
        children: [
          {
            title: "editor.bold.tooltip",
            icon: "Bold",
            shortcut: ["Mod", "B"],
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleBold(),
            action: () => {
              n.editor.chain().toggleBold().focus().run();
            },
            requiredExtensions: ["bold"]
          },
          {
            title: "editor.italic.tooltip",
            icon: "Italic",
            shortcut: ["Mod", "I"],
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleItalic(),
            action: () => {
              n.editor.chain().toggleItalic().focus().run();
            },
            requiredExtensions: ["italic"]
          },
          {
            title: "editor.underline.tooltip",
            icon: "Underline",
            shortcut: ["Mod", "U"],
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleUnderline(),
            action: () => {
              n.editor.chain().toggleUnderline().focus().run();
            },
            requiredExtensions: ["underline"]
          },
          {
            title: "editor.strike.tooltip",
            icon: "Strikethrough",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleStrike(),
            action: () => {
              n.editor.chain().toggleStrike().focus().run();
            },
            requiredExtensions: ["strike"]
          },
          {
            title: "editor.superscript.tooltip",
            icon: "Superscript",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleSuperscript(),
            action: () => {
              n.editor.chain().toggleSuperscript().focus().run();
            },
            requiredExtensions: ["superscript"]
          },
          {
            title: "editor.subscript.tooltip",
            icon: "Subscript",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleSubscript(),
            action: () => {
              n.editor.chain().toggleSubscript().focus().run();
            },
            requiredExtensions: ["subscript"]
          },
          {
            title: "editor.code.tooltip",
            icon: "Code",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleCode(),
            action: () => {
              n.editor.chain().toggleCode().focus().run();
            },
            requiredExtensions: ["code"]
          }
        ]
      }
    ]), p = (v) => {
      v && v();
    }, m = (v) => v === void 0 ? !1 : typeof v == "function" ? v() : v, g = (v) => v === void 0 ? !1 : typeof v == "function" ? v() : v;
    return (v, y) => (E(), T(h(tX), { class: "rounded-b-none shadow-none border-t-transparent border-l-transparent border-r-transparent rounded-t-[0.5rem]" }, {
      default: C(() => [
        (E(!0), W(me, null, Oe(h(s), (w, x) => (E(), T(h(sX), { key: x }, {
          default: C(() => [
            _(h(lX), null, {
              default: C(() => [
                ue(Y(h(e)(w.title)), 1)
              ]),
              _: 2
            }, 1024),
            _(h(rX), null, {
              default: C(() => [
                (E(!0), W(me, null, Oe(w.children, (b, S) => (E(), W(me, { key: S }, [
                  b != null && b.separator ? (E(), T(h(aX), { key: 0 })) : b.checked && i(b.requiredExtensions) ? (E(), T(h(oX), {
                    key: 1,
                    onClick: (k) => p(b.action),
                    "model-value": g(b.checked),
                    disabled: m(b.disabled),
                    class: "flex gap-3"
                  }, {
                    default: C(() => [
                      b.icon ? (E(), T(h(ye), {
                        key: 0,
                        name: b.icon
                      }, null, 8, ["name"])) : oe("", !0),
                      ue(" " + Y(h(e)(b.title)) + " ", 1),
                      b.shortcut ? (E(), T(h(Ow), { key: 1 }, {
                        default: C(() => [
                          ue(Y(h(Ro)(b.shortcut)), 1)
                        ]),
                        _: 2
                      }, 1024)) : oe("", !0)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "model-value", "disabled"])) : i(b.requiredExtensions) ? (E(), T(h(iX), {
                    key: 2,
                    onClick: (k) => p(b.action),
                    disabled: m(b.disabled),
                    class: "flex gap-3"
                  }, {
                    default: C(() => [
                      b.icon ? (E(), T(h(ye), {
                        key: 0,
                        name: b.icon
                      }, null, 8, ["name"])) : oe("", !0),
                      ue(" " + Y(h(e)(b.title)) + " ", 1),
                      b.shortcut ? (E(), T(h(Ow), { key: 1 }, {
                        default: C(() => [
                          ue(Y(h(Ro)(b.shortcut)), 1)
                        ]),
                        _: 2
                      }, 1024)) : oe("", !0)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "disabled"])) : oe("", !0)
                ], 64))), 128))
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1024))), 128))
      ]),
      _: 1
    }));
  }
}), uX = {
  key: 0,
  class: "sticky top-0 h-auto bg-background z-10 overflow-visible rounded-t-[0.5rem]"
}, dX = { class: "flex flex-nowrap overflow-x-auto sm:flex-wrap gap-y-1 gap-x-1 items-center py-0.5" }, fX = { class: "flex items-center" }, pX = /* @__PURE__ */ I({
  __name: "Toolbar",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const { t: e } = Ge(), n = t, o = L(() => {
      const i = [...n.editor.extensionManager.extensions].sort((a, l) => {
        const c = a.options.sort ?? -1, u = l.options.sort ?? -1;
        return c - u;
      });
      let s = [];
      for (const a of i) {
        const { button: l, divider: c = !1, spacer: u = !1, toolbar: d = !0 } = a.options;
        if (!l || !EF(l) || !d) continue;
        const f = l({
          editor: n.editor,
          extension: a,
          t: h(e)
        });
        if (Array.isArray(f)) {
          const p = f.map((m, g) => ({
            button: m,
            divider: g === f.length - 1 ? c : !1,
            spacer: g === 0 ? u : !1
          }));
          s = [...s, ...p];
          continue;
        }
        s.push({ button: f, divider: c, spacer: u });
      }
      return s;
    });
    return (r, i) => o.value.length ? (E(), W("div", uX, [
      N("div", dX, [
        (E(!0), W(me, null, Oe(o.value, (s, a) => {
          var l;
          return E(), W(me, { key: a }, [
            N("div", fX, [
              s.spacer ? (E(), T(h(Ho), {
                key: 0,
                orientation: "vertical",
                class: "h-[16px] mx-[10px]"
              })) : oe("", !0)
            ]),
            (E(), T(An(s.button.component), j({ ref_for: !0 }, s.button.componentProps, {
              editor: r.editor,
              disabled: r.disabled || ((l = s.button.componentProps) == null ? void 0 : l.disabled)
            }), J2({ _: 2 }, [
              Oe(s.button.componentSlots, (c, u, d) => ({
                name: `${u}`,
                fn: C((f) => [
                  (E(), T(An(c), j({ ref_for: !0 }, f == null ? void 0 : f.props), null, 16))
                ])
              }))
            ]), 1040, ["editor", "disabled"])),
            s.divider ? (E(), T(h(Ho), {
              key: 0,
              orientation: "vertical",
              class: "h-auto mx-2"
            })) : oe("", !0)
          ], 64);
        }), 128))
      ])
    ])) : oe("", !0);
  }
}), hX = /* @__PURE__ */ I({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(kV), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mX = /* @__PURE__ */ I({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(WU), null, {
      default: C(() => [
        _(h(oU), { class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" }),
        _(h(XV), j(h(i), {
          class: h(ve)(
            "fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: C(() => [
            D(s.$slots, "default"),
            _(h(rU), { class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground" }, {
              default: C(() => [
                _(h(Nk), { class: "w-4 h-4" }),
                a[0] || (a[0] = N("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), gX = /* @__PURE__ */ I({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), W("div", {
      class: He(
        h(ve)(
          "flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2",
          e.class
        )
      )
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), vX = /* @__PURE__ */ I({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), W("div", {
      class: He(h(ve)("flex flex-col gap-y-1.5 text-center sm:text-left", e.class))
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), yX = /* @__PURE__ */ I({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(iU), j(h(o), {
      class: h(ve)(
        "text-lg font-semibold leading-none tracking-tight",
        e.class
      )
    }), {
      default: C(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bX = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, wX = /* @__PURE__ */ I({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h($W), j(h(i), {
      class: h(ve)("relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]>div]:rotate-90", n.class)
    }), {
      default: C(() => [
        n.withHandle ? (E(), W("div", bX, [
          _(h(xK), { class: "h-2.5 w-2.5" })
        ])) : oe("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), xX = /* @__PURE__ */ I({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(IW), j(h(i), {
      class: h(ve)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CX = /* @__PURE__ */ I({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    el("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(rK), j(h(i), {
      class: h(ve)("flex items-center justify-center gap-1", n.class)
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lh = /* @__PURE__ */ I({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(t) {
    const e = t, n = kg("toggleGroup"), o = L(() => {
      const { class: i, variant: s, size: a, ...l } = e;
      return l;
    }), r = vt(o);
    return (i, s) => {
      var a, l;
      return E(), T(h(iK), j(h(r), {
        class: h(ve)(h(Qk)({
          variant: ((a = h(n)) == null ? void 0 : a.variant) || i.variant,
          size: ((l = h(n)) == null ? void 0 : l.size) || i.size
        }), e.class)
      }), {
        default: C(() => [
          D(i.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
}), SX = /* @__PURE__ */ I({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h($j), j(n.value, {
      class: h(ve)(
        "flex touch-none select-none transition-colors",
        o.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        o.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        e.class
      )
    }), {
      default: C(() => [
        _(h(Pj), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), K3 = /* @__PURE__ */ I({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(Sj), j(n.value, {
      class: h(ve)("relative overflow-hidden", e.class)
    }), {
      default: C(() => [
        _(h(kj), { class: "h-full w-full rounded-[inherit]" }, {
          default: C(() => [
            D(o.$slots, "default")
          ]),
          _: 3
        }),
        _(SX),
        _(h(Dj))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kX = { class: "flex justify-center" }, EX = { class: "hidden items-center gap-1.5 rounded-md border p-[2px] shadow-sm md:flex" }, _X = { class: "relative overflow-y-auto after:absolute after:inset-0 after:right-3 after:z-0 after:rounded-lg h-[--container-height] px-4" }, AX = ["innerHTML"], TX = /* @__PURE__ */ I({
  __name: "Preview",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = vn(), r = R();
    function i(l) {
      o.state.showPreview = l;
    }
    function s() {
      o.state.showPreview = !1;
    }
    const a = L(() => e.editor.getHTML());
    return (l, c) => {
      var u;
      return E(), T(h(hX), {
        open: (u = h(o)) == null ? void 0 : u.state.showPreview,
        "onUpdate:open": i
      }, {
        default: C(() => [
          _(h(mX), { class: "sm:max-w-[425px] md:max-w-[825px] lg:max-w-[1200px] grid-rows-[auto_minmax(0,1fr)_auto] p-0 max-h-[90dvh]" }, {
            default: C(() => [
              _(h(vX), { class: "p-6 pb-0" }, {
                default: C(() => [
                  _(h(yX), null, {
                    default: C(() => [
                      ue(Y(h(n)("editor.preview.tooltip")), 1)
                    ]),
                    _: 1
                  }),
                  N("div", kX, [
                    N("div", EX, [
                      _(h(CX), {
                        type: "single",
                        "default-value": "100",
                        "onUpdate:modelValue": c[0] || (c[0] = (d) => {
                          var f;
                          (f = h(r)) == null || f.resize(parseInt(d));
                        })
                      }, {
                        default: C(() => [
                          _(h(lh), {
                            value: "100",
                            class: "h-[32px] w-[32px] rounded-sm p-0"
                          }, {
                            default: C(() => [
                              _(h(ye), {
                                name: "Monitor",
                                class: "w-5 h-5"
                              })
                            ]),
                            _: 1
                          }),
                          _(h(lh), {
                            value: "60",
                            class: "h-[32px] w-[32px] rounded-sm p-0"
                          }, {
                            default: C(() => [
                              _(h(ye), {
                                name: "Tablet",
                                class: "w-5 h-5"
                              })
                            ]),
                            _: 1
                          }),
                          _(h(lh), {
                            value: "30",
                            class: "h-[32px] w-[32px] rounded-sm p-0"
                          }, {
                            default: C(() => [
                              _(h(ye), {
                                name: "Phone",
                                class: "w-5 h-5"
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ])
                ]),
                _: 1
              }),
              N("div", _X, [
                _(h(xX), {
                  id: "preview-resizable",
                  direction: "horizontal",
                  class: "relative z-10 overflow-auto"
                }, {
                  default: C(() => [
                    _(h(Db), {
                      ref_key: "resizableRef",
                      ref: r,
                      class: "relative rounded-lg border bg-background transition-all",
                      "default-size": 100,
                      "min-size": 30,
                      id: "preview-resize-panel-1"
                    }, {
                      default: C(() => [
                        _(h(K3), { class: "h-full w-full rounded-md border p-3 border-none" }, {
                          default: C(() => [
                            N("div", {
                              innerHTML: h(a),
                              class: "EchoContentView"
                            }, null, 8, AX)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 512),
                    _(h(wX), {
                      id: "block-resizable-handle",
                      class: "relative hidden w-3 bg-transparent p-0 after:absolute after:right-0 after:top-1/2 after:h-8 after:w-[6px] after:-translate-y-1/2 after:translate-x-[-1px] after:rounded-full after:bg-border after:transition-all after:hover:h-10 sm:block"
                    }),
                    _(h(Db), {
                      id: "block-resizable-panel-2",
                      "default-size": 0,
                      "min-size": 0
                    })
                  ]),
                  _: 1
                })
              ]),
              _(h(gX), { class: "p-2 pt-0" }, {
                default: C(() => [
                  _(h(Rt), { onClick: s }, {
                    default: C(() => [
                      ue(Y(h(n)("editor.close")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), OX = ["srcdoc"], MX = /* @__PURE__ */ I({
  __name: "Printer",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = () => {
      const d = Array.from(document.styleSheets);
      let f = "";
      return d.forEach((m) => {
        try {
          Array.from(m.cssRules || []).forEach((v) => {
            v instanceof CSSStyleRule && v.selectorText.includes(".EchoContentView") && (f += v.cssText + `
`);
          });
        } catch (g) {
          console.warn("无法读取样式表:", g);
        }
      }), Array.from(document.querySelectorAll("style")).forEach((m) => {
        const g = m.textContent || "";
        g.includes(".EchoContentView") && (f += g + `
`);
      }), f;
    }, n = t, { state: o } = vn(), r = R(""), i = R(null);
    function s(d) {
      return console.log(e()), `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <title>Echo Editor</title>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>${e()}</style>
    </head>
    <body class="echo-editor">
      <div class="tiptap EchoContentView" translate="no" aria-expanded="false">
          ${d}
      </div>
    </body>
    </html>`;
    }
    function a(d) {
      const f = d.contentWindow;
      if (!f) {
        console.error("无法访问 iframe 的 contentWindow");
        return;
      }
      const p = () => {
        o.printer = !1, f.removeEventListener("afterprint", p);
      };
      f.addEventListener("afterprint", p);
    }
    async function l() {
      var d;
      try {
        n.editor.commands.blur();
        const f = n.editor.getHTML();
        r.value = s(f), await ze();
        const p = i.value;
        if (!p)
          throw new Error("iframe 元素未找到");
        a(p), (d = p.contentWindow) == null || d.print();
      } catch (f) {
        console.error("打印过程中发生错误:", f), o.printer = !1;
      }
    }
    le(
      () => o.printer,
      (d) => {
        d && !n.disabled && l();
      }
    );
    const { bind: c, unbind: u } = x1("ctrl+p,command+p", (d) => {
      d.preventDefault(), n.disabled || (o.printer = !0);
    });
    return be(() => {
      n.editor.on("focus", c), n.editor.on("blur", u);
    }), Nt(() => {
      n.editor.off("focus", c), n.editor.off("blur", u);
    }), (d, f) => h(o).printer ? (E(), W("iframe", {
      key: 0,
      ref_key: "iframeRef",
      ref: i,
      class: "absolute w-0 h-0 border-none overflow-auto",
      srcdoc: h(r)
    }, null, 8, OX)) : oe("", !0);
  }
}), IX = { class: "flex w-full max-w-sm items-center gap-1.5" }, RX = { class: "relative w-full max-w-sm items-center" }, $X = { class: "absolute end-0 inset-y-0 flex items-center justify-center px-2 text-sm" }, PX = { class: "flex gap-1" }, LX = { class: "flex items-center space-x-2 mt-2" }, DX = {
  for: "terms",
  class: "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
}, NX = { class: "flex gap-3 mt-3" }, BX = /* @__PURE__ */ I({
  __name: "FindAndReplace",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    containerRef: { default: void 0 }
  },
  emits: ["update:modelValue", "find", "replace"],
  setup(t, { emit: e }) {
    const n = t, o = R(null), r = R(null), i = vn(), s = R(""), a = R(""), l = R(!1), { t: c } = Ge(), u = L(() => n.containerRef), { focused: d } = b1(r), { top: f, right: p } = iz(u), m = az(u), g = R({ x: 0, y: 0 }), v = L(() => {
      var P, F;
      return ((F = (P = n.editor) == null ? void 0 : P.storage.findAndReplace) == null ? void 0 : F.results.length) || 0;
    });
    le([f, p, m], () => {
      m.value && o.value && (g.value = {
        y: f.value + 24,
        x: p.value - 320 - 24
      });
    });
    const y = (P = !1) => {
      n.editor && (P && n.editor.commands.resetIndex(), n.editor.commands.setSearchTerm(s.value), n.editor.commands.setReplaceTerm(a.value), n.editor.commands.setCaseSensitive(l.value));
    }, w = () => {
      if (!n.editor) return;
      const { results: P, resultIndex: F } = n.editor.storage.findAndReplace, J = P[F];
      if (!J) return;
      n.editor.commands.setTextSelection(J);
      const { node: Q } = n.editor.view.domAtPos(n.editor.state.selection.anchor);
      Q instanceof HTMLElement && Q.scrollIntoView({ behavior: "smooth", block: "center" });
    };
    le(
      () => s.value.trim(),
      (P, F) => {
        P || k(), P !== F && y(!0);
      }
    ), le(
      () => a.value.trim(),
      (P, F) => P === F ? null : y()
    ), le(
      () => l.value,
      (P, F) => P === F ? null : y(!0)
    ), le(
      () => i.state.findAndReplace,
      async (P) => {
        P ? (await ze(), d.value = !0, s.value = Wm(n.editor) || "") : k();
      }
    );
    const x = () => {
      n.editor.commands.replace(), w();
    }, b = () => {
      n.editor.commands.nextSearchResult(), w();
    }, S = (P) => {
      P.preventDefault(), n.editor.commands.previousSearchResult(), w();
    }, k = () => {
      s.value = a.value = "", n.editor.commands.resetIndex();
    }, A = () => n.editor.commands.replaceAll();
    function $(P) {
      l.value = P;
    }
    be(() => setTimeout(y));
    const { bind: O, unbind: M } = x1("ctrl+f,command+f", () => {
      i.state.findAndReplace = !0;
    });
    return n.editor.on("focus", O), n.editor.on("blur", M), (P, F) => {
      var q, z, H, Z, ne, he, we, Ae, Re, qe, Ue, Be;
      const J = ye, Q = Ua, G = Mr, V = Rt, B = Bk;
      return E(), T(qd, { to: "body" }, [
        Vn(N("div", {
          ref_key: "dialogRef",
          ref: o,
          class: "findAndReplaceDialog fixed bg-white shadow-lg rounded-lg p-4 w-[320px] border z-[11]",
          style: pt({ top: `${g.value.y}px`, left: `${g.value.x}px` })
        }, [
          N("button", {
            onClick: F[0] || (F[0] = (rt) => h(i).toggleFindAndReplace()),
            class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
          }, [
            _(J, { name: "Close" })
          ]),
          _(Q, null, {
            default: C(() => [
              ue(Y(h(c)("editor.findAndReplace.find")), 1)
            ]),
            _: 1
          }),
          N("div", IX, [
            N("div", RX, [
              _(G, {
                modelValue: s.value,
                "onUpdate:modelValue": F[1] || (F[1] = (rt) => s.value = rt),
                onKeyup: Sr(b, ["enter"]),
                class: "pr-10",
                ref_key: "inputRef",
                ref: r
              }, null, 8, ["modelValue"]),
              N("span", $X, Y((H = (z = (q = P.editor) == null ? void 0 : q.storage) == null ? void 0 : z.findAndReplace) != null && H.results.length ? ((he = (ne = (Z = P.editor) == null ? void 0 : Z.storage) == null ? void 0 : ne.findAndReplace) == null ? void 0 : he.resultIndex) + 1 : (Re = (Ae = (we = P.editor) == null ? void 0 : we.storage) == null ? void 0 : Ae.findAndReplace) == null ? void 0 : Re.resultIndex) + " / " + Y((Be = (Ue = (qe = P.editor) == null ? void 0 : qe.storage) == null ? void 0 : Ue.findAndReplace) == null ? void 0 : Be.results.length), 1)
            ]),
            N("div", PX, [
              _(V, {
                onClick: S,
                variant: "outline",
                size: "icon",
                class: "px-2.5"
              }, {
                default: C(() => [
                  _(J, {
                    name: "ChevronUp",
                    class: "w-5 h-5"
                  })
                ]),
                _: 1
              }),
              _(V, {
                onClick: b,
                variant: "outline",
                size: "icon",
                class: "px-2.5"
              }, {
                default: C(() => [
                  _(J, {
                    name: "ChevronDown",
                    class: "w-5 h-5"
                  })
                ]),
                _: 1
              })
            ])
          ]),
          _(Q, null, {
            default: C(() => [
              ue(Y(h(c)("editor.findAndReplace.replace")), 1)
            ]),
            _: 1
          }),
          _(G, {
            modelValue: a.value,
            "onUpdate:modelValue": F[2] || (F[2] = (rt) => a.value = rt)
          }, null, 8, ["modelValue"]),
          N("div", LX, [
            _(B, {
              id: "terms",
              checked: l.value,
              "onUpdate:checked": $
            }, null, 8, ["checked"]),
            N("label", DX, Y(h(c)("editor.findAndReplace.caseSensitive")), 1)
          ]),
          N("div", NX, [
            _(V, {
              type: "submit",
              disabled: !v.value
            }, {
              default: C(() => [
                ue(Y(h(c)("editor.findAndReplace.find")), 1)
              ]),
              _: 1
            }, 8, ["disabled"]),
            _(V, {
              variant: "secondary",
              onClick: x,
              disabled: !P.editor.isEditable || !v.value
            }, {
              default: C(() => [
                ue(Y(h(c)("editor.findAndReplace.replace")), 1)
              ]),
              _: 1
            }, 8, ["disabled"]),
            _(V, {
              variant: "secondary",
              onClick: A,
              disabled: !P.editor.isEditable || !v.value
            }, {
              default: C(() => [
                ue(Y(h(c)("editor.findAndReplace.replaceAll")), 1)
              ]),
              _: 1
            }, 8, ["disabled"])
          ])
        ], 4), [
          [no, h(i).state.findAndReplace && h(m)]
        ])
      ]);
    };
  }
}), FX = /* @__PURE__ */ I({
  __name: "Toast",
  props: {
    class: {},
    variant: {},
    onOpenChange: { type: Function },
    defaultOpen: { type: Boolean },
    forceMount: { type: Boolean },
    type: {},
    open: { type: Boolean },
    duration: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(JW), j(h(i), {
      class: h(Yo)(h(jX)({ variant: s.variant }), n.class),
      "onUpdate:open": s.onOpenChange
    }), {
      default: C(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "onUpdate:open"]));
  }
}), zX = /* @__PURE__ */ I({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(ZW), j(n.value, {
      class: h(Yo)("absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e.class)
    }), {
      default: C(() => [
        _(h(Nk), { class: "h-4 w-4" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Mw = /* @__PURE__ */ I({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(nK), j({
      class: h(Yo)("text-sm opacity-90", e.class)
    }, n.value), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), HX = /* @__PURE__ */ I({
  __name: "ToastProvider",
  props: {
    label: {},
    duration: {},
    swipeDirection: {},
    swipeThreshold: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(zW), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), VX = /* @__PURE__ */ I({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(tK), j(n.value, {
      class: h(Yo)("text-sm font-semibold [&+div]:text-xs", e.class)
    }), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), UX = /* @__PURE__ */ I({
  __name: "ToastViewport",
  props: {
    hotkey: {},
    label: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(eK), j(n.value, {
      class: h(Yo)("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e.class)
    }), null, 16, ["class"]));
  }
}), jX = nv(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--reka-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--reka-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), WX = { class: "grid gap-1" }, KX = /* @__PURE__ */ I({
  __name: "Toaster",
  setup(t) {
    const { toasts: e } = oa();
    return (n, o) => (E(), T(h(HX), null, {
      default: C(() => [
        (E(!0), W(me, null, Oe(h(e), (r) => (E(), T(h(FX), j({
          key: r.id,
          ref_for: !0
        }, r), {
          default: C(() => [
            N("div", WX, [
              r.title ? (E(), T(h(VX), { key: 0 }, {
                default: C(() => [
                  ue(Y(r.title), 1)
                ]),
                _: 2
              }, 1024)) : oe("", !0),
              r.description ? (E(), W(me, { key: 1 }, [
                s_(r.description) ? (E(), T(h(Mw), { key: 0 }, {
                  default: C(() => [
                    (E(), T(An(r.description)))
                  ]),
                  _: 2
                }, 1024)) : (E(), T(h(Mw), { key: 1 }, {
                  default: C(() => [
                    ue(Y(r.description), 1)
                  ]),
                  _: 2
                }, 1024))
              ], 64)) : oe("", !0),
              _(h(zX))
            ]),
            (E(), T(An(r.action)))
          ]),
          _: 2
        }, 1040))), 128)),
        _(h(UX))
      ]),
      _: 1
    }));
  }
}), GX = { class: "overflow-hidden relative flex-1" }, qX = {
  key: 2,
  class: "flex justify-between border-t p-3 items-center"
}, YX = { class: "flex flex-col" }, JX = { class: "flex justify-end gap-3 text-sm" }, XX = /* @__PURE__ */ I({
  __name: "EchoEditor",
  props: {
    modelValue: { default: "" },
    output: { default: "html" },
    dark: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    hideToolbar: { type: Boolean, default: !1 },
    hideMenubar: { type: Boolean, default: !1 },
    hideBubble: { type: Boolean, default: !1 },
    removeDefaultWrapper: { type: Boolean, default: !1 },
    maxWidth: { default: void 0 },
    minHeight: { default: void 0 },
    maxHeight: { default: void 0 },
    extensions: { default: () => [] },
    editorClass: { default: void 0 },
    contentClass: { default: void 0 }
  },
  emits: ["enter", "change", "update:modelValue"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, i = a_(), { state: s, isFullscreen: a } = vn(), { t: l } = Ge(), c = oz(), u = R(null), d = L(
      () => [...s.extensions, ...hN(o.extensions, s.extensions, "name")].map(
        (y, w) => y.configure({ sort: w })
      )
    ), f = L(() => ({
      content: o.modelValue,
      editorProps: {
        handleKeyDown: Yu((y, w) => w.key === "Enter" && i.enter && !w.shiftKey ? (r("enter"), !0) : !1, vy),
        attributes: {
          class: "EchoContentView"
        }
      },
      onUpdate: Yu(({ editor: y }) => {
        const w = v(y, o.output);
        r("update:modelValue", w), r("change", { editor: y, output: w });
      }, vy),
      extensions: h(d),
      editable: !o.disabled
    })), p = new iS(h(f)), { isFocused: m } = Sz({ editor: p });
    le(
      () => o.dark,
      (y) => {
        y !== void 0 && (c.value = y);
      }
    );
    const g = L(() => ({
      ...h(a) ? { height: "100%", overflowY: "auto" } : {
        minHeight: fu(o.minHeight),
        maxHeight: fu(o.maxHeight),
        overflowY: "auto",
        scrollBehavior: "smooth",
        scrollbarWidth: "thin"
      },
      maxWidth: fu(o.maxWidth),
      width: o.maxWidth ? "100%" : void 0,
      margin: o.maxWidth ? "8px auto" : void 0
    }));
    function v(y, w) {
      if (o.removeDefaultWrapper && y.isEmpty)
        return w === "json" ? {} : "";
      switch (w) {
        case "html":
          return y.getHTML();
        case "json":
          return y.getJSON();
        case "text":
          return y.getText();
        default:
          return console.warn(`Invalid output type: ${w}`), "";
      }
    }
    return le(
      () => o.modelValue,
      (y) => {
        if (!p || yN(v(p, o.output), y)) return;
        const { from: w, to: x } = p.state.selection;
        p.commands.setContent(y, !1), p.commands.setTextSelection({ from: w, to: x });
      },
      { deep: !0 }
    ), le(
      () => o.disabled,
      (y) => p == null ? void 0 : p.setEditable(!y)
    ), Nt(() => {
      p == null || p.destroy();
    }), e({ editor: p }), (y, w) => h(p) ? (E(), W("div", {
      key: 0,
      class: He(["echo-editor rounded-[0.5rem] bg-background shadow outline outline-1 relative", [
        y.editorClass,
        {
          "outline-primary": h(m),
          "outline-border": !h(m)
        }
      ]])
    }, [
      h(Fe)(h(p), "preview") ? (E(), T(TX, {
        key: 0,
        editor: h(p)
      }, null, 8, ["editor"])) : oe("", !0),
      h(Fe)(h(p), "printer") ? (E(), T(MX, {
        key: 1,
        editor: h(p)
      }, null, 8, ["editor"])) : oe("", !0),
      h(Fe)(h(p), "findAndReplace") ? (E(), T(BX, {
        key: 2,
        "container-ref": u.value,
        editor: h(p)
      }, null, 8, ["container-ref", "editor"])) : oe("", !0),
      N("div", {
        class: He(["relative flex flex-col overflow-hidden", {
          "!fixed bg-background inset-0 z-[10]  w-full h-full m-0 rounded-[0.5rem]": h(a)
        }])
      }, [
        y.hideMenubar ? oe("", !0) : (E(), T(cX, {
          key: 0,
          editor: h(p),
          disabled: y.disabled
        }, null, 8, ["editor", "disabled"])),
        y.hideToolbar ? oe("", !0) : (E(), T(pX, {
          key: 1,
          editor: h(p),
          disabled: y.disabled,
          class: "border-b py-1 px-1 overflow-hidden"
        }, null, 8, ["editor", "disabled"])),
        N("div", GX, [
          _(h(LO), {
            ref_key: "contentRef",
            ref: u,
            editor: h(p),
            class: He(y.contentClass),
            style: pt(g.value),
            spellcheck: h(s).spellCheck
          }, null, 8, ["editor", "class", "style", "spellcheck"]),
          !y.hideBubble && !y.disabled && h(p).isEditable ? (E(), W(me, { key: 0 }, [
            _(xJ, {
              editor: h(p),
              class: "hidden sm:block"
            }, null, 8, ["editor"]),
            h(Fe)(h(p), "link") ? (E(), T(BG, {
              key: 0,
              editor: h(p)
            }, null, 8, ["editor"])) : oe("", !0),
            h(Fe)(h(p), "columns") ? (E(), T(EJ, {
              key: 1,
              editor: h(p)
            }, null, 8, ["editor"])) : oe("", !0),
            h(Fe)(h(p), "table") ? (E(), T(lq, {
              key: 2,
              editor: h(p)
            }, null, 8, ["editor"])) : oe("", !0),
            h(Fe)(h(p), "AI") ? (E(), T(eX, {
              key: 3,
              editor: h(p)
            }, null, 8, ["editor"])) : oe("", !0),
            h(Fe)(h(p), "image") ? (E(), T(IJ, {
              key: 4,
              editor: h(p)
            }, null, 8, ["editor"])) : oe("", !0),
            _(gK, { editor: h(p) }, null, 8, ["editor"])
          ], 64)) : oe("", !0)
        ]),
        h(Fe)(h(p), "characterCount") ? (E(), W("div", qX, [
          N("div", YX, [
            N("div", JX, [
              N("span", null, Y(h(p).storage.characterCount.characters()) + " " + Y(h(l)("editor.characters")), 1)
            ])
          ]),
          D(y.$slots, "footer", { editor: h(p) })
        ])) : oe("", !0)
      ], 2),
      _(KX)
    ], 2)) : oe("", !0);
  }
});
function ZX() {
  Wk({
    prefix: "echo",
    icons: {
      baidu: {
        body: '<svg t="1716185245518" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6045" width="24" height="24"><path d="M824.32 1018.88h-163.84l348.16-348.16v163.84c0 102.4-81.92 184.32-184.32 184.32z m0-1008.64c102.4 0 184.32 81.92 184.32 184.32v97.28l-281.6-281.6h97.28z m-58.88 366.08c0 66.56-25.6 128-66.56 174.08l-7.68 5.12c-79.36 87.04-140.8 192-179.2 307.2-2.56 2.56-5.12 5.12-10.24 5.12s-7.68-2.56-10.24-5.12c-38.4-115.2-99.84-217.6-179.2-307.2l-7.68-7.68-2.56-2.56 2.56 2.56c-40.96-46.08-66.56-107.52-66.56-174.08 0-56.32 17.92-107.52 46.08-148.48C332.8 156.16 409.6 112.64 499.2 112.64s168.96 43.52 215.04 112.64c33.28 43.52 51.2 94.72 51.2 151.04z m-289.28-112.64h-33.28v61.44h-38.4c-38.4 0-71.68 30.72-71.68 71.68v15.36c0 38.4 30.72 71.68 71.68 71.68h66.56v-2.56h2.56v-217.6z m176.64 64h-35.84v125.44h-40.96c-15.36 0-30.72-12.8-30.72-30.72v-97.28H512V435.2c0 25.6 20.48 48.64 48.64 48.64h92.16v-156.16z m-276.48 84.48v-15.36c0-20.48 15.36-35.84 35.84-35.84h30.72v89.6h-30.72c-20.48-2.56-35.84-17.92-35.84-38.4z m-97.28-194.56c-17.92 28.16-33.28 58.88-40.96 89.6L28.16 94.72C61.44 43.52 117.76 7.68 184.32 7.68h307.2l107.52 107.52c-30.72-12.8-64-17.92-97.28-17.92-92.16 2.56-174.08 48.64-222.72 120.32z m20.48 335.36l7.68 7.68c28.16 30.72 53.76 61.44 76.8 97.28L64 972.8C25.6 939.52 0 890.88 0 834.56V225.28l250.88 250.88c12.8 28.16 28.16 53.76 48.64 76.8z m476.16-181.76c0-35.84-7.68-69.12-17.92-99.84l245.76 245.76-276.48 279.04-117.76-117.76c25.6-40.96 56.32-79.36 89.6-117.76l7.68-7.68c40.96-48.64 69.12-112.64 69.12-181.76zM491.52 878.08c2.56 2.56 5.12 5.12 10.24 5.12s7.68-2.56 10.24-5.12c10.24-33.28 25.6-66.56 40.96-99.84l94.72 94.72-145.92 145.92H184.32c-15.36 0-30.72-2.56-43.52-5.12l286.72-286.72c25.6 48.64 48.64 99.84 64 151.04z" fill="#B3CE7D" p-id="6046"></path><path d="M765.44 376.32c0 66.56-25.6 128-66.56 174.08l-7.68 5.12c-79.36 87.04-140.8 192-179.2 307.2-2.56 2.56-5.12 5.12-10.24 5.12s-7.68-2.56-10.24-5.12c-38.4-115.2-99.84-217.6-179.2-307.2l-7.68-7.68-2.56-2.56 2.56 2.56c-40.96-46.08-66.56-107.52-66.56-174.08 0-56.32 17.92-107.52 46.08-148.48C332.8 156.16 409.6 112.64 499.2 112.64s168.96 43.52 215.04 112.64c33.28 43.52 51.2 94.72 51.2 151.04z m-289.28-112.64h-33.28v61.44h-38.4c-38.4 0-71.68 30.72-71.68 71.68v15.36c0 38.4 30.72 71.68 71.68 71.68h66.56v-2.56h2.56v-217.6z m176.64 64h-35.84v125.44h-40.96c-15.36 0-30.72-12.8-30.72-30.72v-97.28H512V435.2c0 25.6 20.48 48.64 48.64 48.64h92.16v-156.16z m-276.48 84.48v-15.36c0-20.48 15.36-35.84 35.84-35.84h30.72v89.6h-30.72c-20.48-2.56-35.84-17.92-35.84-38.4z" fill="#F93737" p-id="6047"></path><path d="M824.32 10.24c102.4 0 184.32 81.92 184.32 184.32v97.28l-281.6-281.6h97.28z" fill="#B2E5FF" p-id="6048"></path><path d="M279.04 217.6c-17.92 28.16-33.28 58.88-40.96 89.6L28.16 94.72C61.44 43.52 117.76 7.68 184.32 7.68h307.2l107.52 107.52c-30.72-12.8-64-17.92-97.28-17.92-92.16 2.56-174.08 48.64-222.72 120.32z m496.64 153.6c0-35.84-7.68-69.12-17.92-99.84l245.76 245.76-276.48 279.04-117.76-117.76c25.6-40.96 56.32-79.36 89.6-117.76l7.68-7.68c40.96-48.64 69.12-112.64 69.12-181.76z" fill="#E6F28F" p-id="6049"></path></svg>',
        width: 24,
        height: 24
      },
      gaode: {
        body: '<svg t="1716185147787" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4078" width="24" height="24"><path d="M658.285714 621.714286h365.714286v256a146.285714 146.285714 0 0 1-146.285714 146.285714h-219.428572V621.714286z" fill="#B2D8FF" p-id="4079"></path><path d="M1024 364.397714V218.624H0v145.773714z" fill="#FFFFFF" p-id="4080"></path><path d="M649.142857 1024h145.773714V0H649.142857z" fill="#FFFFFF" p-id="4081"></path><path d="M1024 729.417143v-145.773714H0v145.773714z" fill="#FFCF68" p-id="4082"></path><path d="M0 218.624h649.179429V0H146.285714a146.285714 146.285714 0 0 0-146.285714 146.285714v72.338286z" fill="#AFE881" p-id="4083"></path><path d="M195.803429 1024H341.577143V0H195.803429z" fill="#FFCF68" p-id="4084"></path><path d="M103.862857 543.670857L349.622857 618.057143l302.628572-256.950857-234.569143 276.772571 262.765714 81.188572 135.314286-520.192z" fill="#0093FD" p-id="4085"></path><path d="M652.251429 361.142857L349.586286 618.057143l68.096 19.821714z" fill="#0066BD" p-id="4086"></path><path d="M349.622857 618.093714v143.908572l97.938286-114.834286-97.974857-29.074286z" fill="#0064BB" p-id="4087"></path></svg>',
        width: 24,
        height: 24
      },
      youku: {
        body: '<svg t="1716185468594" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7073" width="24" height="24"><path d="M740.113 555.315l0.205-0.307c0.512-0.82 0.887-1.707 1.4-2.526 0.204-0.41 0.409-0.82 0.716-1.229 0.205-0.307 0.341-0.682 0.512-1.024 5.598-10.956 8.636-23.04 8.738-35.328v-2.457a80.76 80.76 0 0 0-8.738-35.362c-0.205-0.308-0.307-0.683-0.512-1.024a7.578 7.578 0 0 0-0.683-1.195c-0.546-0.82-0.921-1.707-1.433-2.526-0.103-0.102-0.103-0.205-0.205-0.341a71.339 71.339 0 0 0-4.983-7.305v-0.102a76.902 76.902 0 0 0-8.124-9.148l-0.205-0.17a106.462 106.462 0 0 0-5.086-4.472c-0.41-0.341-0.682-0.614-1.126-0.922l-3.652-2.73a5.632 5.632 0 0 1-0.82-0.615l-250.88-168.14a80.247 80.247 0 0 0-60.586-12.186 80.213 80.213 0 0 0-51.405 34.236 80.862 80.862 0 0 0 22.05 112.06l150.87 101.17-150.972 101.172a80.862 80.862 0 0 0-22.05 112.06 80.213 80.213 0 0 0 51.404 34.235 80.247 80.247 0 0 0 60.553-12.185L715.913 580.71a5.632 5.632 0 0 0 0.819-0.614l1.536-1.024 2.218-1.604 1.127-0.922c1.843-1.433 3.447-2.935 5.086-4.437l0.204-0.24c2.936-2.832 5.7-5.87 8.124-9.147v-0.102c1.912-2.321 3.55-4.779 5.086-7.305z" fill="#FF4A4A" p-id="7074"></path><path d="M979.149 312.627a504.286 504.286 0 0 0-108.886-161.45A506.778 506.778 0 0 0 510.976 2.526c-86.016 0-171.042 21.913-245.93 63.385A510.26 510.26 0 0 0 85.162 233.335 506.368 506.368 0 0 0 2.97 510.464c0 68.574 13.38 135.1 39.936 197.769a505.651 505.651 0 0 0 108.783 161.45A508.757 508.757 0 0 0 313.105 978.57a509.61 509.61 0 0 0 435.712-19.115A512.341 512.341 0 0 0 926.583 802.61a504.9 504.9 0 0 0 92.331-292.181 501.214 501.214 0 0 0-39.8-197.769zM510.976 857.532c-191.386 0-347.136-155.717-347.136-347.136 0-67.55 19.456-132.95 56.115-189.235a346.453 346.453 0 0 1 291.021-157.867c191.42 0 347.136 155.716 347.136 347.136 0 71.919-21.845 140.97-63.078 199.51a347.477 347.477 0 0 1-284.058 147.592z" fill="#38CEFF" p-id="7075"></path><path d="M907.332 690.415a80.35 80.35 0 0 0-112.06 19.524 80.35 80.35 0 0 0 65.707 126.669c25.293 0 50.176-11.878 65.843-34.133a80.555 80.555 0 0 0-19.49-112.06z m-798.72-345.77a80.486 80.486 0 0 0 87.894-134.827 80.486 80.486 0 0 0-87.86 134.826z" fill="#0B99FF" p-id="7076"></path><path d="M751.684 512.444a82.193 82.193 0 0 0-8.738-35.362c-0.205-0.308-0.307-0.683-0.512-1.024a7.578 7.578 0 0 0-0.683-1.195c-0.546-0.82-0.921-1.707-1.433-2.526-0.103-0.102-0.103-0.205-0.205-0.341-0.717-1.093-1.331-2.219-2.15-3.243-0.922-1.4-1.912-2.73-2.936-4.062v-0.102a87.04 87.04 0 0 0-8.124-9.148l-0.204-0.17a106.462 106.462 0 0 0-5.086-4.472c-0.41-0.341-0.683-0.614-1.127-0.922a17.954 17.954 0 0 0-2.218-1.638l-1.536-1.024a79.701 79.701 0 0 0-45.91-14.2c-16.042 0-31.607 4.78-44.885 13.722l-100.01 67.038 100.01 67.038c13.312 8.943 28.843 13.721 44.885 13.721a80.982 80.982 0 0 0 45.91-14.233l1.536-1.024 2.218-1.604 1.127-0.922a157.672 157.672 0 0 0 5.086-4.437l0.204-0.24a77.32 77.32 0 0 0 8.124-9.147v-0.102c1.024-1.298 1.912-2.629 2.936-4.062l2.15-3.243 0.205-0.307a31.88 31.88 0 0 0 1.4-2.526c0.204-0.41 0.409-0.82 0.716-1.229 0.205-0.307 0.341-0.683 0.512-1.024 5.598-10.957 8.533-23.04 8.738-35.362v-2.628z" fill="#F5001A" p-id="7077"></path></svg>',
        width: 24,
        height: 24
      },
      bilibili: {
        body: '<svg t="1716185543850" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8124" width="24" height="24"><path d="M0 0m184.32 0l655.36 0q184.32 0 184.32 184.32l0 655.36q0 184.32-184.32 184.32l-655.36 0q-184.32 0-184.32-184.32l0-655.36q0-184.32 184.32-184.32Z" fill="#EC5D85" p-id="8125"></path><path d="M512 241.96096h52.224l65.06496-96.31744c49.63328-50.31936 89.64096 0.43008 63.85664 45.71136l-34.31424 51.5072c257.64864 5.02784 257.64864 43.008 257.64864 325.03808 0 325.94944 0 336.46592-404.48 336.46592S107.52 893.8496 107.52 567.90016c0-277.69856 0-318.80192 253.14304-324.95616l-39.43424-58.368c-31.26272-54.90688 37.33504-90.40896 64.68608-42.37312l60.416 99.80928c18.18624-0.0512 41.18528-0.0512 65.66912-0.0512z" fill="#EF85A7" p-id="8126"></path><path d="M512 338.5856c332.8 0 332.8 0 332.8 240.64s0 248.39168-332.8 248.39168-332.8-7.75168-332.8-248.39168 0-240.64 332.8-240.64z" fill="#EC5D85" p-id="8127"></path><path d="M281.6 558.08a30.72 30.72 0 0 1-27.47392-16.97792 30.72 30.72 0 0 1 13.73184-41.216l122.88-61.44a30.72 30.72 0 0 1 41.216 13.74208 30.72 30.72 0 0 1-13.74208 41.216l-122.88 61.44a30.59712 30.59712 0 0 1-13.73184 3.23584zM752.64 558.08a30.60736 30.60736 0 0 1-12.8512-2.83648l-133.12-61.44a30.72 30.72 0 0 1-15.04256-40.7552 30.72 30.72 0 0 1 40.76544-15.02208l133.12 61.44A30.72 30.72 0 0 1 752.64 558.08zM454.656 666.88a15.36 15.36 0 0 1-12.288-6.1952 15.36 15.36 0 0 1 3.072-21.49376l68.5056-50.91328 50.35008 52.62336a15.36 15.36 0 0 1-22.20032 21.23776l-31.5904-33.024-46.71488 34.72384a15.28832 15.28832 0 0 1-9.13408 3.04128z" fill="#EF85A7" p-id="8128"></path><path d="M65.536 369.31584c15.03232 101.90848 32.84992 147.17952 44.544 355.328 14.63296 2.18112 177.70496 10.04544 204.05248-74.62912a16.14848 16.14848 0 0 0 1.64864-10.87488c-30.60736-80.3328-169.216-60.416-169.216-60.416s-10.36288-146.50368-11.49952-238.83776zM362.25024 383.03744l34.816 303.17568h34.64192L405.23776 381.1328zM309.52448 536.28928h45.48608l16.09728 158.6176-31.82592 1.85344zM446.86336 542.98624h45.80352V705.3312h-33.87392zM296.6016 457.97376h21.39136l5.2736 58.99264-18.91328 2.26304zM326.99392 457.97376h21.39136l2.53952 55.808-17.408 1.61792zM470.62016 459.88864h19.456v62.27968h-19.456zM440.23808 459.88864h22.20032v62.27968h-16.62976z" fill="#FFFFFF" p-id="8129"></path><path d="M243.56864 645.51936a275.456 275.456 0 0 1-28.4672 23.74656 242.688 242.688 0 0 1-29.53216 17.52064 2.70336 2.70336 0 0 1-4.4032-1.95584 258.60096 258.60096 0 0 1-5.12-29.57312c-1.41312-12.1856-1.95584-25.68192-2.16064-36.36224 0-0.3072 0-2.5088 3.01056-1.90464a245.92384 245.92384 0 0 1 34.22208 9.5744 257.024 257.024 0 0 1 32.3584 15.17568c0.52224 0.256 2.51904 1.4848 0.09216 3.77856z" fill="#EB5480" p-id="8130"></path><path d="M513.29024 369.31584c15.03232 101.90848 32.84992 147.17952 44.544 355.328 14.63296 2.18112 177.70496 10.04544 204.05248-74.62912a16.14848 16.14848 0 0 0 1.64864-10.87488c-30.60736-80.3328-169.216-60.416-169.216-60.416s-10.36288-146.50368-11.49952-238.83776zM810.00448 383.03744l34.816 303.17568h34.64192L852.992 381.1328zM757.27872 536.28928h45.48608l16.09728 158.6176-31.82592 1.85344zM894.6176 542.98624h45.80352V705.3312H906.5472zM744.35584 457.97376h21.39136l5.2736 58.99264-18.91328 2.26304zM774.74816 457.97376h21.39136l2.53952 55.808-17.408 1.61792zM918.3744 459.88864h19.456v62.27968h-19.456zM887.99232 459.88864h22.20032v62.27968h-16.62976z" fill="#FFFFFF" p-id="8131"></path><path d="M691.32288 645.51936a275.456 275.456 0 0 1-28.4672 23.74656 242.688 242.688 0 0 1-29.53216 17.52064 2.70336 2.70336 0 0 1-4.4032-1.95584 258.60096 258.60096 0 0 1-5.12-29.57312c-1.41312-12.1856-1.95584-25.68192-2.16064-36.36224 0-0.3072 0-2.5088 3.01056-1.90464a245.92384 245.92384 0 0 1 34.22208 9.5744 257.024 257.024 0 0 1 32.3584 15.17568c0.52224 0.256 2.51904 1.4848 0.09216 3.77856z" fill="#EB5480" p-id="8132"></path></svg>',
        width: 24,
        height: 24
      },
      modao: {
        body: '<svg t="1716185608586" class="icon" viewBox="0 0 1061 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9191" width="24" height="24"><path d="M601.043478 881.15942c-1.855072-5.194203-17.066667-40.069565-33.391304-77.542029-16.324638-37.843478-29.681159-70.121739-29.68116-71.976811s13.727536-11.501449 30.423189-21.147826c74.944928-44.521739 131.710145-120.208696 157.310145-209.994203 10.017391-34.504348 10.017391-35.988406 12.243478-190.70145l2.226087-155.826087 79.397101-1.113043c43.77971-0.742029 83.478261-0.371014 88.30145 1.113043l8.904348 2.226087-1.484058 162.133334c-1.113043 147.663768-2.226087 165.101449-9.275363 196.637681-17.437681 77.913043-47.86087 148.776812-89.043478 206.284058-42.295652 58.991304-115.756522 125.031884-176.231884 157.681159-26.342029 14.098551-34.875362 14.469565-39.698551 2.226087zM132.452174 480.092754c-1.484058-1.484058-2.597101-74.944928-2.597102-163.246377 0-126.886957 1.113043-160.649275 4.823189-162.133334 8.162319-2.968116 163.617391-2.597101 168.811594 0.371015 3.710145 2.597101 4.452174 37.843478 3.710145 164.35942l-1.113043 161.02029-85.704348 1.113044c-47.118841 0.371014-86.446377-0.371014-87.930435-1.484058zM421.843478 480.092754c-1.484058-1.484058-2.597101-74.944928-2.597101-163.246377 0-126.515942 1.113043-160.649275 4.823188-162.133334 7.791304-2.968116 163.988406-2.226087 168.811594 0.742029 3.33913 2.226087 4.452174 39.698551 3.710145 163.988406l-1.113043 161.02029-85.704348 1.113044c-47.118841 0.371014-86.446377-0.371014-87.930435-1.484058z" fill="#FF3332" p-id="9192"></path></svg>',
        width: 24,
        height: 24
      },
      lanhu: {
        body: '<svg t="1716185640724" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11680" width="24" height="24"><path d="M959.445292 862.225843c38.558128 43.498852 6.246304 133.850105-74.735493 94.088796-167.319032-82.174739-200.485883 60.133477-374.071698 65.217559-173.596055 5.094322-211.422035-147.387178-373.677464-65.217559-80.495404 40.749454-113.303861-50.589943-74.750853-94.088796 53.800134-60.665949 104.461757-130.138162 105.506221-384.147703-0.445433-8.125315 0-11.04367 0-19.271384 0-103.340494 35.977688-197.244972 94.626387-266.732546-5.913509-6.891414-12.123974-15.856397-18.267879-26.213998a61.346898 61.346898 0 0 1-1.658855-2.969554 340.239257 340.239257 0 0 1-16.102153-31.164962 370.523592 370.523592 0 0 1-13.444913-33.996278c-0.455673-1.443818-0.993265-2.887636-1.372139-4.336573a303.662539 303.662539 0 0 1-6.082467-21.862065C197.677785 37.903137 199.121603 9.113819 218.408347 0.947544c10.941272-4.638649 24.160909 8.46323 39.495073 27.744854 0.537592 0.686069 1.146862 1.382379 1.745894 2.129887 0.691189 0.844787 1.372139 1.684454 2.053088 2.590681 10.019686 12.953401 21.114556 28.118608 33.177091 42.142073 0.931826 1.059824 1.827812 2.135007 2.749398 3.20507 0.527352 0.604151 1.059824 1.203182 1.587175 1.827812 14.602016 16.419588 30.60177 30.842407 47.989024 37.974457 49.105166-30.217776 105.470381-47.405352 165.42466-47.405352 58.443903 0 113.493298 16.347909 161.728078 45.173067 15.492882-7.679882 29.838902-20.87904 43.038059-35.737052 0.537592-0.62975 1.075183-1.228781 1.597416-1.832932l2.734038-3.20507c12.083015-14.028585 23.172764-29.183552 33.18221-42.142073 0.691189-0.906226 1.372139-1.745893 2.063329-2.590681 0.599031-0.747509 1.208301-1.443818 1.740773-2.129887 15.339285-19.281624 28.548682-32.383503 39.500194-27.744854 19.276504 8.161155 20.735682 36.955593 12.98412 70.572997a298.419739 298.419739 0 0 1-6.082466 21.867184c-0.368634 1.448938-0.906226 2.892756-1.361899 4.336573a379.514174 379.514174 0 0 1-13.434674 33.996278 342.829938 342.829938 0 0 1-16.112393 31.164962c-0.522232 0.993265-1.059824 1.97117-1.669094 2.969555-4.710328 7.935878-9.446255 15.052569-14.079784 21.047996C819.743116 256.882175 857.543496 352.880702 857.543496 458.811876c0 6.041507-0.02048 6.246304-0.266236 12.231492 0.122878 259.411058 47.917344 330.004534 102.168032 391.187595z" fill="#0692FF" p-id="11681"></path><path d="M510.863377 640.374529c112.67923 0 203.982789-92.189305 203.982789-205.87716 0-39.295397-10.931032-75.994993-29.96178-107.282833 0-0.081919-0.071679-0.153598-0.143358-0.240637-35.747291-58.955895-100.227582-98.261532-173.872531-98.261531-112.668991 0-204.054468 92.117626-204.054467 205.785001a206.368672 206.368672 0 0 0 53.027026 138.432435c37.354947 41.389445 91.124361 67.444725 151.022321 67.444725z" fill="#FFFFFF" p-id="11682"></path><path d="M554.223992 290.089986c57.030805 0 103.268815 46.632244 103.268815 104.1904 0 57.532557-46.23801 104.169921-103.268815 104.169921-57.030805 0-103.268815-46.637364-103.268815-104.169921 0-57.558156 46.23801-104.190401 103.268815-104.1904z" fill="#293D50" p-id="11683"></path></svg>',
        width: 24,
        height: 24
      },
      qqvideo: {
        body: '<svg t="1716186856310" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16273" width="24" height="24"><path d="M199.111111 0h625.777778c109.795556 0 199.111111 89.315556 199.111111 199.111111v625.777778c0 109.795556-89.315556 199.111111-199.111111 199.111111H199.111111c-109.795556 0-199.111111-89.315556-199.111111-199.111111V199.111111C0 89.315556 89.315556 0 199.111111 0z" fill="#FFFFFF" p-id="16274"></path><path d="M327.68 143.36c25.6-2.844444 51.768889 0.568889 75.662222 9.102222 52.906667 17.066667 104.675556 38.684444 154.737778 63.146667 84.195556 41.528889 164.977778 89.884444 242.346667 143.36 34.133333 22.755556 65.991111 48.924444 94.435555 78.506667 15.928889 18.204444 28.444444 40.96 26.168889 65.422222-3.413333 29.582222-23.893333 52.906667-44.373333 72.817778-84.195556 79.644444-176.924444 150.186667-276.48 209.92-51.2 30.72-105.813333 55.751111-162.133334 75.662222-36.408889 12.515556-74.524444 23.324444-113.208888 19.342222-23.324444-1.706667-44.942222-11.946667-60.871112-28.444444-13.084444-15.36-21.617778-33.564444-25.031111-52.906667l1.137778-1.706667c17.066667-3.982222 33.564444-9.102222 50.631111-13.084444 71.111111-18.204444 139.946667-44.373333 205.368889-77.368889 70.542222-34.133333 137.671111-73.955556 201.386667-119.466667 20.48-15.36 43.235556-30.72 55.182222-55.182222 7.964444-17.635556 6.826667-38.115556-3.982222-54.613333-12.515556-19.342222-29.013333-35.271111-48.355556-48.355556-21.617778-15.36-44.373333-29.582222-67.697778-42.666667-44.373333-26.737778-91.022222-49.493333-138.24-72.248888-54.044444-26.168889-109.795556-48.355556-167.253333-66.56-25.6-7.395556-51.2-15.36-76.8-22.186667 2.844444-11.377778 6.257778-22.755556 10.808889-33.564445 13.084444-26.168889 37.546667-44.942222 66.56-48.924444z" fill="#10ABF2" p-id="16275"></path><path d="M168.96 231.537778c23.893333-11.377778 51.768889-7.964444 76.8-3.413334-7.395556 33.564444-11.946667 67.697778-17.066667 101.831112-0.568889 14.791111-2.275556 29.013333-3.982222 43.804444-2.844444 18.204444-2.275556 36.977778-5.12 55.182222-0.568889 21.048889-1.706667 42.666667-2.275555 64.284445-2.275556 20.48-1.137778 41.528889-1.137778 62.008889 0 30.72-0.568889 62.008889 1.706666 92.728888 1.706667 47.217778 5.12 93.866667 11.377778 140.515556v6.826667c-23.893333 4.551111-51.768889 7.964444-73.955555-6.826667s-27.875556-42.097778-33.564445-65.991111c-13.084444-76.8-19.911111-154.737778-19.342222-233.244445 1.137778-40.96 5.12-81.351111 10.808889-121.742222 4.551111-32.995556 11.946667-65.422222 22.755555-97.28 5.688889-16.497778 17.635556-30.72 32.995556-38.684444z" fill="#FF8F21" p-id="16276"></path><path d="M246.897778 225.848889l5.12 0.568889c25.6 6.826667 51.2 14.791111 76.8 22.186666 57.457778 18.204444 113.208889 40.96 167.253333 67.128889 46.648889 23.324444 93.297778 46.08 138.24 72.248889 23.324444 13.084444 46.08 27.306667 67.697778 42.666667 19.342222 12.515556 35.271111 29.013333 48.355555 47.786667 10.808889 16.497778 11.946667 36.977778 3.982223 54.613333-11.377778 23.893333-34.702222 39.253333-55.182223 55.182222-63.715556 45.511111-130.844444 85.333333-201.386666 119.466667-65.991111 32.995556-134.826667 58.595556-205.937778 77.368889-17.066667 3.982222-33.564444 9.102222-50.631111 13.084444l-9.671111 1.706667c-0.568889-3.982222-1.137778-7.964444-1.706667-12.515556-6.257778-46.648889-9.671111-93.866667-11.377778-140.515555-3.413333-30.72-2.275556-62.008889-2.275555-92.728889-0.568889-20.48 0-41.528889 1.137778-62.008889 0.568889-21.048889 1.706667-42.666667 2.275555-64.284445 2.844444-18.204444 2.275556-36.977778 5.12-55.182222 1.706667-14.222222 3.413333-29.013333 3.982222-43.804444 5.12-34.133333 9.102222-68.266667 17.066667-101.831111l0.568889-2.275556 0.568889 1.137778z m96.711111 122.311111c-9.102222 3.413333-14.791111 11.946667-14.222222 21.048889-0.568889 13.653333-0.568889 27.306667 0.568889 40.96 0.568889 40.391111-0.568889 81.351111 0.568888 121.742222v108.088889c-1.137778 9.102222 2.844444 18.204444 10.808889 23.324444 9.102222 2.275556 19.342222 0.568889 26.737778-5.688888 65.422222-43.804444 131.413333-87.608889 196.835556-131.413334 7.964444-5.688889 17.066667-14.222222 15.928889-25.6-1.706667-10.24-8.533333-19.342222-18.204445-23.893333L362.951111 353.28c-5.688889-3.982222-12.515556-5.688889-19.342222-5.12z" fill="#7DE621" p-id="16277"></path><path d="M343.608889 348.16c6.826667-0.568889 13.653333 1.137778 19.342222 5.12l200.817778 124.017778c9.671111 4.551111 16.497778 13.084444 18.204444 23.893333 1.137778 10.808889-7.964444 19.342222-15.928889 25.6-65.422222 43.235556-131.413333 87.04-196.835555 130.844445-7.395556 5.688889-17.635556 7.964444-26.737778 5.688888-7.395556-5.12-11.377778-13.653333-10.808889-22.755555v-108.088889c-1.137778-40.391111 0-81.351111-0.568889-121.742222-1.137778-13.653333-1.706667-27.306667-1.137777-41.528889-1.137778-9.102222 5.12-17.635556 13.653333-21.048889z" fill="#FFFFFF" p-id="16278"></path></svg>',
        width: 24,
        height: 24
      },
      figma: {
        body: '<svg t="1716187077296" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17340" width="24" height="24"><path d="M512 512c0-94.4 76.8-171.2 171.2-171.2 94.4 0 171.2 76.8 171.2 171.2s-76.8 171.2-171.2 171.2C588.8 683.2 512 606.4 512 512z" fill="#1ABCFE" p-id="17341"></path><path d="M171.2 852.8c0-94.4 76.8-171.2 171.2-171.2H512v171.2C512 947.2 435.2 1024 340.8 1024s-169.6-76.8-169.6-171.2z" fill="#0ACF83" p-id="17342"></path><path d="M512 0v340.8h171.2c94.4 0 171.2-76.8 171.2-171.2S777.6 0 683.2 0H512z" fill="#FF7262" p-id="17343"></path><path d="M171.2 171.2c0 94.4 76.8 171.2 171.2 171.2H512V0H340.8c-94.4 0-169.6 76.8-169.6 171.2z" fill="#F24E1E" p-id="17344"></path><path d="M171.2 512c0 94.4 76.8 171.2 171.2 171.2H512V340.8H340.8c-94.4 0-169.6 76.8-169.6 171.2z" fill="#A259FF" p-id="17345"></path></svg>',
        width: 24,
        height: 24
      },
      canva: {
        body: '<svg t="1716187133225" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23499" width="24" height="24"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0zM297.056 327.68c32.16 0 57.056 23.424 59.936 51.2 2.944 24.864-7.296 46.816-35.072 60-14.624 7.296-20.48 7.328-23.424 2.944-1.44-2.944 0-5.856 2.944-8.8 26.336-21.92 26.336-39.52 23.392-64.352-1.44-16.128-13.152-26.368-24.864-26.368-51.2 0-124.32 114.08-114.08 197.504 4.384 32.16 23.424 70.24 64.384 70.24 13.152 0 27.744-4.384 40.96-10.24 21.344-11.264 34.08-20.064 46.816-34.144-3.104-37.76 30.048-87.296 78.976-87.296 21.984 0 39.52 8.736 40.96 24.864 2.912 21.92-16.096 24.832-21.92 24.832s-16.128-1.44-16.128-7.264c-1.44-5.888 13.184-2.976 11.744-16.128-1.504-8.8-10.24-11.68-19.04-11.68-30.72 0-48.256 42.4-43.904 68.736 1.504 11.744 7.328 23.424 19.072 23.424 8.736 0 21.92-13.216 26.336-32.224 2.912-13.152 14.624-21.92 24.864-21.92 4.352 0 7.264 1.44 8.736 7.296v5.888c-1.44 5.856-5.856 23.392-4.352 27.776 0 2.944 1.44 7.296 7.264 7.296 3.936 0 18.592-7.68 33.152-19.584 4.992-25.184 10.784-55.392 10.784-57.888 1.44-10.24 5.856-20.48 26.336-20.48 4.384 0 7.296 1.44 8.736 7.296v5.888l-5.792 26.336c18.976-24.864 46.816-42.4 64.352-42.4 7.328 0 13.184 4.352 13.184 11.68 0 4.384 0 11.68-2.944 19.04a474.88 474.88 0 0 0-17.568 62.88c0 5.856 1.504 11.68 8.832 11.68 7.296 0 29.216-8.8 46.752-32.16l0.288-0.16c-0.096-2.912-0.288-5.728-0.288-8.608 0-17.536 1.504-32.16 4.448-42.4 2.912-11.68 17.536-21.92 26.336-21.92 4.384 0 8.736 2.944 8.736 7.296 0 1.504 0 4.384-1.44 5.856-5.856 19.04-10.24 36.576-10.24 54.144 0 10.24 1.44 24.832 4.352 33.632 0 1.44 1.504 2.944 2.976 2.944 2.912 0 23.392-18.976 37.984-43.872-13.152-8.8-20.48-23.424-20.48-40.96 0-30.72 19.04-46.816 36.608-46.816 14.624 0 26.336 10.24 26.336 30.72 0 13.152-4.384 27.744-11.68 40.96h4.352l1.056 0.032c9.376 0 17.856-3.936 23.84-10.24a12.448 12.448 0 0 1 5.632-4.96l0.096-0.032c14.304-18.144 35.424-31.584 60.16-31.584 20.48 0 39.424 8.736 40.928 24.832 2.912 21.984-16.128 26.368-21.984 26.368l-0.096-0.096c-5.888 0-16.096-1.504-16.096-7.328s13.184-2.912 11.68-16.032c-1.44-8.8-10.24-11.744-19.04-11.744-29.28 0-48.224 38.016-43.872 68.736 1.44 11.744 7.296 24.864 18.976 24.864 8.8 0 21.984-13.152 27.808-32.16 2.912-11.68 14.624-21.92 24.864-21.92 4.384 0 7.264 1.44 8.736 7.296 0 2.944 0 8.8-5.856 27.808-7.264 13.152-7.296 20.48-5.856 26.336 1.44 11.68 7.296 20.48 13.184 24.864 1.44 1.44 2.912 4.352 2.912 4.352 0 2.944-1.44 5.888-5.856 5.888-1.44 0-2.912 0-4.384-1.504-21.92-8.736-30.72-23.392-33.664-38.016-8.736 10.24-18.976 16.096-30.72 16.096-18.976 0-37.984-17.536-40.96-39.52a68.8 68.8 0 0 1 3.328-28.192l-0.128 0.48c-8.672 5.536-18.016 8.672-26.592 8.672h-7.264c-19.072 27.808-39.552 46.848-54.176 55.584a38.048 38.048 0 0 1-16 4.448h-0.096c-2.912 0-7.296-1.504-8.736-4.448-4.064-6.496-6.656-16.736-8.224-28.448-20.512 22.496-48.864 34.336-61.984 34.336-14.624 0-23.392-8.8-24.832-23.456v-16.032c4.352-32.16 16.096-51.2 16.096-57.056a3.136 3.136 0 0 0-2.944-2.976c-10.24 0-43.872 35.168-49.76 58.592l-4.384 18.976c-2.912 13.184-16.096 21.984-24.832 21.984-4.384 0-7.328-1.504-8.8-7.328v-5.856l1.952-9.952c-18.56 13.216-37.12 21.664-45.856 21.664-13.152 0-20.48-7.328-21.92-17.568-8.8 11.68-18.976 17.568-32.16 17.568-15.008 0-29.696-10.24-36.768-25.312-10.4 11.744-22.304 23.584-36.352 32.608-20.48 13.184-43.872 23.424-71.68 23.424-24.832 0-46.816-13.184-58.496-24.864-17.568-16.096-27.776-40.96-29.28-64.384-8.736-71.68 35.104-163.84 102.4-204.8 16.128-8.736 32.224-14.624 48.288-14.624z m416.832 140.416c-4.448 0-7.328 7.328-7.328 14.624 0 11.68 5.856 24.864 13.184 32.224a72.64 72.64 0 0 0 4.352-24.864c0-14.624-5.856-21.984-10.208-21.984z" fill="#00C4CC" p-id="23500"></path></svg>',
        width: 24,
        height: 24
      },
      processon: {
        body: '<svg t="1716187155553" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="24554" width="24" height="24"><path d="M241.29537297 142.80465793C204.50619412 147.5843544 170.32412243 172.20703316 154.24696159 205.66490841 140.92174722 233.32921219 141.93562222 206.96846199 141.93562222 513.44839287c0 259.11748409 0.14483929 270.55978775 2.75194645 280.26401997C153.66760444 827.74964523 175.97285461 855.41394901 205.66490841 869.75303841c27.66430378 13.32521438 1.30355359 12.31133938 307.78348446 12.31133937 259.11748409 0 270.55978775-0.14483929 280.26401997-2.75194645 34.0372324-8.98003579 61.70153618-31.28528595 76.04062557-60.97733974 13.32521438-27.66430378 12.31133938-1.30355359 12.31133937-307.78348446 0-259.11748409-0.14483929-270.55978775-2.75194644-280.26401997C870.33239556 196.25035477 848.02714539 168.4412117 818.33509159 154.24696159c-27.66430378-13.32521438 0.43451786-12.16650009-301.26571655-12.45617866C370.4920168 141.64594364 246.364748 142.0804615 241.29537297 142.80465793z m158.59901905 177.28328706c36.06498242 6.37292861 62.42573261 19.40846443 87.48292923 43.59662532 25.63655377 24.76751804 42.29307175 56.19764328 50.83858967 96.46296502 3.76582146 17.5255537 5.35905361 60.25314331 2.89678573 80.24096489-11.29746438 92.40746498-66.62607193 152.22609043-152.08125115 164.39259052-19.11878586 2.60710716-54.02505397 1.013875-71.4057684-3.47614289-66.48123264-17.38071443-111.52625084-69.0883398-125.28598308-144.40476894-3.47614289-18.97394658-3.47614289-66.33639336-0.14483928-84.73098278 4.20033931-22.30525017 9.55939293-38.38241101 19.26362514-57.93571472 16.51167869-33.31303597 36.64433956-55.47344685 66.62607193-73.5783577 15.64264297-9.26971435 41.42403603-18.24975014 60.97733975-21.14653587 14.48392868-2.1725893 46.92792893-1.73807144 60.83250046 0.57935715z m360.21530628 104.28428649c29.11269665 6.08325005 53.73537541 27.66430378 65.03283977 56.77700043 8.98003579 23.0294466 8.83519649 21.43621445 9.41455365 124.56178665l0.57935714 94.58005429H765.46875191v-83.71710778c0-91.82810783-0.28967857-95.73876858-8.69035721-112.82980442-7.53164291-15.20812511-19.26362514-22.73976803-38.52725029-24.62267876-21.14653587-2.02775002-43.30694676 11.29746438-53.88021469 32.15432167-5.64873218 11.15262508-6.08325005 19.84298229-6.08325005 106.02235795V700.29107285h-69.23317909l-0.72419643-132.23826885c-0.43451786-72.56448269-1.30355359-133.831501-1.73807144-136.1489296l-1.01387502-3.91066075h30.41625024c27.80914307 0 30.56108952 0.28967857 31.28528595 2.46226787 0.43451786 1.44839287 1.1587143 10.13875008 1.73807143 19.26362515 0.43451786 9.12487507 1.1587143 17.09103584 1.59323216 17.81523227 0.28967857 0.57935715 3.47614289-2.75194645 6.80744648-7.38680361 13.32521438-17.96007157 35.77530383-31.57496453 60.39798259-36.354661 10.13875008-2.02775002 31.57496453-1.73807144 42.29307176 0.57935715z" fill="#067bef" p-id="24555"></path><path d="M342.82771302 376.43042755c-15.49780369 3.76582146-29.11269665 11.87682152-42.29307176 25.34687519-17.5255537 17.67039299-26.79526807 36.49950027-33.60271453 67.49510765-4.05550003 18.68426799-5.06937504 57.64603615-2.02775002 76.33030414 10.71810723 65.46735764 48.08664322 104.2842865 100.80814362 104.57396508 16.80135728 0 26.21591092-2.02775002 41.27919674-9.26971435 39.39628601-18.82910728 61.84637546-66.19155407 61.70153617-130.35535813-0.14483929-49.24535752-14.3390894-87.62776852-42.00339317-113.26432229-11.29746438-10.42842865-23.89848232-17.38071443-37.94789314-20.712018-11.15262508-2.60710716-35.19594669-2.60710716-45.91405391-0.14483929z" fill="#067bef" p-id="24556"></path></svg>',
        width: 24,
        height: 24
      },
      codepen: {
        body: '<svg t="1716187324883" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="25725" id="mx_n_1716187324884" width="24" height="24"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#030502" p-id="25726"></path><path d="M840.277 383.595l-312-208a29.333 29.333 0 0 0-32.554 0l-312 208A29.717 29.717 0 0 0 170.667 408v208c0 10.07 5.397 19.35 13.056 24.405l312 208a29.333 29.333 0 0 0 32.554 0l312-208c7.531-4.906 13.056-14.229 13.056-24.405V408c0-9.45-4.842-18.987-13.056-24.405zM541.333 254.827L771.18 408.043l-102.656 68.672-127.19-85.078v-136.81z m-58.666 0v136.81l-127.168 85.078L252.82 408.02l229.846-153.194zM229.333 462.912l73.387 49.067-73.387 49.109v-98.176z m253.334 306.261L252.8 615.957l102.677-68.65 127.147 85.056v136.81zM512 581.397L408.256 512 512 442.603 615.744 512 512 581.397z m29.333 187.776v-136.81l127.19-85.056 102.656 68.65-229.846 153.216z m253.334-208.085L721.28 512l73.387-49.088v98.155z" fill="#FFFFFF" p-id="25727"></path></svg>',
        width: 24,
        height: 24
      },
      jinshuju: {
        body: '<svg t="1716187349707" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="26820" width="24" height="24"><path d="M697.7024 128.5632c-17.8688 10.24-33.28 20.4288-49.5104 32.6144-15.872 12.0832-18.944 14.8992-38.4 34.2016-46.5408 46.6432-69.2224 96.4608-67.6864 149.3504 0.3072 11.4688 0.8704 16.7424 4.096 34.2016 1.3312 6.7584 8.1408 26.7776 12.9536 37.6832 9.9328 22.528 24.832 41.472 35.584 45.0048 13.2096 4.352 38.144 1.1264 63.3856-8.0896 28.9792-10.752 48.64-22.7328 66.0992-40.1408 29.7984-29.7984 44.288-66.6624 44.3904-112.896 0-13.824-2.2528-37.888-4.2496-46.08-0.4096-2.048-1.1264-5.12-1.3824-7.168-3.0208-16.6912-13.5168-49.6128-23.3984-73.8816-7.2704-17.408-23.7056-52.0192-25.3952-53.0432a101.12 101.12 0 0 0-16.4864 8.2432z m-577.28-5.12c0.3072 1.4336 1.024 7.936 1.536 14.6432 0.6144 6.656 1.1776 13.0048 1.4336 14.1824 0.4608 2.0992 1.7408 12.1856 2.8672 20.5312 0.512 4.8128 4.8128 31.0784 5.632 35.4816 24.1664 123.0848 59.5968 201.4208 112.7936 249.344a153.6 153.6 0 0 0 66.6624 34.8672c13.312 3.0208 16.7424 3.2768 31.8976 3.584 28.3648 0.512 66.0992-5.9904 90.368-15.616 30.9248-12.1856 46.3872-28.672 53.4528-56.832 4.608-17.7664 4.7104-19.6096 5.12-48.6912 0.3072-26.112-1.024-40.2944-5.5296-60.7232-6.656-29.6448-31.744-65.0752-59.392-83.8144-28.2624-18.9952-49.408-26.624-141.4656-51.2-47.9232-12.8-133.7344-42.5472-155.5968-54.0672-9.0624-4.8128-10.3424-4.9664-9.728-1.6896z m657.5616 357.9904c-12.9024 1.536-20.2752 2.8672-26.2144 4.4032l-8.3968 2.048c-6.912 1.2288-23.552 10.752-31.0272 17.5616-17.3056 15.872-30.7712 42.0864-37.5808 73.728-4.864 22.272-3.6864 39.9872 3.3792 49.2032 12.1856 16.0256 58.4192 32.256 91.0848 31.7952 35.1744-0.4096 73.0112-25.9584 101.12-68.2496 8.8064-13.0048 22.6816-37.6832 23.3984-41.1136 0-0.4096 1.536-3.9936 3.2768-7.7824 7.3728-16.0256 17.5616-45.6704 16.4352-47.5136a18.7904 18.7904 0 0 0-7.2192-2.1504 94.1056 94.1056 0 0 1-9.5232-1.536c-3.072-0.5632-31.3344-5.8368-37.888-6.9632-22.272-3.84-63.232-5.5296-80.8448-3.4304z m-358.4 40.2944c3.9424-1.9968 16.2816-8.3456 27.2384-14.1824 10.9056-5.632 20.5312-10.496 21.4016-10.496 0.7168-0.1536 13.4656 14.4896 28.3648 32.3584 14.7456 17.8688 28.3648 33.28 30.3616 34.1504 15.616 7.5264 38.144-4.6592 65.6384-35.328 3.1232-3.3792 6.144-5.4784 6.656-4.9152 0.768 0.6656 1.5872 5.2224 2.1504 10.0352 0.4608 4.864 1.1264 10.24 1.4336 12.0832 0.4096 1.8432 1.1264 6.0928 1.536 9.6256l3.4304 24.1152 0.1024 0.8704c2.7136 18.944 2.7136 18.9952-6.656 28.928-27.8016 29.6448-54.5792 71.7824-64.8192 102.2464a254.208 254.208 0 0 0-8.7552 36.0448l-1.4336 11.3152c-1.9968 15.0528-2.9696 41.5744-1.6896 47.5648 2.9696 13.8752 7.2192 21.9648 16.0256 29.6448 10.24 8.9088 23.2448 14.4384 43.8272 18.432 15.872 3.072 62.4128 0.8192 86.3744-4.096 3.84-0.8704 7.2192-1.3312 7.5264-0.8704a18.176 18.176 0 0 1 1.1264 5.2224l1.4336 9.7792c0.4096 2.7136 0.9728 7.2704 1.2288 9.9328 1.5872 12.6464 2.56 19.3024 3.0208 21.2992 0.256 1.1264 1.024 5.632 1.3824 10.0864l0.8704 7.936-202.24 0.256-202.4448 0.1536 1.024-10.24c0.512-5.632 1.28-11.3152 1.4336-12.4416 0.256-1.1264 0.8192-5.9904 1.2288-10.6496l1.536-11.3664a35.0208 35.0208 0 0 0 0.6144-5.12c0.1536-1.9456 1.9968-2.4064 11.9296-2.4064 6.3488 0 13.6192-0.4096 15.872-0.8192 2.4064-0.4096 5.8368-1.1264 7.68-1.536 18.1248-3.584 41.5232-17.7664 56.832-34.3552 6.2464-6.656 22.7328-30.0544 22.7328-32.2048 0-0.256 2.56-5.12 5.632-10.6496 10.8032-19.712 23.8592-55.6032 33.3824-91.648 3.7888-14.2848 4.9152-34.304 2.9696-48.1792a248.6272 248.6272 0 0 0-6.8096-34.7648c-4.5568-18.8416-15.36-52.224-22.4256-69.3248a137.0624 137.0624 0 0 1-4.2496-11.6736c0-0.6656 3.3792-2.816 7.5264-4.8128z m-202.8544 24.9856a217.5488 217.5488 0 0 0-65.0752 17.7152c-17.6128 7.5264-29.696 14.336-29.5424 16.5888 0.3072 4.2496 59.5968 84.1216 72.0896 97.1776 11.776 12.288 27.8016 23.3984 39.2704 27.0848 14.4896 4.6592 32.0512 5.12 48.2304 1.4336 30.5152-7.1168 42.3936-15.616 47.2576-33.9456 1.9456-7.7824 2.0992-38.9632 0.1024-48.896-8.0896-41.2672-27.8016-65.024-61.1328-73.728a155.7504 155.7504 0 0 0-51.2-3.4304z" fill="#FE8432" p-id="26821"></path></svg>',
        width: 24,
        height: 24
      }
    }
  });
}
const QX = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, eZ = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, tZ = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, nZ = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, oZ = on.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Ci({
        find: QX,
        type: this.type
      }),
      Ci({
        find: tZ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: eZ,
        type: this.type
      }),
      Er({
        find: nZ,
        type: this.type
      })
    ];
  }
}), ure = oZ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e == null ? void 0 : e.chain().focus().toggleBold().run(),
          isActive: () => e.isActive("bold") || !1,
          disabled: !(e != null && e.isEditable) || !e.can().toggleBold(),
          icon: "Bold",
          shortcutKeys: ["mod", "B"],
          tooltip: n("editor.bold.tooltip")
        }
      })
    };
  }
}), rZ = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, iZ = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, sZ = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, aZ = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, lZ = on.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Ci({
        find: rZ,
        type: this.type
      }),
      Ci({
        find: sZ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: iZ,
        type: this.type
      }),
      Er({
        find: aZ,
        type: this.type
      })
    ];
  }
}), dre = lZ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: ge,
          componentProps: {
            action: () => e.chain().toggleItalic().focus().run(),
            isActive: () => e.isActive("italic") || !1,
            disabled: !(e != null && e.isEditable) || !e.can().toggleItalic(),
            shortcutKeys: ["mod", "I"],
            icon: "Italic",
            tooltip: n("editor.italic.tooltip")
          }
        };
      }
    };
  }
}), cZ = on.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), fre = cZ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: ge,
          componentProps: {
            action: () => e.chain().toggleUnderline().focus().run(),
            isActive: () => e.isActive("underline") || !1,
            disabled: !e.isEditable || !e.can().toggleUnderline(),
            icon: "Underline",
            shortcutKeys: ["mod", "U"],
            tooltip: n("editor.underline.tooltip")
          }
        };
      }
    };
  }
}), uZ = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, dZ = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, fZ = on.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Ci({
        find: uZ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: dZ,
        type: this.type
      })
    ];
  }
}), pre = fZ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e.chain().toggleStrike().focus().run(),
          isActive: () => e.isActive("strike") || !1,
          disabled: !e.isEditable || !e.can().toggleStrike(),
          icon: "Strikethrough",
          shortcutKeys: ["shift", "mod", "X"],
          tooltip: n("editor.strike.tooltip")
        }
      })
    };
  }
}), pZ = /(^|[^`])`([^`]+)`(?!`)/, hZ = /(^|[^`])`([^`]+)`(?!`)/g, mZ = on.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Ci({
        find: pZ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: hZ,
        type: this.type
      })
    ];
  }
}), hre = mZ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e == null ? void 0 : e.chain().focus().toggleCode().run(),
          isActive: () => e.isActive("code") || !1,
          disabled: !(e != null && e.isEditable) || !e.can().toggleCode(),
          icon: "Code",
          shortcutKeys: ["mod", "E"],
          tooltip: n("editor.code.tooltip")
        }
      })
    };
  }
});
var Gc = {}, jn = Symbol(), vi = Symbol(), yv = (t) => typeof t == "string" ? re[t] : t, re = {
  plain: Gc,
  plaintext: Gc,
  text: Gc,
  txt: Gc
}, bv = (t, e) => (e[vi] || Jf)(t, e), Jf = (t, e) => {
  for (var n = [t], o, r = [], i = 0; o = yv(e[jn]); )
    delete e[jn], Object.assign(e, o);
  for (Y3(t, e, n, 0); r[i++] = n[0], n = n[1]; )
    ;
  return r;
}, Iw = "</span>", qc = "", Sa = "", G3 = (t) => {
  for (var e = "", n = t.length, o = 0; o < n; )
    e += q3(t[o++]);
  return e;
}, q3 = (t) => {
  if (t instanceof ls) {
    var { type: e, alias: n, content: o } = t, r = qc, i = Sa, s = `<span class="token ${e + (n ? " " + n : "") + (e == "keyword" && typeof o == "string" ? " keyword-" + o : "")}">`;
    Sa += Iw, qc += s;
    var a = q3(o);
    return qc = r, Sa = i, s + a + Iw;
  }
  return typeof t != "string" ? G3(t) : (t = t.replace(/&/g, "&amp;").replace(/</g, "&lt;"), Sa && t.includes(`
`) ? t.replace(/\n/g, Sa + `
` + qc) : t);
}, Y3 = (t, e, n, o, r) => {
  for (var i in e)
    if (e[i])
      for (var s = 0, a = e[i], l = Array.isArray(a) ? a : [a]; s < l.length; ++s) {
        if (r && r[0] == i && r[1] == s)
          return;
        for (var c = l[s], u = c.pattern || c, d = yv(c.inside), f = c.lookbehind, p = c.greedy && u.global, m = c.alias, g = n, v = o; g && (!r || v < r[2]); v += g[0].length, g = g[1]) {
          var y = g[0], w = 0, x, b;
          if (!(y instanceof ls)) {
            if (u.lastIndex = p ? v : 0, x = u.exec(p ? t : y), x && f && x[1] && (b = x[1].length, x.index += b, x[0] = x[0].slice(b)), p) {
              if (!x)
                break;
              if (x[0]) {
                for (var $ = x.index, S = $ + x[0].length, k; $ >= v + (k = g[0].length); g = g[1], v += k)
                  ;
                if (g[0] instanceof ls)
                  continue;
                for (var A = g, a = v; (a += A[0].length) < S; A = A[1], w++)
                  ;
                y = t.slice(v, a), x.index -= v;
              }
            }
            if (x && x[0]) {
              for (var $ = x.index, O = x[0], M = y.slice($ + O.length), P = v + y.length, F = new ls(i, d ? bv(O, d) : O, O, m), J = g, Q = 0, G; J = J[1], Q++ < w; )
                ;
              M && (!J || J[0] instanceof ls ? J = [M, J] : J[0] = M + J[0]), v += $, g[0] = $ ? y.slice(0, $) : F, $ ? g = g[1] = [F, J] : g[1] = J, w && (Y3(t, e, g, v, G = [i, s, P]), P = G[2]), r && P > r[2] && (r[2] = P);
            }
          }
        }
      }
};
function ls(t, e, n, o) {
  this.type = t, this.content = e, this.alias = o, this.length = n.length;
}
var dd = "\\b(?:BASH(?:OPTS|_ALIASES|_ARG[CV]|_CMDS|_COMPLETION_COMPAT_DIR|_LINENO|_REMATCH|_SOURCE|_VERSINFO|_VERSION)?|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|E?UID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_(?:ADDRESS|ALL|IDENTIFICATION|MEASUREMENT|MONETARY|NAME|NUMERIC|PAPER|TELEPHONE|TIME)|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS[1-4]|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_(?:CONFIG_DIRS|CURRENT_DESKTOP|DATA_DIRS|GREETER_DATA_DIR|MENU_PREFIX|RUNTIME_DIR|SEAT|SEAT_PATH|SESSION_DESKTOP|SESSION_ID|SESSION_PATH|SESSION_TYPE|VTNR)|XMODIFIERS)\\b", Km = {
  pattern: /(^(["']?)\w+\2)[ 	]+\S.*/,
  lookbehind: !0,
  alias: "punctuation"
  // this looks reasonably well in all themes
}, J3 = {
  variable: /^\$\(|^`|\)$|`$/
}, Yc = {
  bash: Km,
  environment: {
    pattern: RegExp("\\$" + dd),
    alias: "constant"
  },
  variable: [
    // [0]: Arithmetic Environment
    {
      pattern: /\$?\(\([^]*?\)\)/g,
      greedy: !0,
      inside: {
        // If there is a $ sign at the beginning highlight $(( and )) as variable
        variable: [
          {
            pattern: /(^\$[^]+)../,
            lookbehind: !0
          },
          /^\$\(\(/
        ],
        number: /\b0x[a-fA-F\d]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
        operator: /--|\+\+|&&|\|\||(?:\*\*|<<|>>|[%&|^!=<>/*+-])=?|[?:~]/,
        // If there is no $ sign at the beginning highlight (( and )) as punctuation
        punctuation: /\(\(?|\)\)?|,|;/
      }
    },
    // [1]: Command Substitution
    {
      pattern: /\$\((?:[^()]|\([^)]*\))*\)|`[^`]+`/g,
      greedy: !0,
      inside: J3
    },
    // [2]: Brace expansion
    {
      pattern: /\$\{[^}]*\}/g,
      greedy: !0,
      inside: {
        operator: /:[?=+-]?|[!/]|##?|%%?|\^\^?|,,?/,
        punctuation: /[[\]]/,
        environment: {
          pattern: RegExp("(\\{)" + dd),
          lookbehind: !0,
          alias: "constant"
        }
      }
    },
    /\$(?:\w+|[#?*!@$])/
  ],
  // Escape sequences from echo and printf's manuals, and escaped quotes.
  entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[a-fA-F\d]{8}|u[a-fA-F\d]{4}|x[a-fA-F\d]{1,2})/
}, gZ = Km.inside = re.sh = re.shell = re.bash = {
  shebang: {
    pattern: /^#!\s*\/.*/,
    alias: "important"
  },
  comment: {
    pattern: /(^|[^"{\\$])#.*/,
    lookbehind: !0
  },
  "function-name": [
    // a) function foo {
    // b) foo() {
    // c) function foo() {
    // but not “foo {”
    {
      // a) and c)
      pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
      lookbehind: !0,
      alias: "function"
    },
    {
      // b)
      pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
      alias: "function"
    }
  ],
  // Highlight variable names as variables in for and select beginnings.
  "for-or-select": {
    pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
    lookbehind: !0,
    alias: "variable"
  },
  // Highlight variable names as variables in the left-hand part
  // of assignments (“=” and “+=”).
  "assign-left": {
    pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
    lookbehind: !0,
    alias: "variable",
    inside: {
      environment: {
        pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + dd),
        lookbehind: !0,
        alias: "constant"
      }
    }
  },
  // Highlight parameter names as variables
  parameter: {
    pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?![^\s=])/,
    lookbehind: !0,
    alias: "variable"
  },
  string: [
    // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
    {
      pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[^]*?\n\2/g,
      lookbehind: !0,
      greedy: !0,
      inside: Yc
    },
    // Here-document with quotes around the tag
    // → No expansion (so no “inside”).
    {
      pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[^]*?\n\3/g,
      lookbehind: !0,
      greedy: !0,
      inside: {
        bash: Km
      }
    },
    // “Normal” string
    {
      // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
      pattern: /(^|[^\\](?:\\\\)*)"(?:\\[^]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^\\"`$])*"/g,
      lookbehind: !0,
      greedy: !0,
      inside: Yc
    },
    {
      // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
      pattern: /(^|[^$\\])'[^']*'/g,
      lookbehind: !0,
      greedy: !0
    },
    {
      // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
      pattern: /\$'(?:\\[^]|[^\\'])*'/g,
      greedy: !0,
      inside: {
        entity: Yc.entity
      }
    }
  ],
  environment: {
    pattern: RegExp("\\$?" + dd),
    alias: "constant"
  },
  variable: Yc.variable,
  function: {
    pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|c?fdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cron|crontab|c?split|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff3?|dig|dircolors|dirname|dirs?|dmesg|docker|docker-compose|du|[ef]?grep|eject|env|ethtool|expand|expect|expr|fdformat|fg|file|find|fmt|fold|format|free|fsck|fuser|g?awk|git|g?parted|groupadd|groupdel|groupmod|groups|grub-mkconfig|halt|head|hg|history|host|hostname|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|killall|less|link|ln|logname|logrotate|look|lpc|lprint[dq]?|lprm?|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mm?v|more|most|mtools|m?tr|mutt|nano|nc|netstat|nice|nl|node|nohup|notify-send|nslookup|op|open|passwd|paste|pathchk|ping|p?kill|p?npm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ra[mr]|reboot|remsync|rename|renice|rev|rmdir|rp?m|r?sync|[sr]?cp|screen|sdiff|se[dq]|sendmail|service|s?ftp|shellcheck|shuf|shutdown|sleep|s?locate|[sz]?sh|stat|strace|sudo|sum?|suspend|swapon|sysctl|tac|tail|tar|tee|time|timeout|h?top|touch|traceroute|t?sort|tty|u?mount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vim?|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|g?zip|zsh|zypper)(?=$|[)\s;|&])/,
    lookbehind: !0
  },
  keyword: {
    pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
    lookbehind: !0
  },
  // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
  builtin: {
    pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|[ls]et|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
    lookbehind: !0,
    // Alias added to make those easier to distinguish from strings.
    alias: "class-name"
  },
  boolean: {
    pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
    lookbehind: !0
  },
  "file-descriptor": {
    pattern: /\B&\d\b/,
    alias: "important"
  },
  operator: {
    // Lots of redirections here, but not just that.
    pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
    inside: {
      "file-descriptor": {
        pattern: /^\d/,
        alias: "important"
      }
    }
  },
  punctuation: /\$?\(\(?|\)\)?|\.\.|[[\]{};\\]/,
  number: {
    pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
    lookbehind: !0
  }
};
[
  "comment",
  "function-name",
  "for-or-select",
  "assign-left",
  "parameter",
  "string",
  "environment",
  "function",
  "keyword",
  "builtin",
  "boolean",
  "file-descriptor",
  "operator",
  "punctuation",
  "number"
].forEach((t) => J3[t] = gZ[t]);
var X3 = /(?:"(?:\\[^]|[^\\\n"])*"|'(?:\\[^]|[^\\\n'])*')/g, Jc = X3.source, Rw = {
  rule: /^@[\w-]+/,
  "selector-function-argument": {
    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^)]*\))*\))+(?=\s*\))/,
    lookbehind: !0,
    alias: "selector"
  },
  keyword: {
    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
    lookbehind: !0
  }
  // See rest below
};
Rw[jn] = re.css = {
  comment: /\/\*[^]*?\*\//,
  atrule: {
    pattern: RegExp(`@[\\w-](?:[^;{\\s"']|\\s+(?!\\s)|${Jc})*?(?:;|(?=\\s*\\{))`),
    inside: Rw
  },
  url: {
    // https://drafts.csswg.org/css-values-3/#urls
    pattern: RegExp(`\\burl\\((?:${Jc}|(?:[^\\\\
"')=]|\\\\[^])*)\\)`, "gi"),
    greedy: !0,
    inside: {
      function: /^url/i,
      punctuation: /^\(|\)$/,
      string: {
        pattern: RegExp("^" + Jc + "$"),
        alias: "url"
      }
    }
  },
  selector: {
    pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|${Jc})*(?=\\s*\\{)`),
    lookbehind: !0
  },
  string: {
    pattern: X3,
    greedy: !0
  },
  property: {
    pattern: /(^|[^-\w\xa0-\uffff])(?!\d)(?:(?!\s)[-\w\xa0-\uffff])+(?=\s*:)/i,
    lookbehind: !0
  },
  important: /!important\b/i,
  function: {
    pattern: /(^|[^-a-z\d])[-a-z\d]+(?=\()/i,
    lookbehind: !0
  },
  punctuation: /[(){},:;]/
};
var Cu = (t, e) => {
  if (e.has(t))
    return e.get(t);
  var n = t, o = vZ.call(t).slice(8, -1);
  if (o == "Object") {
    e.set(t, n = {});
    for (var r in t)
      n[r] = Cu(t[r], e);
    t[jn] && (n[jn] = Cu(t[jn], e)), t[vi] && (n[vi] = t[vi]);
  } else if (o == "Array") {
    e.set(t, n = []);
    for (var i = 0, s = t.length; i < s; i++)
      n[i] = Cu(t[i], e);
  }
  return n;
}, wv = (t) => Cu(t, /* @__PURE__ */ new Map()), Kr = (t, e) => Object.assign(wv(re[t]), e), lt = (t, e, n) => {
  var o = {};
  for (var r in t)
    o[r] = t[r], delete t[r];
  for (var r in o)
    r == e && Object.assign(t, n), n.hasOwnProperty(r) || (t[r] = o[r]);
}, vZ = {}.toString, fd = re.css, $w = {
  pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
  lookbehind: !0
}, Pw = {
  pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
  lookbehind: !0
};
fd.selector.inside = fd.atrule.inside["selector-function-argument"].inside = {
  "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
  "pseudo-class": /:[-\w]+/,
  class: /\.[-\w]+/,
  id: /#[-\w]+/,
  attribute: {
    pattern: /\[(?:[^[\]"']|(["'])(?:\\[^]|(?!\1)[^\\\n])*\1)*\]/g,
    greedy: !0,
    inside: {
      punctuation: /^\[|\]$/,
      "case-sensitivity": {
        pattern: /(\s)[si]$/i,
        lookbehind: !0,
        alias: "keyword"
      },
      namespace: {
        pattern: /^(\s*)(?:(?!\s)[-*\w\xa0-\uffff])*\|(?!=)/,
        lookbehind: !0,
        inside: {
          punctuation: /\|$/
        }
      },
      "attr-name": {
        pattern: /^(\s*)(?:(?!\s)[-\w\xa0-\uffff])+/,
        lookbehind: !0
      },
      "attr-value": {
        pattern: /(=\s*)(?:(?!\s)[-\w\xa0-\uffff])+(?=\s*$)|(["'])(?:\\[^]|(?!\2)[^\\\n])*\2/,
        lookbehind: !0
      },
      operator: /[|~*^$]?=/
    }
  },
  "n-th": [
    {
      pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
      lookbehind: !0,
      inside: {
        number: /[\dn]+/,
        operator: /[+-]/
      }
    },
    {
      pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
      lookbehind: !0
    }
  ],
  combinator: />|\+|~|\|\|/,
  // the `tag` token has been existed and removed.
  // because we can't find a perfect tokenize to match it.
  // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
  punctuation: /[(),]/
};
lt(fd, "property", {
  variable: {
    pattern: /(^|[^-\w\xa0-\uffff])--(?!\d)(?:(?!\s)[-\w\xa0-\uffff])*/i,
    lookbehind: !0
  }
});
lt(fd, "function", {
  operator: {
    pattern: /(\s)[/*+-](?!\S)/,
    lookbehind: !0
  },
  // CAREFUL!
  // Previewers and Inline color use hexcode and color.
  hexcode: {
    pattern: /\B#[a-f\d]{3,8}\b/i,
    alias: "color"
  },
  color: [
    {
      pattern: /(^|[^\w-])(?:(?:alice|cadet|cornflower|deepsky|dodger|midnight|powder|royal|sky|steel)blue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blueviolet|brown|burlywood|chartreuse|chocolate|coral|cornsilk|crimson|(?:dark)?(?:blue|cyan|goldenrod|gr[ae]y|green|khaki|magenta|olivegreen|orange|orchid|red|salmon|seagreen|slateblue|slategr[ae]y|turquoise|violet)|deeppink|dimgr[ae]y|firebrick|floralwhite|(?:forest|lawn|lime|pale|spring)green|fuchsia|gainsboro|ghostwhite|gold|greenyellow|honeydew|hotpink|indianred|indigo|ivory|lavender|lavenderblush|lemonchiffon|light(?:blue|coral|cyan|goldenrodyellow|gr[ae]y|green|pink|salmon|seagreen|skyblue|slategr[ae]y|steelblue|yellow)|lime|linen|maroon|medium(?:aquamarine|blue|orchid|purple|seagreen|slateblue|springgreen|turquoise|violetred)|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orangered|palegoldenrod|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|purple|rebeccapurple|rosybrown|saddlebrown|sandybrown|seashell|sienna|silver|snow|tan|teal|thistle|tomato|transparent|wheat|white|whitesmoke|yellow|yellowgreen)(?![\w-])/i,
      lookbehind: !0
    },
    {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        function: /^[^(]+/,
        unit: $w,
        number: Pw,
        punctuation: /[(),]/
      }
    }
  ],
  // it's important that there is no boundary assertion after the hex digits
  entity: /\\[a-f\d]{1,8}/i,
  unit: $w,
  number: Pw
});
re.ini = {
  /**
   * The component mimics the behavior of the Win32 API parser.
   *
   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
   */
  comment: {
    pattern: /(^[ \f	\v]*)[#;].*/m,
    lookbehind: !0
  },
  section: {
    pattern: /(^[ \f	\v]*)\[[^\n\]]*\]?/m,
    lookbehind: !0,
    inside: {
      "section-name": {
        pattern: /(^\[[ \f	\v]*)[^ \f	\v\]]+(?:[ \f	\v]+[^ \f	\v\]]+)*/,
        lookbehind: !0,
        alias: "selector"
      },
      punctuation: /[[\]]/
    }
  },
  key: {
    pattern: /(^[ \f	\v]*)[^ \f\n	\v=]+(?:[ \f	\v]+[^ \f\n	\v=]+)*(?=[ \f	\v]*=)/m,
    lookbehind: !0,
    alias: "attr-name"
  },
  value: {
    pattern: /(=[ \f	\v]*)[^ \f\n	\v]+(?:[ \f	\v]+[^ \f\n	\v]+)*/,
    lookbehind: !0,
    alias: "attr-value",
    inside: {
      "inner-value": {
        pattern: /^(["']).+(?=\1$)/,
        lookbehind: !0
      }
    }
  },
  punctuation: /=/
};
var Gr = () => ({
  pattern: /\/\/.*|\/\*[^]*?(?:\*\/|$)/g,
  greedy: !0
}), xv = () => ({
  pattern: /(["'])(?:\\[^]|(?!\1)[^\\\n])*\1/g,
  greedy: !0
}), Z3 = /\b0x[a-f\d]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, ra = /[()[\]{}.,:;]/, gn = /\b(?:false|true)\b/, ch = {
  "interpolation-punctuation": {
    pattern: /^\$\{?|\}$/,
    alias: "punctuation"
  },
  expression: {
    pattern: /[^]+/
  }
};
ch.expression.inside = re.kts = re.kt = re.kotlin = {
  // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
  "string-literal": [
    {
      pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
      alias: "multiline",
      inside: {
        interpolation: {
          pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          inside: ch
        },
        string: /[^]+/
      }
    },
    {
      pattern: /"(?:\\.|[^\\\n"$]|\$(?:(?!\{)|\{[^{}]*\}))*"/,
      alias: "singleline",
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\\\)*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          lookbehind: !0,
          inside: ch
        },
        string: /[^]+/
      }
    }
  ],
  char: {
    // https://kotlinlang.org/spec/expressions.html#character-literals
    pattern: /'(?:[^\\\n']|\\(?:.|u[a-fA-F\d]{0,4}))'/g,
    greedy: !0
  },
  comment: Gr(),
  annotation: {
    pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
    alias: "builtin"
  },
  keyword: {
    // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
    pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
    lookbehind: !0
  },
  boolean: gn,
  label: {
    pattern: /\b\w+@|@\w+/,
    alias: "symbol"
  },
  function: {
    pattern: /(?:`[^\n`]+`|\b\w+)(?=\s*\()|(\.)(?:`[^\n`]+`|\w+)(?=\s*\{)/g,
    lookbehind: !0,
    greedy: !0
  },
  number: /\b(?:0[xX][a-fA-F\d]+(?:_[a-fA-F\d]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
  operator: /--|\+\+|&&|\|\||->|[!=]==|!!|[%!=<>/*+-]=?|[?:]:?|\.\.|\b(?:and|inv|shl|u?shr|x?or)\b/,
  punctuation: ra
};
var Q3 = [
  {
    pattern: /&[a-z\d]{1,8};/i,
    alias: "named-entity"
  },
  /&#x?[a-f\d]{1,8};/i
], yZ = {
  pattern: /<\/?(?!\d)[^\s/=>$<%]+(?:\s(?:\s*[^\s/=>]+(?:\s*=\s*(?!\s)(?:"[^"]*"|'[^']*'|[^\s"'=>]+(?=[\s>]))?|(?=[\s/>])))+)?\s*\/?>/g,
  greedy: !0,
  inside: {
    punctuation: /^<\/?|\/?>$/,
    tag: {
      pattern: /^\S+/,
      inside: {
        namespace: /^[^:]+:/
      }
    },
    "attr-value": [{
      pattern: /(=\s*)(?:"[^"]*"|'[^']*'|[^\s"'=>]+)/g,
      lookbehind: !0,
      greedy: !0,
      inside: {
        punctuation: /^["']|["']$/,
        entity: Q3
      }
    }],
    "attr-equals": /=/,
    "attr-name": {
      pattern: /\S+/,
      inside: {
        namespace: /^[^:]+:/
      }
    }
  }
};
re.rss = re.atom = re.ssml = re.xml = {
  comment: {
    pattern: /<!--(?:(?!<!--)[^])*?-->/g,
    greedy: !0
  },
  prolog: {
    pattern: /<\?[^]+?\?>/g,
    greedy: !0
  },
  doctype: {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/gi,
    greedy: !0,
    inside: {
      "internal-subset": {
        pattern: /(\[)[^]+(?=\]\s*>$)/,
        lookbehind: !0,
        inside: "xml"
      },
      string: /"[^"]*"|'[^']*'/,
      punctuation: /^<!|[>[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /\S+/
    }
  },
  cdata: {
    pattern: /<!\[CDATA\[[^]*?\]\]>/gi,
    greedy: !0
  },
  tag: yZ,
  entity: Q3,
  "markup-bracket": {
    pattern: /[()[\]{}]/,
    alias: "punctuation"
  }
};
var Gm = (t, e) => (t["language-" + e] = {
  pattern: /[^]+/,
  inside: e
}, t), Lw = (t, e) => ({
  pattern: RegExp(`(<${t}[^>]*>)(?!</${t}>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[^])+?(?=</${t}>)`, "gi"),
  lookbehind: !0,
  greedy: !0,
  inside: Gm({
    "included-cdata": {
      pattern: /<!\[CDATA\[[^]*?\]\]>/i,
      inside: Gm({
        cdata: /^<!\[CDATA\[|\]\]>$/i
      }, e)
    }
  }, e)
}), Dw = (t, e) => ({
  pattern: RegExp(`((?:^|["'\\s])(?:${t})\\s*=\\s*)(?:"[^"]*"|'[^']*'|[^\\s"'=>]+)`, "gi"),
  lookbehind: !0,
  greedy: !0,
  inside: Gm({
    punctuation: /^["']|["']$/
  }, e)
}), eE = re.svg = re.mathml = re.html = re.markup = wv(re.xml);
eE.tag.inside["attr-value"].unshift(
  Dw("style", "css"),
  Dw("on[a-z]+", "javascript")
);
lt(eE, "cdata", {
  style: Lw("style", "css"),
  script: Lw("script", "javascript")
});
re.r = {
  comment: /#.*/,
  string: {
    pattern: /(["'])(?:\\.|(?!\1)[^\\\n])*\1/g,
    greedy: !0
  },
  "percent-operator": {
    // Includes user-defined operators
    // and %%, %*%, %/%, %in%, %o%, %x%
    pattern: /%[^%\s]*%/,
    alias: "operator"
  },
  boolean: /\b(?:FALSE|TRUE)\b/,
  ellipsis: /\.\.(?:\.|\d+)/,
  number: [
    /\b(?:Inf|NaN)\b/,
    /(?:\b0x[a-fA-F\d]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
  ],
  keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
  operator: /->>?|<=|<<?-|[!=<>]=?|::?|&&?|\|\|?|[~^$@/*+-]/,
  punctuation: /[()[\]{},;]/
};
re.basic = {
  comment: {
    pattern: /(?:!|rem\b).+/i,
    inside: {
      keyword: /^rem/i
    }
  },
  string: {
    pattern: /"(?:""|[#$%&'().,:;\w ?^!=<>/*+-])*"/g,
    greedy: !0
  },
  number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  keyword: /\b(?:as|beep|bload|bsave|call absolute|call|case|chain|chdir|clear|close|cls|com|common|const|data|declare|def(?: fn| seg|dbl|int|[ls]ng|str)|dim|do|double|else|elseif|environ|erase|error|exit|field|files|for|function|get|gosub|goto|if|input|integer|ioctl|key|kill|line input|locate|lock|long|loop|[lr]set|mkdir|name|next|off|on(?: com| error| key| timer)?|open|option base|[op]ut|poke|read|redim|rem|restore|resume|return|rmdir|run|select case|shared|shell|single|sleep|static|step|stop|string|sub|swap|system|then|timer|to|troff|tron|type|unlock|until|using|view print|wait|w?end|while|write)(?:\$|\b)/i,
  function: /\b(?:abs|access|a?cos|angle|area|arithmetic|array|a?sin|ask|atn?|base|begin|break|cause|ceil|chr|clip|collate|color|co[nst]|cosh|csc|date|datum|debug|decimal|de[fgt]|degrees|delete|device|display|dot|elapsed|eps|erasable|exline|exp|external|extype|filetype|fixed|fp|go|graph|handler|idn|image|int?|internal|ip|is|keyed|[lu]bound|[lu]case|left|le[nt]|length|lines?|log2?|log10|[lr]trim|margin|ma[tx]|maxnum|mi[dn]|missing|mod|native|nul|numeric|of|option|ord|organization|outin|output|pi|pointer|points?|pos|print|program|prompt|rad|radians|randomize|record|recsize|rectype|relative|remainder|repeat|rest|retry|rewrite|right|rnd|round|same|se[ct]|select|sequential|setter|sgn|sinh|size|skip|s[qt]r|standard|status|stream|style|tab|tanh?|template|text|there|time|timeout|trace|transform|truncate|use|val|variable|viewport|when|window|with|zer|zonewidth)(?:\$|\b)/i,
  operator: /<=|<>|>=|[&^=<>/*+-]|\b(?:and|eqv|imp|not|x?or)\b/i,
  punctuation: /[(),:;]/
};
re.vbnet = Kr("basic", {
  comment: {
    pattern: /(?:!|'|rem\b).*/i,
    inside: {
      keyword: /^rem/i
    }
  },
  string: {
    pattern: /(^|[^"])"(?:""|[^"])*"(?!")/g,
    lookbehind: !0,
    greedy: !0
  },
  keyword: /(?:\b(?:addhandler|addressof|alias|and|andalso|as|beep|bload|boolean|bsave|byref|byval|call absolute|call|case|catch|cbool|c?byte|cc?har|c?date|cdbl|cdec|chain|chdir|cu?int|class|clear|close|cls|cobj|com|common|const|continue|c?sbyte|c?u?short|c?sng|cstr|c?type|cu?lng|data|decimal|declare|def(?: fn| seg|dbl|int|lng|sng|str)|default|delegate|dim|directcast|do|double|else|elseif|enum|environ|erase|error|event|exit|false|true|field|files|finally|for each|for|friend|function|[gls]et|gettype|getxmlnamespace|global|gosub|goto|handles|i[fns]|implements|imports|inherits|input|interface|ioctl|isnot|key|kill|lib|like|line input|locate|lock|loop|[lr]set|me|mkdir|mod|module|mustinherit|mustoverride|mybase|myclass|name|namespace|narrowing|new|next|not|nothing|notinheritable|notoverridable|object|off?|on (?:com|error|key|timer)|on|open|operator|option base|option|optional|orelse|out|overloads|overridable|overrides|paramarray|partial|poke|private|property|protected|public|put|raiseevent|read|readonly|redim|removehandler|restore|resume|return|rmdir|run|select case|select|shadows|shared|shell|single|sleep|static|step|stop|string|structure|sub|swap|synclock|system|[tw]hen|throw|timer|to|troff|tron|try|trycast|typeof|u?integer|u?long|unlock|until|using|view print|wait|w?end|while|widening|with|withevents|write|writeonly|x?or)|\B#(?:const|else|elseif|end|if))(?:\$|\b)/i,
  punctuation: /[(){},:;]/
});
var Nw = {
  // https://en.cppreference.com/w/c/language/character_constant
  pattern: /'(?:\\[^]|[^\\\n']){0,32}'/g,
  greedy: !0
}, Bw = {
  pattern: /\/\/(?:[^\\\n]|\\\n?)*|\/\*[^]*?(?:\*\/|$)/g,
  greedy: !0
}, Fw = {
  // https://en.cppreference.com/w/c/language/string_literal
  pattern: /"(?:\\[^]|[^\\\n"])*"/g,
  greedy: !0
}, zw = {
  pattern: /\S[^]*/
};
zw.inside = re.c = {
  comment: Bw,
  char: Nw,
  macro: {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[ 	]*)#\s*[a-z](?:[^\\\n/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\[^])*/img,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
    inside: {
      string: [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: !0
        },
        Fw
      ],
      char: Nw,
      comment: Bw,
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: !0
        },
        {
          pattern: /(^#\s*define\s+)\w+/i,
          lookbehind: !0,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      directive: {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: !0,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=\n)/,
      expression: zw
    }
  },
  string: Fw,
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([^]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: !0
  },
  keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  // highlight predefined macros as constants
  constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /(?:\b0x(?:[a-f\d]+(?:\.[a-f\d]*)?|\.[a-f\d]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: /->|([&|:+-])\1|[?:~]|>>=?|<<=?|[%&|^!=<>/*+-]=?/,
  punctuation: ra
};
lt(
  re.opencl = Kr("c", {
    // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
    keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
    // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
    // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
    // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
    number: /(?:\b0x(?:[a-f\d]+(?:\.[a-f\d]*)?|\.[a-f\d]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
    boolean: gn,
    "constant-opencl-kernel": {
      pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN2|LN10|LOG2E?|LOG10E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
      alias: "constant"
    }
  }),
  "class-name",
  {
    // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
    // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
    "builtin-type": {
      pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|u?intptr_t)\b/,
      alias: "keyword"
    }
  }
);
var qm = {
  // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
  "type-opencl-host": {
    pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:[2348]|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
    alias: "keyword"
  },
  "boolean-opencl-host": {
    pattern: /\bCL_(?:FALSE|TRUE)\b/,
    alias: "boolean"
  },
  // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
  "constant-opencl-host": {
    pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|RA?|READ_(?:ONLY|WRITE)_CACHE|RG|RGB[Ax]?|RG?x|RUNNING|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_5[56]5|VERSION_(?:1_[012]|2_[01])|s?BGRA|sRGB[Ax]?)\b/,
    alias: "constant"
  },
  // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
  "function-opencl-host": {
    pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image[23]D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
    alias: "function"
  }
};
lt(re.c, "keyword", qm);
re.cpp && (qm["type-opencl-host-cpp"] = {
  pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image(?:[123]D|[12]DArray|1DBuffer|[23]DGL|Format|GL)?|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTrait(?:Atomic|Coarse|Fine|ReadOnly|ReadWrite|WriteOnly)|Sampler|UserEvent)\b/,
  alias: "keyword"
}, lt(re.cpp, "keyword", qm));
var bZ = re.diff = {
  // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
  // Match "@@ ... @@" coord lines in unified diff.
  // Match coord lines in normal diff (starts with a number).
  coord: /^(?:\*{3}|-{3}|\+{3}|\d).*$|^@@.*@@$/m
  // deleted, inserted, unchanged, diff
}, uh = {
  "deleted-sign": "-",
  "deleted-arrow": "<",
  "inserted-sign": "+",
  "inserted-arrow": ">",
  unchanged: " ",
  diff: "!"
};
for (var Yi in uh) {
  var dh = Yi.split("-")[0];
  bZ[Yi] = {
    pattern: RegExp("^(?:[" + uh[Yi] + `].*$
?)+`, "m"),
    alias: dh != Yi ? dh : Yi == "diff" ? "bold" : void 0,
    inside: {
      prefix: {
        pattern: RegExp("^[" + uh[Yi] + "]", "mg"),
        greedy: !0,
        alias: dh
      }
    }
  };
}
var fh = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|opens?|package|permits|private|protected|provides|public|record(?!\s*[()[\]{}%~.,:;?%&|^=<>/*+-])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throws?|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, Ra = "(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*", Ym = {
  pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
  inside: {
    punctuation: /\./
  }
}, Jm = {
  namespace: Ym,
  punctuation: /\./
}, Hw = {
  pattern: RegExp(`(^|[^\\w.])${Ra}[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b`),
  lookbehind: !0,
  inside: Jm
};
re.java = {
  "doc-comment": {
    pattern: /\/\*\*(?!\/)[^]*?(?:\*\/|$)/g,
    greedy: !0,
    alias: "comment",
    inside: "javadoc"
  },
  comment: Gr(),
  "triple-quoted-string": {
    // http://openjdk.java.net/jeps/355#Description
    pattern: /"""[ 	]*\n(?:\\.|[^\\])*?"""/g,
    greedy: !0,
    alias: "string"
  },
  char: {
    pattern: /'(?:\\.|[^\\\n']){1,6}'/g,
    greedy: !0
  },
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^\\\n"])*"/g,
    lookbehind: !0,
    greedy: !0
  },
  annotation: {
    pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
    lookbehind: !0,
    alias: "punctuation"
  },
  generics: {
    pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
    inside: {
      "class-name": Hw,
      keyword: fh,
      punctuation: /[().,:<>]/,
      operator: /[?&|]/
    }
  },
  import: [
    {
      pattern: RegExp(`(\\bimport\\s+)${Ra}(?:[A-Z]\\w*|\\*)(?=\\s*;)`),
      lookbehind: !0,
      inside: {
        namespace: Ym,
        punctuation: /\./,
        operator: /\*/,
        "class-name": /\w+/
      }
    },
    {
      pattern: RegExp(`(\\bimport\\s+static\\s+)${Ra}(?:\\w+|\\*)(?=\\s*;)`),
      lookbehind: !0,
      alias: "static",
      inside: {
        namespace: Ym,
        static: /\b\w+$/,
        punctuation: /\./,
        operator: /\*/,
        "class-name": /\w+/
      }
    }
  ],
  namespace: {
    pattern: RegExp(
      `(\\b(?:exports|import(?:\\s+static)?|module|opens?|package|provides|requires|to|transitive|uses|with)\\s+)(?!${fh.source})[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?`
    ),
    lookbehind: !0,
    inside: {
      punctuation: /\./
    }
  },
  "class-name": [
    Hw,
    {
      // variables, parameters, and constructor references
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(`(^|[^\\w.])${Ra}[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)`),
      lookbehind: !0,
      inside: Jm
    },
    {
      // class names based on keyword
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(`(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)${Ra}[A-Z]\\w*\\b`),
      lookbehind: !0,
      inside: Jm
    }
  ],
  keyword: fh,
  boolean: gn,
  function: {
    pattern: /\b\w+(?=\()|(::\s*)[a-z_]\w*/,
    lookbehind: !0
  },
  number: /\b0b[01][01_]*l?\b|\b0x(?:\.[a-f\d_p+-]+|[a-f\d_]+(?:\.[a-f\d_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
  constant: /\b[A-Z][A-Z_\d]+\b/,
  operator: {
    pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[%&|^!=<>/*+-]=?)/m,
    lookbehind: !0
  },
  punctuation: ra
};
lt(
  re.less = Kr("css", {
    comment: Gr(),
    atrule: {
      pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
      inside: {
        punctuation: /[():]/
      }
    },
    // selectors and mixins are considered the same
    selector: {
      pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
      inside: {
        // mixin parameters
        variable: /@+[\w-]+/
      }
    },
    property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
    operator: /[/*+-]/
  }),
  "property",
  {
    variable: [
      // Variable declaration (the colon must be consumed!)
      {
        pattern: /@[\w-]+\s*:/,
        inside: {
          punctuation: /:/
        }
      },
      // Variable usage
      /@@?[\w-]+/
    ],
    "mixin-usage": {
      pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
      lookbehind: !0,
      alias: "function"
    }
  }
);
re.objc = re.objectivec = Kr("c", {
  string: {
    pattern: /@?"(?:\\[^]|[^\\\n"])*"/g,
    greedy: !0
  },
  keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int?|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|==?|>>?=?|<<?=?|&&?|\|\|?|[~^@%?/*]/
});
delete re.objc["class-name"];
var tE = {
  pattern: /^(..)[^]+(?=.)/,
  lookbehind: !0
}, ph = "(?:([^a-zA-Z\\d\\s{(\\[<=])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|\\((?:\\\\[\\s\\S]|[^\\\\()]|\\((?:\\\\[\\s\\S]|[^\\\\()])*\\))*\\)|\\{(?:\\\\[\\s\\S]|[^\\\\{}]|\\{(?:\\\\[\\s\\S]|[^\\\\{}])*\\})*\\}|\\[(?:\\\\[\\s\\S]|[^\\\\[\\]]|\\[(?:\\\\[\\s\\S]|[^\\\\[\\]])*\\])*\\]|<(?:\\\\[\\s\\S]|[^\\\\<>]|<(?:\\\\[\\s\\S]|[^\\\\<>])*>)*>)", Vw = `(?:"(?:\\\\.|[^\\\\
"])*"|(?:\\b(?!\\d)\\w+|[^\\s\0-\\x7f]+)[?!]?|\\$.)`, Xr = {
  pattern: /((?:^|[^\\])(?:\\\\)*)#\{(?:[^{}]|\{[^}]*\})*\}/,
  lookbehind: !0,
  inside: {
    content: tE,
    delimiter: {
      pattern: /.+/,
      alias: "punctuation"
    }
  }
};
tE.inside = re.rb = re.ruby = {
  comment: {
    pattern: /#.*|^=begin\s[^]*?^=end/mg,
    greedy: !0
  },
  "string-literal": [
    {
      pattern: RegExp("%[qQiIwWs]?" + ph, "g"),
      greedy: !0,
      inside: {
        interpolation: Xr,
        string: /[^]+/
      }
    },
    {
      pattern: /(["'])(?:#\{[^}]+\}|#(?!\{)|\\[^]|(?!\1)[^\\#\n])*\1/g,
      greedy: !0,
      inside: {
        interpolation: Xr,
        string: /[^]+/
      }
    },
    {
      pattern: /<<[-~]?([a-z_]\w*)\n(?:.*\n)*?[ 	]*\1/gi,
      alias: "heredoc-string",
      greedy: !0,
      inside: {
        delimiter: {
          pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
          inside: {
            symbol: /\w+/,
            punctuation: /^<<[-~]?/
          }
        },
        interpolation: Xr,
        string: /[^]+/
      }
    },
    {
      pattern: /<<[-~]?'([a-z_]\w*)'\n(?:.*\n)*?[ 	]*\1/gi,
      alias: "heredoc-string",
      greedy: !0,
      inside: {
        delimiter: {
          pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
          inside: {
            symbol: /\w+/,
            punctuation: /^<<[-~]?'|'$/
          }
        },
        string: /[^]+/
      }
    }
  ],
  "command-literal": [
    {
      pattern: RegExp("%x" + ph, "g"),
      greedy: !0,
      inside: {
        interpolation: Xr,
        command: {
          pattern: /[^]+/,
          alias: "string"
        }
      }
    },
    {
      pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\[^]|[^\\`#\n])*`/g,
      greedy: !0,
      inside: {
        interpolation: Xr,
        command: {
          pattern: /[^]+/,
          alias: "string"
        }
      }
    }
  ],
  "class-name": {
    pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
    lookbehind: !0,
    inside: {
      punctuation: /[.\\]/
    }
  },
  "regex-literal": [
    {
      pattern: RegExp(`%r${ph}[egimnosux]{0,6}`, "g"),
      greedy: !0,
      inside: {
        interpolation: Xr,
        regex: /[^]+/
      }
    },
    {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\]]+\]|\\.|[^\\\n/[])+\/[egimnosux]{0,6}(?=\s*(?:$|[\n,.;})#]))/g,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: Xr,
        regex: /[^]+/
      }
    }
  ],
  variable: /[@$]+(?!\d)\w+(?:[?!]|\b)/,
  symbol: [
    {
      pattern: RegExp("(^|[^:]):" + Vw, "g"),
      lookbehind: !0,
      greedy: !0
    },
    {
      pattern: RegExp(`([
{(,][ 	]*)` + Vw + "(?=:(?!:))", "g"),
      lookbehind: !0,
      greedy: !0
    }
  ],
  "method-definition": {
    pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
    lookbehind: !0,
    inside: {
      function: /\b\w+$/,
      keyword: /^self\b/,
      "class-name": /^\w+/,
      punctuation: /\./
    }
  },
  keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|f?or|if|in|include|module|new|next|nil|not|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|[tw]hen|throw|undef|unless|until|while|yield)\b/,
  boolean: gn,
  builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
  constant: /\b[A-Z][A-Z\d_]*(?:[?!]|\b)/,
  number: Z3,
  "double-colon": {
    pattern: /::/,
    alias: "punctuation"
  },
  operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[%&|^!=<>/*+-])=?|[?:]/,
  punctuation: /[()[\]{}.,;]/
};
re.sql = {
  comment: /\/\*[^]*?\*\/|(?:--|\/\/|#).*/,
  variable: [
    {
      pattern: /@(["'`])(?:\\[^]|(?!\1)[^\\])+\1/g,
      greedy: !0
    },
    /@[\w.$]+/
  ],
  string: {
    pattern: /(^|[^@\\])(["'])(?:\\[^]|(?!\2)[^\\]|\2\2)*\2/g,
    lookbehind: !0,
    greedy: !0
  },
  identifier: {
    pattern: /(^|[^@\\])`(?:\\[^]|[^\\`]|``)*`/g,
    lookbehind: !0,
    greedy: !0,
    inside: {
      punctuation: /^`|`$/
    }
  },
  function: /\b(?:avg|count|first|format|last|[lu]case|len|max|mi[dn]|mod|now|round|sum)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  keyword: /\b(?:action|add|after|algorithm|alter|analyze|any|apply|asc?|authorization|auto_increment|backup|bdb|begin|berkeleydb|bigint|binary|bit|blob|bool|boolean|break|browse|[br]tree|bulk|by|c?all|cascaded?|case|chain|character|charset|check(?:point)?|close|clustered|coalesce|collate|columns?|comment|commit(?:ted)?|compute|connect|consistent|constraint|contains(?:table)?|continue|convert|create|cross|current(?:_date|_time|_timestamp|_user)?|cursor|cycle|data(?:bases?)?|date(?:time)?|day|dbcc|deallocate|dec|decimal|declare|default|definer|delayed|delete|delimiters?|deny|desc|describe|deterministic|disable|discard|disk|distinct|distinctrow|distributed|do|double|drop|dummy|dump(?:file)?|duplicate|else(?:if)?|enable|enclosed|end|engine|enum|errlvl|errors|escaped?|except|exec(?:ute)?|exists|exit|explain|extended|fetch|fields|file|fillfactor|first|fixed|float|following|for each row|for|force|foreign|freetexttable|freetext|from|full|function|geometry(?:collection)?|global|goto|grant|group|handler|hash|having|holdlock|hour|identity(?:col|_insert)?|if|ignore|import|index|infile|inner|innodb|inout|insert|integer|intersect|interval|into?|invoker|isolation|iterate|join|keys?|kill|language|last|leave|left|level|limit|lineno|lines|linestring|load|local|lock|long(?:blob|text)|loop|matched|match|(?:medium|tiny)(?:blob|int|text)|merge|middleint|minute|mode|modifies|modify|month|multi(?:linestring|point|polygon)|national|natural|n?char|next|no|nonclustered|nullif|numeric|off?|offsets?|on|open(?:datasource|query|rowset)?|optimize|option(?:ally)?|order|out(?:er|file)?|over|partial|partition|percent|pivot|plan|point|polygon|preceding|precision|prepare|prev|primary|print|privileges|proc(?:edure)?|public|purge|quick|raiserror|reads?|real|reconfigure|references|release|rename|repeat(?:able)?|replace|replication|require|resignal|restore|restrict|returning|returns?|revoke|right|rollback|routine|row(?:count|guidcol|s)?|rule|savepoint|save|schema|second|select|serializable|serial|session_user|session|setuser|set|share|show|shutdown|simple|smallint|snapshot|some|soname|sql|start(?:ing)?|statistics|status|striped|system_user|tables?|tablespace|temp(?:orary|table)?|terminated|textsize|text|[tw]hen|timestamp|time|top?|transactions?|tran|trigger|truncate|tsequal|types?|unbounded|uncommitted|undefined|union|unique|unlock|unpivot|unsigned|updatetext|update|usage|user?|using|values?|var(?:binary|char|character|ying)|view|waitfor|warnings|where|while|with(?: rollup|in)?|work|writetext|write|year)\b/i,
  boolean: /\b(?:false|true|null)\b/i,
  number: /\b0x[a-f\d]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[=%~^/*+-]|&&?|\|\|?|!=?|<<|<=?>?|>[>=]?|\b(?:and|between|div|[ir]?like|in|is|not|x?or|regexp|sounds like)\b/i,
  punctuation: /[()[\].,;`]/
};
re.wasm = {
  comment: /\(;[^]*?;\)|;;.*/,
  string: {
    pattern: /"(?:\\[^]|[^\\"])*"/g,
    greedy: !0
  },
  keyword: [
    {
      pattern: /\b(?:align|offset)=/,
      inside: {
        operator: /=/
      }
    },
    {
      pattern: /\b(?:(?:[fi]32|[fi]64)(?:\.(?:abs|a[dn]d|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|x?or))?|memory\.(?:grow|size))\b/,
      inside: {
        punctuation: /\./
      }
    },
    /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
  ],
  variable: /\$[\w!#$%&'*./:<=>?@\\^`|~+-]+/,
  number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[a-fA-F\d](?:_?[a-fA-F\d])*(?:\.[a-fA-F\d](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[a-fA-F\d](?:_?[\da-fA-D])*)?\b/,
  punctuation: /[()]/
};
var ia = (t, e) => {
  for (var n = 0; n < e; n++)
    t = t.replace(/<self>/g, `(?:${t})`);
  return t.replace(/<self>/g, "[]");
}, Ft = (t, e) => t.replace(/<(\d+)>/g, (n, o) => `(?:${e[+o]})`), Pe = (t, e, n) => RegExp(Ft(t, e), n), Xm = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, Ds = re.cpp = Kr("c", {
  "class-name": [
    {
      pattern: RegExp(`(\\b(?:class|concept|enum|struct|typename)\\s+)(?!${Xm.source})\\w+`),
      lookbehind: !0
    },
    // This is intended to capture the class name of method implementations like:
    //   void foo::bar() const {}
    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
    // it starts with an uppercase letter. This approximation should give decent results.
    /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
    // This will capture the class name before destructors like:
    //   Foo::~Foo() {}
    /\b[a-z_]\w*(?=\s*::\s*~\w+\s*\()/i,
    // This also intends to capture the class name of method implementations but here the class has template
    // parameters, so it can't be a namespace (until C++ adds generic namespaces).
    /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
  ],
  keyword: Xm,
  number: {
    pattern: /(?:\b0b[01']+|\b0x(?:[a-f\d']+(?:\.[a-f\d']*)?|\.[a-f\d']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/gi,
    greedy: !0
  },
  operator: /->|--|\+\+|&&|\|\||[?:~]|<=>|>>=?|<<=?|[%&|^!=<>/*+-]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|x?or|x?or_eq)\b/,
  boolean: gn
});
lt(Ds, "string", {
  module: {
    // https://en.cppreference.com/w/cpp/language/modules
    pattern: Pe(
      `(\\b(?:import|module)\\s+)(?:"(?:\\\\[\\s\\S]|[^\\\\
"])*"|<[^<>
]*>|<0>(?:\\s*:\\s*<0>)?|:\\s*<0>)`,
      [`\\b(?!${Xm.source})\\w+(?:\\s*\\.\\s*\\w+)*\\b`],
      "g"
    ),
    lookbehind: !0,
    greedy: !0,
    inside: {
      string: /^[<"][^]+/,
      operator: /:/,
      punctuation: /\./
    }
  },
  "raw-string": {
    pattern: /R"([^()\\ ]{0,16})\([^]*?\)\1"/g,
    greedy: !0,
    alias: "string"
  }
});
lt(Ds, "keyword", {
  "generic-function": {
    pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
    inside: {
      function: /^\w+/,
      generic: {
        pattern: /<[^]+/,
        alias: "class-name",
        inside: Ds
      }
    }
  }
});
lt(Ds, "operator", {
  "double-colon": {
    pattern: /::/,
    alias: "punctuation"
  }
});
var nE = Object.assign({}, Ds);
lt(Ds, "class-name", {
  // the base clause is an optional list of parent classes
  // https://en.cppreference.com/w/cpp/language/class
  "base-clause": {
    pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/g,
    lookbehind: !0,
    greedy: !0,
    inside: nE
  }
});
lt(nE, "double-colon", {
  // All untokenized words that are not namespaces should be class names
  "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
});
re.go = {
  comment: Gr(),
  char: {
    pattern: /'(?:\\.|[^\\\n']){0,10}'/g,
    greedy: !0
  },
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^\\\n"])*"|`[^`]*`/g,
    lookbehind: !0,
    greedy: !0
  },
  keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  boolean: /\b(?:_|false|true|iota|nil)\b/,
  function: /\b\w+(?=\()/,
  number: [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  operator: /--|\+\+|&&|\|\||&\^=?|<-|<<=?|>>=?|[%&|^!=<>/*+-]=?|:=|\.{3}/,
  punctuation: ra,
  builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
};
var hh = {};
re.js = re.javascript = Object.assign(hh, {
  "doc-comment": {
    pattern: /\/\*\*(?!\/)[^]*?(?:\*\/|$)/g,
    greedy: !0,
    alias: "comment",
    inside: "jsdoc"
  },
  comment: Gr(),
  hashbang: {
    pattern: /^#!.*/g,
    greedy: !0,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[^]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}|(?!\$\{)[^\\`])*`/g,
    greedy: !0,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\\\)*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}/,
        lookbehind: !0,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          [jn]: hh
        }
      },
      string: /[^]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ 	]*)(["'])(?:\\[^]|(?!\2)[^\\\n])*\2(?=\s*:)/mg,
    lookbehind: !0,
    greedy: !0,
    alias: "property"
  },
  string: xv(),
  regex: {
    pattern: /((?:^|[^$\w\xa0-\uffff"'`.)\]\s]|\b(?:return|yield))\s*)\/(?:(?:\[(?:\\.|[^\\\n\]])*\]|\\.|[^\\\n/[])+\/[dgimyus]{0,7}|(?:\[(?:\\.|[^\\\n[\]]|\[(?:\\.|[^\\\n[\]]|\[(?:\\.|[^\\\n[\]])*\])*\])*\]|\\.|[^\\\n/[])+\/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?!\/\*|[^()[\]{}.,:;?`\n%&|^!=<>/*+-]))/g,
    lookbehind: !0,
    greedy: !0,
    inside: {
      "regex-flags": /\w+$/,
      "regex-delimiter": /^\/|\/$/,
      "regex-source": {
        pattern: /.+/,
        alias: "language-regex",
        inside: "regex"
      }
    }
  },
  "class-name": [
    {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new)\s+)(?!\d)(?:(?!\s)[$\w.\xa0-\uffff])+/,
      lookbehind: !0,
      inside: {
        punctuation: /\./
      }
    },
    {
      pattern: /(^|[^$\w\xa0-\uffff]|\s)(?![a-z\d])(?:(?!\s)[$\w\xa0-\uffff])+(?=\.(?:constructor|prototype)\b)/,
      lookbehind: !0
    }
  ],
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^)]*\))*\)|(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+)\s*=>))/,
    alias: "function",
    inside: {
      "maybe-class-name": /^[A-Z].*/
    }
  },
  parameter: [
    /(function(?:\s+(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    /(^|[^$\w\xa0-\uffff]|\s)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*=>)/,
    /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|continue|default|do|else|finally|for|if|return|switch|throw|try|while|yield|class|const|debugger|delete|enum|extends|function|[gs]et|export|from|import|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)(?![$\w\xa0-\uffff]))(?:(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/
  ].map((t) => ({
    pattern: t,
    lookbehind: !0,
    inside: hh
  })),
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
  keyword: [
    {
      pattern: /(^|[^.]|\.{3}\s*)\b(?:as|assert(?=\s*\{)|export|from(?!\s*[^\s"'])|import)\b/,
      alias: "module",
      lookbehind: !0
    },
    {
      pattern: /(^|[^.]|\.{3}\s*)\b(?:await|break|case|catch|continue|default|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
      alias: "control-flow",
      lookbehind: !0
    },
    {
      pattern: /(^|[^.]|\.{3}\s*)\b(?:async(?!\s*[^\s($\w\xa0-\uffff])|class|const|debugger|delete|enum|extends|function|[gs]et(?!\s*[^\s#[$\w\xa0-\uffff])|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)\b/,
      lookbehind: !0
    }
  ],
  boolean: gn,
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  function: {
    pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    inside: {
      "maybe-class-name": /^[A-Z].*/
    }
  },
  number: {
    pattern: /(^|[^$\w])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][a-fA-F\d]+(?:_[a-fA-F\d]+)*n?|\d+(?:_\d+)*n|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?)(?![$\w])/,
    lookbehind: !0
  },
  "literal-property": {
    pattern: /([\n,{][ 	]*)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*:)/,
    lookbehind: !0,
    alias: "property"
  },
  operator: [
    {
      pattern: /=>/,
      alias: "arrow"
    },
    /--|\+\+|(?:\*\*|&&|\|\||[!=]=|>>>?|<<|[%&|^!=<>/*+-]|\?\?)=?|\.{3}|\?(?!\.)|~|:/
  ],
  "property-access": {
    pattern: /(\.\s*)#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+/,
    lookbehind: !0,
    inside: {
      "maybe-class-name": /^[A-Z].*/
    }
  },
  "maybe-class-name": {
    pattern: /(^|[^$\w\xa0-\uffff])[A-Z][$\w\xa0-\uffff]+/,
    lookbehind: !0
  },
  punctuation: /\?\.|[()[\]{}.,:;]/
});
var wZ = (t) => (e, n) => {
  for (var o = yv(t), r = "", i = [], s = 0, a = Jf(e, n), l = 0, c = a.length, m = 0; l < c; ) {
    var u = a[l++], d = u.length, f = u.type;
    f && f.slice(0, 6) != "ignore" ? (i[s++] = [m, u], r += " ".repeat(d)) : r += e.slice(m, m + d), m += d;
  }
  var p = 0, m = 0, g = (y) => {
    for (var w = 0; p < s && w < y.length; w++) {
      var x = y[w], b = x.content;
      if (Array.isArray(b))
        g(b);
      else {
        for (var S = x.length, k = [], A, $, O = 0, M = m; ([A, $] = i[p], A >= m && A < m + S) && (M < A && (k[O++] = r.slice(M, A)), M = A + $.length, k[O++] = $, ++p != s); )
          ;
        m += S, O && (M < m && (k[O++] = r.slice(M, m)), b ? x.content = k : (y.splice(w, 1, ...k), w += O - 1));
      }
    }
  }, v = o ? bv(r, o) : [r];
  return g(v), v;
}, oE = re.js, Cv = oE["template-string"], xZ = Cv.pattern.source, CZ = Cv.inside.interpolation.pattern, Ji = (t, e) => ({
  pattern: RegExp("((?:" + e + ")\\s*)" + xZ, "g"),
  lookbehind: !0,
  greedy: !0,
  inside: {
    "template-punctuation": {
      pattern: /^`|`$/,
      alias: "string"
    },
    ["language-" + t]: {
      pattern: /[^]+/,
      inside: {
        interpolation: {
          pattern: CZ,
          lookbehind: !0,
          alias: "language-javascript",
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            [jn]: "js"
          }
        },
        [vi]: wZ(t)
      }
    }
  }
});
oE["template-string"] = [
  // styled-jsx:
  //   css`a { color: #25F; }`
  // styled-components:
  //   styled.h1`color: red;`
  Ji("css", "\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)"),
  // html`<p></p>`
  // div.innerHTML = `<p></p>`
  Ji("html", "\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?="),
  // svg`<path fill="#fff" d="M55.37 ..."/>`
  Ji("svg", "\\bsvg"),
  // md`# h1`, markdown`## h2`
  Ji("markdown", "\\b(?:markdown|md)"),
  // gql`...`, graphql`...`, graphql.experimental`...`
  Ji("graphql", "\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)"),
  // sql`...`
  Ji("sql", "\\bsql"),
  // vanilla template string
  Cv
];
var Su = "\\s|//.*(?!.)|/\\*(?:[^*]|\\*(?!/))*\\*/", Zm = "\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})*\\}", Uw = Ft("\\{<0>*\\.{3}(?:[^{}]|<1>)*\\}", [Su, Zm]), jw = (t) => t && (!t.type || t.type == "plain-text"), SZ = (t, e, n) => {
  for (var o = 0, r = [], i = 0; o < t.length; o++) {
    var s = t[o], a = s.length, l = s.type, c = !l, u, d, f, p, m;
    l && (m = s.content, l == "tag" ? (f = m[0].length, d = m[2] ? e.substr(n + f, m[1].length) : "", f > 1 ? i && r[i - 1][0] == d && i-- : m[m.length - 1].length < 2 && (r[i++] = [d, 0])) : i && l == "punctuation" ? (u = r[i - 1], m == "{" ? u[1]++ : u[1] && m == "}" ? u[1]-- : c = !"}()[]".includes(m)) : c = !0), c && i && !r[i - 1][1] && (f = n, jw(t[o + 1]) && (a += t[o + 1].length, t.splice(o + 1, 1)), jw(t[o - 1]) && (f -= t[--o].length, t.splice(o, 1)), p = e.slice(f, n + a), t[o] = new ls("plain-text", p, p)), n += a;
  }
  return t;
}, rE = (t, e) => {
  lt(re[e] = t = wv(t), "regex", {
    tag: {
      pattern: Pe(
        `</?(?:(?!\\d)[^\\s/=><%]+(?:<0>(?:<0>*(?:[^\\s<>/={*]+(?:<0>*=<0>*(?!\\s)(?:"[^"]*"|'[^']*'|<1>)?|(?=[\\s/>]))|<2>))+)?<0>*/?)?>`,
        [Su, Zm, Uw],
        "g"
      ),
      greedy: !0,
      inside: {
        punctuation: /^<\/?|\/?>$/,
        tag: {
          pattern: /^[^\s/]+/,
          inside: {
            namespace: /^[^:]+:/,
            "class-name": /^[A-Z]\w*(?:\.[A-Z]\w*)*$/
          }
        },
        script: {
          // Allow for two levels of nesting
          pattern: Pe("(=<0>*)<1>", [Su, Zm]),
          lookbehind: !0,
          alias: e = "language-" + e,
          inside: t
        },
        spread: {
          pattern: RegExp(Uw),
          alias: e,
          inside: t
        },
        "attr-value": {
          pattern: Pe(`(=<0>*)(?:"[^"]*"|'[^']*')`, [Su]),
          lookbehind: !0,
          inside: {
            punctuation: /^["']|["']$/
          }
        },
        comment: t.comment,
        "attr-equals": /=/,
        "attr-name": {
          pattern: /\S+/,
          inside: {
            namespace: /^[^:]+:/
          }
        }
      }
    }
  }), t[vi] = (n, o) => SZ(Jf(n, o), n, 0);
};
rE(re.js, "jsx");
re.lua = {
  comment: /^#!.+|--(?:\[(=*)\[[^]*?\]\1\]|.*)/m,
  // \z may be used to skip the following space
  string: {
    pattern: /(["'])(?:(?!\1)[^\\\n]|\\z\s|\\[^z])*\1|\[(=*)\[[^]*?\]\2\]/g,
    greedy: !0
  },
  number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  keyword: /\b(?:and|break|do|else|elseif|end|false|true|f?or|function|goto|if|in|local|nil|not|repeat|return|then|until|while)\b/,
  function: /(?!\d)\w+(?=\s*(?:[({]))/,
  // Match ".." but don't break "..."
  operator: {
    pattern: /[%&|^#*+-]|\/\/?|<[<=]?|>[>=]?|[=~]=?|(^|[^.])\.\.(?!\.)/,
    lookbehind: !0
  },
  punctuation: /[()[\]{},;]|\.+|:+/
};
var Xc = "(?:\\((?:\\\\[\\s\\S]|[^\\\\()])*\\)|\\{(?:\\\\[\\s\\S]|[^\\\\{}])*\\}|\\[(?:\\\\[\\s\\S]|[^\\\\[\\]])*\\]|<(?:\\\\[\\s\\S]|[^\\\\<>])*>)", Ww = "(?![a-zA-Zd])\\s*(?:([^a-zA-Zd\\s{([<])(?:\\\\[^]|(?!\\1)[^\\\\])*\\1|([a-zA-Zd])(?:\\\\[^]|(?!\\2)[^\\\\])*\\2";
re.perl = {
  comment: [
    {
      // POD
      pattern: /(^\s*)=\w[^]*?=cut.*/mg,
      lookbehind: !0,
      greedy: !0
    },
    {
      pattern: /(^|[^\\$])#.*/g,
      lookbehind: !0,
      greedy: !0
    }
  ],
  // TODO Could be nice to handle Heredoc too.
  string: {
    pattern: RegExp(
      `\\bq[qwx]?${Ww}|${Xc})|("|\`)(?:\\\\[^]|(?!\\3)[^\\\\])*\\3|'(?:\\\\.|[^\\\\
'])*'`,
      "g"
    ),
    greedy: !0
  },
  regex: [
    {
      pattern: RegExp(
        `\\b(?:m|qr)${Ww}|${Xc})[msixpodualngc]*`,
        "g"
      ),
      greedy: !0
    },
    // The lookbehinds prevent -s from breaking
    {
      pattern: RegExp(
        `(^|[^-])\\b(?:s|tr|y)(?![a-zA-Zd])\\s*(?:([^a-zA-Zd\\s{([<])(?:\\\\[^]|(?!\\2)[^\\\\])*\\2(?:\\\\[^]|(?!\\2)[^\\\\])*\\2|([a-zA-Zd])(?:\\\\[^]|(?!\\3)[^\\\\])*\\3(?:\\\\[^]|(?!\\3)[^\\\\])*\\3|${Xc}\\s*${Xc})[msixpodualngcer]*`,
        "g"
      ),
      lookbehind: !0,
      greedy: !0
    },
    // /.../
    // The look-ahead tries to prevent two divisions on
    // the same line from being highlighted as regex.
    // This does not support multi-line regex.
    {
      pattern: /\/(?:\\.|[^\\\n/])*\/[msixpodualngc]*(?=\s*(?:$|[\n,.;})&|*~<>!?^+-]|(?:and|cmp|eq|[gl][et]|ne|not|x|x?or)\b))/g,
      greedy: !0
    }
  ],
  // FIXME Not sure about the handling of ::, ', and #
  variable: /[&*$@%](?:\{\^[A-Z]+\}|\^[A-Z_]|#?(?=\{)|#?(?:(?:::)*'?(?!\d)[$\w]+(?![$\w]))+(?:::)*|\d+)|(?!%=)[$@%][!"#$%&'*,./:;<=>?@()[\]{}||^_`|~+-]/,
  filehandle: {
    // <>, <FOO>, _
    pattern: /<(?![<=])\S*?>|\b_\b/,
    alias: "symbol"
  },
  "v-string": {
    // v1.2, 1.2.3
    pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
    alias: "string"
  },
  function: {
    pattern: /(\bsub[ 	]+)\w+/,
    lookbehind: !0
  },
  keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
  number: /\b(?:0x[a-fA-F\d](?:_?[a-fA-F\d])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
  operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|->|=>|=~|~~|<=>?|!~|--|\+\+|(?:\*\*|\/\/|&&|\|\||<<|>>|[~%&|^!=<>/*+-])=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|[gl][et]|ne|not|x?or)\b/,
  punctuation: /[()[\]{},:;]/
};
var Kw = {
  "format-spec": {
    pattern: /(:)[^(){}:]+(?=\}$)/,
    lookbehind: !0
  },
  "conversion-option": {
    pattern: /![sra](?=[:}]$)/,
    alias: "punctuation"
  }
};
Kw[jn] = re.py = re.python = {
  comment: {
    pattern: /#.*/g,
    greedy: !0
  },
  "string-interpolation": {
    pattern: /(?:fr?|rf)(?:("""|''')[^]*?\1|(["'])(?:\\[^]|(?!\2)[^\\\n])*\2)/gi,
    greedy: !0,
    inside: {
      interpolation: {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}/,
        lookbehind: !0,
        inside: Kw
      },
      string: /[^]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:br?|rb?|u)?("""|''')[^]*?\1/gi,
    greedy: !0,
    alias: "string"
  },
  string: {
    pattern: /(?:br?|rb?|u)?(["'])(?:\\[^]|(?!\1)[^\\\n])*\1/gi,
    greedy: !0
  },
  function: {
    pattern: /((?:^|\s)def[ 	]+)(?!\d)\w+(?=\s*\()/,
    lookbehind: !0
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: !0
  },
  decorator: {
    pattern: /(^[ 	]*)@\w+(?:\.\w+)*/m,
    lookbehind: !0,
    alias: "annotation punctuation",
    inside: {
      punctuation: /\./
    }
  },
  keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|de[fl]|elif|else|except|exec|finally|f?or|from|global|i[fns]|import|lambda|match|nonlocal|not|pass|print|raise|return|try|while|with|yield)\b/,
  builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|ma[px]|memoryview|min|next|object|oct|open|ord|pow|property|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|x?range|zip)\b/,
  boolean: /\b(?:False|True|None)\b/,
  number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f\d])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /!=|:=|\*\*=?|\/\/=?|<>|>>|<<|[%=<>/*+-]=?|[&|^~]/,
  punctuation: ra
};
var kZ = ia("/\\*(?:[^*/]|\\*(?!/)|/(?!\\*)|<self>)*\\*/", 2), Gw = {
  pattern: /b?"(?:\\[^]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/g,
  greedy: !0
}, qw = {
  "closure-punctuation": {
    pattern: /^\||\|$/,
    alias: "punctuation"
  }
};
qw[jn] = re.rust = {
  comment: {
    pattern: RegExp("//.*|" + kZ, "g"),
    greedy: !0
  },
  string: Gw,
  char: {
    pattern: /b?'(?:\\(?:x[0-7][a-fA-F\d]|u\{(?:[a-fA-F\d]_*){1,6}\}|.)|[^\\\n	'])'/g,
    greedy: !0
  },
  attribute: {
    pattern: /#!?\[(?:[^[\]"]|"(?:\\[^]|[^\\"])*")*\]/g,
    greedy: !0,
    alias: "attr-name",
    inside: {
      string: Gw
    }
  },
  // Closure params should not be confused with bitwise OR |
  "closure-params": {
    pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/g,
    lookbehind: !0,
    greedy: !0,
    inside: qw
  },
  "lifetime-annotation": {
    pattern: /'\w+/,
    alias: "symbol"
  },
  "fragment-specifier": {
    pattern: /(\$\w+:)[a-z]+/,
    lookbehind: !0,
    alias: "punctuation"
  },
  variable: /\$\w+/,
  "function-definition": {
    pattern: /(\bfn\s+)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  "type-definition": {
    pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
    lookbehind: !0,
    alias: "class-name"
  },
  "module-declaration": [
    {
      pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
      lookbehind: !0,
      alias: "namespace"
    },
    {
      pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
      lookbehind: !0,
      alias: "namespace",
      inside: {
        punctuation: /::/
      }
    }
  ],
  // https://github.com/rust-lang/reference/blob/master/src/keywords.md
  // primitives and str
  // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
  keyword: /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield|bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/,
  // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
  // and Rust's naming conventions recommend snake_case anyway.
  // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
  function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
  macro: {
    pattern: /\b\w+!/,
    alias: "property"
  },
  constant: /\b[A-Z_][A-Z_\d]+\b/,
  "class-name": /\b[A-Z]\w*\b/,
  namespace: {
    pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
    inside: {
      punctuation: /::/
    }
  },
  // Hex, oct, bin, dec numbers with visual separators and type suffix
  number: /\b(?:0x[a-fA-F\d](?:_?[a-fA-F\d])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
  boolean: gn,
  punctuation: /->|\.\.=|\.{1,3}|::|[()[\]{},:;]/,
  operator: /&&|\|\||=>|>>=?|<<=?|[%&|^!=<>/*+-]=?|[@?]/
};
var Yw = re.swift = {
  comment: {
    // Nested comments are supported up to 2 levels
    pattern: /\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//g,
    greedy: !0
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: /(^|[^"#])(?:"(?:\\(?:\((?:[^()]|\([^)]*\))*\)|[^(])|[^\\\n"])*"|"""(?:\\(?:\((?:[^()]|\([^)]*\))*\)|[^(])|[^\\"]|"(?!""))*""")(?!["#])/g,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\\()(?:[^()]|\([^()]*\))+(?=\))/,
          lookbehind: !0
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        punctuation: /\\(?=\n)/,
        string: /[^]+/
      }
    },
    {
      pattern: /(^|[^"#])(#+)(?:"(?:\\(?:#+\((?:[^()]|\([^)]*\))*\)|[^#])|[^\\\n])*?"|"""(?:\\(?:#+\((?:[^()]|\([^)]*\))*\)|[^#])|[^\\])*?""")\2/g,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))+(?=\))/,
          lookbehind: !0
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        string: /[^]+/
      }
    }
  ],
  directive: {
    // directives with conditions
    pattern: /#(?:(?:elseif|if)\b(?:[ 	]*(?:![ 	]*)?(?:\b\w+\b(?:[ 	]*\((?:[^()]|\([^)]*\))*\))?|\((?:[^()]|\([^)]*\))*\))(?:[ 	]*(?:&&|\|\|))?)+|(?:else|endif)\b)/,
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: gn,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/
    }
  },
  literal: {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+/,
    alias: "property"
  },
  attribute: {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  label: {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b(?!\d)\w+(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: !0,
    alias: "important"
  },
  keyword: /\b(?:Any|[Pp]rotocol|[Ss]elf|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|[gs]et|guard|higherThan|i[fns]|import|indirect|infix|init|inout|internal|isolated|lazy|lef?t|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|public|repeat|required|rethrows|return|right|safe|some|static|struct|subscript|super|switch|throws?|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: gn,
  nil: {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  omit: {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f\d_]+(?:\.[a-f\dp_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  operator: /[~?%&|^!=<>/*+-]+|\.[.~?%&|^!=<>/*+-]+/,
  punctuation: /[()[\]{}.,:;\\]/
};
Yw["string-literal"].forEach((t) => {
  t.inside.interpolation.inside = Yw;
});
re.clike = {
  comment: Gr(),
  string: xv(),
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: {
      punctuation: /[.\\]/
    }
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: gn,
  function: /\b\w+(?=\()/,
  number: Z3,
  operator: /[!=]==|[!=<>]=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: ra
};
var Xf = (t) => `\\b(?:${t})\\b`, iE = "bool|char|decimal|double|dynamic|float|object|s?byte|string|u?int|u?long|u?short|var|void", Zf = "class|enum|interface|record|struct", sE = "add|alias|and|ascending|async|await|by|descending|from(?!\\s*[^\\s\\w])|[gls]et|global|group|into|init(?=\\s*;)|join|nameof|not|notnull|on|or|orderby|partial|remove|select|unmanaged|value|when|where|with(?=\\s*{)", Sv = "abstract|as|[bc]ase|break|catch|checked|const|continue|default|delegate|do|else|event|explicit|extern|finally|fixed|for|foreach|goto|i[fns]|implicit|internal|lock|namespace|new|null|operator|out|override|params|private|protected|public|readonly|ref|return|sealed|sizeof|stackalloc|static|switch|this|throw|try|typeof|unchecked|unsafe|using|virtual|volatile|while|yield", aE = Xf(Zf), pd = RegExp(Xf(iE + "|" + Zf + "|" + sE + "|" + Sv)), EZ = Xf(Zf + "|" + sE + "|" + Sv), _Z = Xf(iE + "|" + Zf + "|" + Sv), hd = ia("<(?:[^<>;=*/%&|^+-]|<self>)*>", 2), ku = ia("\\((?:[^()]|<self>)*\\)", 2), ro = "@?\\b(?!\\d)\\w+\\b", md = Ft("<0>(?:\\s*<1>)?", [ro, hd]), Ai = Ft("(?!<0>)<1>(?:\\s*\\.\\s*<1>)*", [EZ, md]), kv = "\\[\\s*(?:,\\s*)*\\]", AZ = Ft("<0>(?:\\s*(?:\\?\\s*)?<1>)*(?:\\s*\\?)?", [Ai, kv]), TZ = Ft("[^()[\\],;%&|^=<>/*+-]|<0>|<1>|<2>", [hd, ku, kv]), OZ = Ft("\\(<0>+(?:,<0>+)+\\)", [TZ]), cs = Ft("(?:<0>|<1>)(?:\\s*(?:\\?\\s*)?<2>)*(?:\\s*\\?)?", [OZ, Ai, kv]), Dn = {
  keyword: pd,
  punctuation: /[()[\].,:<>?]/
}, lE = `'(?:\\\\.|[^
'\\\\]|\\\\[Uux][a-fA-F\\d]{1,8})'`, cE = `"(?:\\\\.|[^\\\\
"])*"`, MZ = '@"(?:""|\\\\[\\s\\S]|[^\\\\"])*"(?!")', $r = re.dotnet = re.cs = re.csharp = Kr("clike", {
  string: [
    {
      pattern: Pe("(^|[^$\\\\])<0>", [MZ], "g"),
      lookbehind: !0,
      greedy: !0
    },
    {
      pattern: Pe("(^|[^@$\\\\])<0>", [cE], "g"),
      lookbehind: !0,
      greedy: !0
    }
  ],
  "class-name": [
    {
      // Using static
      // using static System.Math;
      pattern: Pe("(\\busing\\s+static\\s+)<0>(?=\\s*;)", [Ai]),
      lookbehind: !0,
      inside: Dn
    },
    {
      // Using alias (type)
      // using Project = PC.MyCompany.Project;
      pattern: Pe("(\\busing\\s+<0>\\s*=\\s*)<1>(?=\\s*;)", [ro, cs]),
      lookbehind: !0,
      inside: Dn
    },
    {
      // Using alias (alias)
      // using Project = PC.MyCompany.Project;
      pattern: Pe("(\\busing\\s+)<0>(?=\\s*=)", [ro]),
      lookbehind: !0
    },
    {
      // Type declarations
      // class Foo<A, B>
      // interface Foo<out A, B>
      pattern: Pe("(\\b<0>\\s+)<1>", [aE, md]),
      lookbehind: !0,
      inside: Dn
    },
    {
      // Single catch exception declaration
      // catch(Foo)
      // (things like catch(Foo e) is covered by variable declaration)
      pattern: Pe("(\\bcatch\\s*\\(\\s*)<0>", [Ai]),
      lookbehind: !0,
      inside: Dn
    },
    {
      // Name of the type parameter of generic constraints
      // where Foo : class
      pattern: Pe("(\\bwhere\\s+)<0>", [ro]),
      lookbehind: !0
    },
    {
      // Casts and checks via as and is.
      // as Foo<A>, is Bar<B>
      // (things like if(a is Foo b) is covered by variable declaration)
      pattern: Pe("(\\b(?:is(?:\\s+not)?|as)\\s+)<0>", [AZ]),
      lookbehind: !0,
      inside: Dn
    },
    {
      // Variable, field and parameter declaration
      // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
      pattern: Pe("\\b<0>(?=\\s+(?!<1>|with\\s*\\{)<2>(?:\\s*[=,:;{)\\]]|\\s+(?:in|when)\\b))", [cs, _Z, ro]),
      inside: Dn
    }
  ],
  keyword: pd,
  // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
  number: /(?:\b0(?:x[a-f\d_]*[a-f\d]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[+-]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
  operator: /[=-]>|([&|+-])\1|~|\?\?=?|>>=?|<<=?|[%&|^!=<>/*+-]=?/,
  punctuation: /\?\.?|::|[()[\]{}.,:;]/
});
lt($r, "number", {
  range: {
    pattern: /\.\./,
    alias: "operator"
  }
});
lt($r, "punctuation", {
  "named-parameter": {
    pattern: Pe("([(,]\\s*)<0>(?=\\s*:)", [ro]),
    lookbehind: !0,
    alias: "punctuation"
  }
});
lt($r, "class-name", {
  namespace: {
    // namespace Foo.Bar {}
    // using Foo.Bar;
    pattern: Pe("(\\b(?:namespace|using)\\s+)<0>(?:\\s*\\.\\s*<0>)*(?=\\s*[;{])", [ro]),
    lookbehind: !0,
    inside: {
      punctuation: /\./
    }
  },
  "type-expression": {
    // default(Foo), typeof(Foo<Bar>), sizeof(int)
    pattern: Pe("(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<0>)+(?=\\s*\\))", [ku]),
    lookbehind: !0,
    alias: "class-name",
    inside: Dn
  },
  "return-type": {
    // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
    // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
    // int Foo => 0; int Foo { get; set } = 0;
    pattern: Pe("<0>(?=\\s+(?:<1>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))", [cs, Ai]),
    alias: "class-name",
    inside: Dn
  },
  "constructor-invocation": {
    // new List<Foo<Bar[]>> { }
    pattern: Pe("(\\bnew\\s+)<0>(?=\\s*[[({])", [cs]),
    lookbehind: !0,
    alias: "class-name",
    inside: Dn
  },
  /*'explicit-implementation': {
  	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
  	pattern: replace(/\b<0>(?=\.<1>)/, className, methodOrPropertyDeclaration),
  	inside: classNameInside,
  	alias: 'class-name'
  },*/
  "generic-method": {
    // foo<Bar>()
    pattern: Pe("<0>\\s*<1>(?=\\s*\\()", [ro, hd]),
    inside: {
      function: Pe("^<0>", [ro]),
      generic: {
        pattern: RegExp(hd),
        alias: "class-name",
        inside: Dn
      }
    }
  },
  "type-list": {
    // The list of types inherited or of generic constraints
    // class Foo<F> : Bar, IList<FooBar>
    // where F : Bar, IList<int>
    pattern: Pe(
      "\\b((?:<0>\\s+<1>|record\\s+<1>\\s*<5>|where\\s+<2>)\\s*:\\s*)(?:<3>|<4>|<1>\\s*<5>|<6>)(?:\\s*,\\s*(?:<3>|<4>|<6>))*(?=\\s*(?:where|[{;]|=>|$))",
      [aE, md, ro, cs, pd.source, ku, "\\bnew\\s*\\(\\s*\\)"]
    ),
    lookbehind: !0,
    inside: {
      "record-arguments": {
        pattern: Pe("(^(?!new\\s*\\()<0>\\s*)<1>", [md, ku], "g"),
        lookbehind: !0,
        greedy: !0,
        inside: $r
      },
      keyword: pd,
      "class-name": {
        pattern: RegExp(cs, "g"),
        greedy: !0,
        inside: Dn
      },
      punctuation: /[(),]/
    }
  },
  preprocessor: {
    pattern: /(^[ 	]*)#.*/m,
    lookbehind: !0,
    alias: "property",
    inside: {
      // highlight preprocessor directives as keywords
      directive: {
        pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
        lookbehind: !0,
        alias: "keyword"
      }
    }
  }
});
var uE = cE + "|" + lE, dE = Ft(`/(?![*/])|//[^
]*
|/\\*(?:[^*]|\\*(?!/))*\\*/|<0>`, [uE]), fE = ia(Ft(`[^()"'/]|<0>|\\(<self>*\\)`, [dE]), 2), Jw = "\\b(?:assembly|event|field|method|module|param|property|return|type)\\b", IZ = Ft("<0>(?:\\s*\\(<1>*\\))?", [Ai, fE]), Ev = `:[^
}]+`, pE = ia(Ft(`[^()"'/]|<0>|\\(<self>*\\)`, [dE]), 2), Xw = Ft("\\{(?!\\{)(?:(?![}:])<0>)*<1>?\\}", [pE, Ev]), hE = ia(Ft(`[^()"'/]|/(?!\\*)|/\\*(?:[^*]|\\*(?!/))*\\*/|<0>|\\(<self>*\\)`, [uE]), 2), Zw = Ft("\\{(?!\\{)(?:(?![}:])<0>)*<1>?\\}", [hE, Ev]), Qw = (t, e) => ({
  interpolation: {
    pattern: Pe("((?:^|[^{])(?:\\{\\{)*)<0>", [t]),
    lookbehind: !0,
    inside: {
      "format-string": {
        pattern: Pe("(^\\{(?:(?![}:])<0>)*)<1>(?=\\}$)", [e, Ev]),
        lookbehind: !0,
        inside: {
          punctuation: /^:/
        }
      },
      punctuation: /^\{|\}$/,
      expression: {
        pattern: /[^]+/,
        alias: "language-csharp",
        inside: $r
      }
    }
  },
  string: /[^]+/
});
lt($r, "class-name", {
  attribute: {
    // Attributes
    // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
    pattern: Pe("((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<0>\\s*:\\s*)?<1>(?:\\s*,\\s*<1>)*(?=\\s*\\])", [Jw, IZ], "g"),
    lookbehind: !0,
    greedy: !0,
    inside: {
      target: {
        pattern: Pe("^<0>(?=\\s*:)", [Jw]),
        alias: "keyword"
      },
      "attribute-arguments": {
        pattern: Pe("\\(<0>*\\)", [fE]),
        inside: $r
      },
      "class-name": {
        pattern: RegExp(Ai),
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /[,:]/
    }
  }
});
lt($r, "string", {
  "interpolation-string": [
    {
      pattern: Pe('(^|[^\\\\])(?:\\$@|@\\$)"(?:""|\\\\[\\s\\S]|\\{\\{|<0>|[^\\\\{"])*"', [Xw], "g"),
      lookbehind: !0,
      greedy: !0,
      inside: Qw(Xw, pE)
    },
    {
      pattern: Pe('(^|[^@\\\\])\\$"(?:\\\\.|\\{\\{|<0>|[^\\\\"{])*"', [Zw], "g"),
      lookbehind: !0,
      greedy: !0,
      inside: Qw(Zw, hE)
    }
  ],
  char: {
    pattern: RegExp(lE, "g"),
    greedy: !0
  }
});
re.graphql = {
  comment: /#.*/,
  description: {
    pattern: /(?:"""(?:[^"]|"(?!""))*"""|"(?:\\.|[^\\\n"])*")(?=\s*[a-z_])/gi,
    greedy: !0,
    alias: "string",
    inside: {
      "language-markdown": {
        pattern: /("(?!")|""")[^]+(?=\1)/,
        lookbehind: !0,
        inside: "md"
      }
    }
  },
  string: {
    pattern: /"""[^]*?"""|"(?:\\.|[^\\\n"])*"/g,
    greedy: !0
  },
  number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  boolean: gn,
  variable: /\$[a-z_]\w*/i,
  directive: {
    pattern: /@[a-z_]\w*/i,
    alias: "function"
  },
  "attr-name": {
    pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\\n"])*")*\))?:)/gi,
    greedy: !0
  },
  "atom-input": {
    pattern: /\b[A-Z]\w*Input\b/,
    alias: "class-name"
  },
  scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
  constant: /\b[A-Z][A-Z_\d]*\b/,
  "class-name": {
    pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
    lookbehind: !0
  },
  fragment: {
    pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))(?!\d)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  "definition-mutation": {
    pattern: /(\bmutation\s+)(?!\d)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  "definition-query": {
    pattern: /(\bquery\s+)(?!\d)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
  operator: /[&|!=]|\.{3}/,
  "property-query": /\w+(?=\s*\()/,
  object: /\w+(?=\s*\{)/,
  punctuation: /[()[\]{},:!=]/,
  property: /\w+/,
  [vi](t, e) {
    for (var n = Jf(t, e), o = n.filter(({ type: g }) => g && g != "comment" && g != "scalar"), r = o.length, i = 0, s = (g) => {
      for (var v = 0; v < g.length; v++)
        if (i + v == r || o[i + v].type != g[v])
          return !0;
    }, a = (g, v) => {
      for (var y = 1, w = i; w < r; w++) {
        var x = o[w], b = x.content;
        if (x.type == "punctuation") {
          if (g == b)
            y++;
          else if (v == b && !--y)
            return w;
        }
      }
    }; i < r; ) {
      var l = o[i++];
      if (l.type == "keyword" && l.content == "mutation") {
        var c = [];
        if (!s(["definition-mutation", "punctuation"]) && o[i + 1].content == "(") {
          i += 2;
          var u = a("(", ")");
          if (!u)
            continue;
          for (; i < u; i++) {
            var d = o[i];
            d.type == "variable" && (d.alias = "variable-input", c.push(d.content));
          }
          i = u + 1;
        }
        if (!s(["punctuation", "property-query"]) && o[i].content == "{" && (o[++i].alias = "property-mutation", c[0])) {
          var f = a("{", "}");
          if (f)
            for (var p = i; p < f; p++) {
              var m = o[p];
              m.type == "variable" && c.indexOf(m.content) >= 0 && (m.alias = "variable-input");
            }
        }
      }
    }
    return n;
  }
};
re.webmanifest = re.json = {
  property: {
    pattern: /"(?:\\.|[^\\\n"])*"(?=\s*:)/g,
    greedy: !0
  },
  string: {
    pattern: /"(?:\\.|[^\\\n"])*"/g,
    greedy: !0
  },
  comment: Gr(),
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  operator: /:/,
  punctuation: /[[\]{},]/,
  boolean: gn,
  null: {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
re.makefile = {
  comment: /#(?:\\[^]|[^\\\n])*/,
  string: xv(),
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  target: {
    pattern: /^(?:[^:=\s]|[ 	]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: {
      variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|override|private|s?include|undefine|unexport|vpath)\b/,
  function: {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ 	])/,
    lookbehind: !0
  },
  operator: /(?:::|[?:+!])?=|[|@]/,
  punctuation: /[:;(){}]/
};
var _v = re.scss = Kr("css", {
  comment: Gr(),
  atrule: {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      rule: /@[\w-]+/,
      [jn]: "scss"
    }
  },
  // url, compassified
  url: /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  selector: {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?!\s)[^@;(){}]?(?:[^@;(){}\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      parent: {
        pattern: /&/,
        alias: "important"
      },
      placeholder: /%[-\w]+/,
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  property: {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
lt(_v, "atrule", {
  keyword: [
    /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
    {
      pattern: /( )(?:from|through)(?= )/,
      lookbehind: !0
    }
  ]
});
lt(_v, "important", {
  // var and interpolated vars
  variable: /\$[-\w]+|#\{\$[-\w]+\}/
});
lt(_v, "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  placeholder: {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  statement: {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  boolean: gn,
  null: {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  operator: {
    pattern: /(\s)(?:[%/*+-]|[!=]=|[<>]=?|and|not|or)(?!\S)/,
    lookbehind: !0
  }
});
var mE = {
  pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/g,
  lookbehind: !0,
  greedy: !0
}, sa = re.ts = re.typescript = Kr("js", {
  "class-name": mE
});
lt(sa, "operator", {
  builtin: /\b(?:Array|Function|Promise|any|boolean|never|number|string|symbol|unknown)\b/
});
sa.keyword.push(
  /\b(?:abstract|declare|is|keyof|readonly|require)\b|\b(?:asserts|infer|interface|module|namespace|type)\b(?!\s*[^\s{_$a-zA-Z\xa0-\uffff])|\btype(?=\s*\*)/
);
delete sa.parameter;
delete sa["literal-property"];
var Av = mE.inside = Object.assign({}, sa);
delete Av["class-name"];
delete Av["maybe-class-name"];
lt(sa, "function", {
  decorator: {
    pattern: /@[$\w\xa0-\uffff]+/,
    inside: {
      at: {
        pattern: /^@/,
        alias: "operator"
      },
      function: /.+/
    }
  },
  "generic-function": {
    // e.g. foo<T extends "bar" | "baz">( ...
    pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+\s*<(?:[^<>=]|=[^<]|=?<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/g,
    greedy: !0,
    inside: {
      generic: {
        pattern: /<[^]+/,
        // everything after the first <
        alias: "class-name",
        inside: Av
      },
      function: /\S+/
    }
  }
});
rE(re.ts, "tsx");
var Qm = re.tsx.tag, gE = "(?:^|(";
try {
  RegExp("(?<=)"), gE += "?<=";
} catch {
  Qm.lookbehind = !0;
}
Qm.pattern = RegExp(gE + `[^\\w$])|(?=</))${Qm.pattern.source}`, "g");
var eg = /[*&][^\s[\]{},]+/, tg = /!(?:<[\w%#;/?:@&=$,.!~*'()[\]+-]+>|(?:[a-zA-Z\d-]*!)?[\w%#;/?:@&=$.~*'()+-]+)?/, ng = `(?:${tg.source}(?:[ 	]+${eg.source})?|${eg.source}(?:[ 	]+${tg.source})?)`, RZ = Ft(
  "(?:[^\\s\0-\\x08\\x0e-\\x1f!\"#%&'*,:>?@[\\]{}`|\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff-]|[?:-]<0>)(?:[ 	]*(?:(?![#:])<0>|:<0>))*",
  ["[^\\s\0-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]"]
), e2 = `"(?:\\\\.|[^\\\\
"])*"|'(?:\\\\.|[^\\\\
'])*'`, ka = (t, e) => Pe(
  `([:,[{-]\\s*(?:\\s<0>[ 	]+)?)<1>(?=[ 	]*(?:$|,|\\]|\\}|(?:
\\s*)?#))`,
  [ng, t],
  e
);
re.yml = re.yaml = {
  scalar: {
    pattern: Pe(`([:-]\\s*(?:\\s<0>[ 	]+)?[|>])[ 	]*(?:(
[ 	]+)\\S.*(?:\\2.+)*)`, [ng]),
    lookbehind: !0,
    alias: "string"
  },
  comment: /#.*/,
  key: {
    pattern: Pe(
      `((?:^|[:,[{
?-])[ 	]*(?:<0>[ 	]+)?)<1>(?=\\s*:\\s)`,
      [ng, "(?:" + RZ + "|" + e2 + ")"],
      "g"
    ),
    lookbehind: !0,
    greedy: !0,
    alias: "atrule"
  },
  directive: {
    pattern: /(^[ 	]*)%.+/m,
    lookbehind: !0,
    alias: "important"
  },
  datetime: {
    pattern: ka("\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ 	]+)\\d\\d?:\\d\\d:\\d\\d(?:\\.\\d*)?(?:[ 	]*(?:Z|[+-]\\d\\d?(?::\\d\\d)?))?|\\d{4}-\\d\\d-\\d\\d|\\d\\d?:\\d\\d(?::\\d\\d(?:\\.\\d*)?)?", "m"),
    lookbehind: !0,
    alias: "number"
  },
  boolean: {
    pattern: ka("false|true", "im"),
    lookbehind: !0,
    alias: "important"
  },
  null: {
    pattern: ka("null|~", "im"),
    lookbehind: !0,
    alias: "important"
  },
  string: {
    pattern: ka(e2, "mg"),
    lookbehind: !0,
    greedy: !0
  },
  number: {
    pattern: ka("[+-]?(?:0x[a-f\\d]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)", "im"),
    lookbehind: !0
  },
  tag: tg,
  important: eg,
  punctuation: /---|[:[\]{},|>?-]|\.{3}/
};
var t2 = {
  pattern: /\\[\\()[\]{}^$+*?|.]/,
  alias: "escape"
}, Eu = /\\(?:x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|u\{[a-fA-F\d]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, $Z = {
  pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
  alias: "class-name"
}, PZ = {
  pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
  alias: "class-name"
}, n2 = "(?:[^\\\\-]|" + Eu.source + ")", LZ = RegExp(n2 + "-" + n2), o2 = {
  pattern: /(<|')[^<>']+(?=[>']$)/,
  lookbehind: !0,
  alias: "variable"
};
re.regex = {
  "char-class": {
    pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:\\[^]|[^\\\]])*\]/,
    lookbehind: !0,
    inside: {
      "char-class-punctuation": {
        pattern: /^.|.$/g,
        greedy: !0,
        alias: "punctuation"
      },
      "char-class-negation": {
        pattern: /^\^/,
        alias: "operator"
      },
      range: {
        pattern: LZ,
        inside: {
          escape: Eu,
          "range-punctuation": {
            pattern: /-/,
            alias: "operator"
          }
        }
      },
      "special-escape": t2,
      "char-set": PZ,
      escape: Eu
    }
  },
  "special-escape": t2,
  "char-set": $Z,
  backreference: [
    {
      // a backreference which is not an octal escape
      pattern: /\\(?![123][0-7]{2})[1-9]/,
      alias: "keyword"
    },
    {
      pattern: /\\k<[^<>']+>/,
      alias: "keyword",
      inside: {
        "group-name": o2
      }
    }
  ],
  anchor: {
    pattern: /[$^]|\\[ABbGZz]/,
    alias: "function"
  },
  escape: Eu,
  group: [
    {
      // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
      // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
      // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
      pattern: /(\()\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[!=]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?)/,
      lookbehind: !0,
      inside: {
        "group-name": o2
      }
    },
    {
      pattern: /[()]/,
      alias: "punctuation"
    }
  ],
  quantifier: {
    pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
    alias: "number"
  },
  alternation: {
    pattern: /\|/,
    alias: "keyword"
  }
};
const DZ = (t, e, ...n) => {
  var q;
  let o, r, i = [], s, a = "", l, c = !1, u = !1, d = !0, f = [], p, m = 0;
  const g = BZ(), v = g.firstChild, y = v.children, w = y[0], x = w.firstChild, b = { language: "text", value: a }, S = new Set(n), k = {}, A = (z) => {
    if (Object.assign(b, z), a = z.value ?? a, o = b.language, !re[o])
      throw Error(`Language '${o}' has no grammar.`);
    p = !!b.readOnly, g.style.tabSize = b.tabSize || 2, x.inputMode = p ? "none" : "", x.setAttribute("aria-readonly", p), M(), O(), (r != (r = re[o]) || a != x.value) && (Q(), x.value = a, x.selectionEnd = 0, $());
  }, $ = () => {
    f = bv(a = x.value, r), G("tokenize", f, o, a);
    let z = G3(f).split(`
`), H = 0, Z = m, ne = m = z.length;
    for (; z[H] == i[H] && H < ne; )
      ++H;
    for (; ne && z[--ne] == i[--Z]; )
      ;
    if (H == ne && H == Z)
      y[H + 1].innerHTML = z[H] + `
`;
    else {
      let he = Z < H ? Z : H - 1, we = he, Ae = "";
      for (; we < ne; )
        Ae += `<div class=pce-line aria-hidden=true>${z[++we]}
</div>`;
      for (we = ne < H ? ne : H - 1; we < Z; we++)
        y[H + 1].remove();
      for (Ae && y[he + 1].insertAdjacentHTML("afterend", Ae), we = he + 1; we < m; )
        y[++we].setAttribute("data-line", we);
      g.style.setProperty(
        "--number-width",
        Math.ceil(Math.log10(m + 1)) + ".001ch"
      );
    }
    G("update", a), V(!0), d && setTimeout(setTimeout, 0, () => d = !0), i = z, d = !1;
  }, O = (z) => {
    (z || S).forEach((H) => {
      typeof H == "object" ? (H.update(B, b), z && S.add(H)) : (H(B, b), z || S.delete(H));
    });
  }, M = ([z, H] = P()) => {
    g.className = `prism-code-editor language-${o}${b.lineNumbers == !1 ? "" : " show-line-numbers"} pce-${b.wordWrap ? "" : "no"}wrap${b.rtl ? " pce-rtl" : ""} pce-${z < H ? "has" : "no"}-selection${u ? " pce-focus" : ""}${p ? " pce-readonly" : ""}`;
  }, P = () => [
    x.selectionStart,
    x.selectionEnd,
    x.selectionDirection
  ], F = {
    Escape() {
      x.blur();
    }
  }, J = {}, Q = () => _u && !u && Vt(
    B,
    "focus",
    (z) => {
      let H = z.relatedTarget;
      H ? H.focus() : x.blur();
    },
    { once: !0 }
  ), G = (z, ...H) => {
    var Z, ne;
    (Z = k[z]) == null || Z.forEach((he) => he.apply(B, H)), (ne = b["on" + z[0].toUpperCase() + z.slice(1)]) == null || ne.apply(B, H);
  }, V = (z) => {
    if (z || d) {
      const H = P(), Z = y[l = yE(a, 0, H[H[2] < "f" ? 0 : 1])];
      Z != s && (s == null || s.classList.remove("active-line"), Z.classList.add("active-line"), s = Z), M(H), G("selectionChange", H, a);
    }
  }, B = {
    scrollContainer: g,
    wrapper: v,
    overlays: w,
    textarea: x,
    get activeLine() {
      return s;
    },
    get activeLineNumber() {
      return l;
    },
    get value() {
      return a;
    },
    options: b,
    get focused() {
      return u;
    },
    get removed() {
      return c;
    },
    get tokens() {
      return f;
    },
    inputCommandMap: J,
    keyCommandMap: F,
    extensions: {},
    setOptions: A,
    update: $,
    getSelection: P,
    setSelection(z, H = z, Z) {
      Q(), x.setSelectionRange(z, H, Z), V(!0);
    },
    addExtensions(...z) {
      O(z);
    },
    addListener(z, H) {
      (k[z] || (k[z] = /* @__PURE__ */ new Set())).add(H);
    },
    removeListener(z, H) {
      var Z;
      (Z = k[z]) == null || Z.delete(H);
    },
    remove() {
      g.remove(), c = !0;
    }
  };
  return Vt(B, "keydown", (z) => {
    var H;
    (H = F[z.key]) != null && H.call(F, z, P(), a) && Ht(z);
  }), Vt(B, "beforeinput", (z) => {
    var H;
    (p || z.inputType == "insertText" && ((H = J[z.data]) != null && H.call(J, z, P(), a))) && Ht(z);
  }), Vt(B, "input", $), Vt(B, "blur", () => {
    Ga = null, u = !1, M();
  }), Vt(B, "focus", () => {
    Ga = V, u = !0, M();
  }), Vt(B, "selectionchange", (z) => {
    V(), Ht(z);
  }), (q = NZ(t)) == null || q.append(g), e && A(e), B;
}, r2 = /* @__PURE__ */ document.createElement("div"), Qf = (t) => {
  r2.innerHTML = t;
  const e = r2.firstChild;
  return () => e.cloneNode(!0);
}, Vt = (t, e, n, o) => t.textarea.addEventListener(e, n, o), NZ = (t) => typeof t == "string" ? document.querySelector(t) : t, vE = navigator.userAgent, gd = /Mac|iPhone|iPod|iPad/i.test(navigator.platform), vd = /Chrome\//.test(vE), _u = !vd && /AppleWebKit\//.test(vE), yE = (t, e = 0, n = 1 / 0) => {
  let o = 1;
  for (; (e = t.indexOf(`
`, e) + 1) && e <= n; o++)
    ;
  return o;
}, mh = {}, BZ = /* @__PURE__ */ Qf(
  "<div><div class=pce-wrapper><div class=pce-overlays><textarea spellcheck=false autocapitalize=off autocomplete=off>"
), Ht = (t) => {
  t.preventDefault(), t.stopImmediatePropagation();
};
let Ga;
document.addEventListener("selectionchange", () => Ga == null ? void 0 : Ga());
const FZ = (t, e, n = 0) => {
  const o = t.scrollContainer.style, r = document.documentElement.style;
  o.scrollPaddingBlock = r.scrollPaddingBlock = `${n}px ${vd && !e.textContent ? e.offsetHeight : 0}px`, e.scrollIntoView({ block: "nearest" }), o.scrollPaddingBlock = r.scrollPaddingBlock = "";
}, yd = (t, e) => e ? t.lastIndexOf(`
`, e - 1) + 1 : 0, ep = (t, e) => (e = t.indexOf(`
`, e)) + 1 ? e : t.length, zZ = (t, e, n) => (t.addListener(e, n), () => t.removeListener(e, n)), HZ = (t, e) => parseFloat(getComputedStyle(t)[e]);
let us;
const Ea = (t) => t.replace(/[$+?|.^*()[\]{}\\]/g, "\\$&"), og = (t, e) => t.slice(yd(t, e), e), nr = (t, e, n = e) => [
  t.slice(e = yd(t, e), n = ep(t, n)).split(`
`),
  e,
  n
], bd = (t, e, n = 0, o = n, r = t.getSelection()[0]) => {
  var u;
  const i = t.value, s = t.wrapper.children[yE(i, 0, r)], a = document.createTreeWalker(s, 5);
  let l = a.lastChild(), c = ep(i, r) + 1 - r - l.length;
  for (; -c <= o && (l = a.previousNode()); )
    if (!l.lastChild && (c -= l.length || 0, c <= n)) {
      for (; l != s; l = l.parentNode)
        if ((u = l.matches) != null && u.call(l, e))
          return l;
    }
}, gh = (t, e) => {
  var n;
  return ((n = bd(t, '[class*="language-"]', 0, 0, e)) == null ? void 0 : n.className.match(
    /language-(\S*)/
  )[1]) || t.options.language;
}, Xt = (t, e, n, o, r, i) => {
  if (t.options.readOnly)
    return;
  us = t.getSelection(), o ?? (o = n);
  let s = t.textarea, a = t.value, l = vd && !a[o ?? us[1]] && /\n$/.test(e) && /^$|\n$/.test(a), c;
  t.focused || s.focus(), n != null && s.setSelectionRange(n, o), r != null && (c = zZ(t, "update", () => {
    s.setSelectionRange(
      r,
      i ?? r,
      us[2]
    ), c();
  })), _u || s.dispatchEvent(new InputEvent("beforeinput", { data: e })), vd || _u ? (l && (s.selectionEnd--, e = e.slice(0, -1)), _u && (e += `
`), document.execCommand(
    e ? "insertHTML" : "delete",
    !1,
    e.replace(/&/g, "&amp;").replace(/</g, "&lt;")
  ), l && s.selectionStart++) : document.execCommand(e ? "insertText" : "delete", !1, e), us = 0;
}, $a = (t) => t.altKey + t.ctrlKey * 2 + t.metaKey * 4 + t.shiftKey * 8;
let rg = !1;
const i2 = navigator.clipboard, ui = gd ? 4 : 2, VZ = (t) => rg = t, Zr = (t) => t.search(/\S|$/), UZ = (t = ['""', "''", "``", "()", "[]", "{}"], e = /([^$\w'"`]["'`]|.[[({])[.,:;\])}>\s]|.[[({]`/s) => (n, o) => {
  let r;
  const { keyCommandMap: i, inputCommandMap: s, getSelection: a, scrollContainer: l } = n, c = ({ insertSpaces: g = !0, tabSize: v } = o) => [g ? " " : "	", g ? v || 2 : 1], u = () => {
    var g;
    return !o.readOnly && !((g = n.extensions.cursor) != null && g.scrollIntoView());
  }, d = ([g, v], [y, w], x, b) => (g < v || !b && e.test((x[v - 1] || " ") + y + (x[v] || " "))) && !Xt(n, y + x.slice(g, v) + w, null, null, g + 1, v + 1), f = ([g, v], y, w) => g == v && w[v] == y && !n.setSelection(g + 1), p = (g, v, y, w, x, b) => {
    let S = v.join(`
`);
    if (S != g.join(`
`)) {
      const k = g.length - 1, A = v[k], $ = g[k], O = $.length - A.length, M = v[0].length - g[0].length, P = y + Zr((M < 0 ? v : g)[0]), F = w - $.length + Zr(O > 0 ? A : $), J = y - w + S.length + O, Q = P > x ? x : Math.max(P, x + M), G = b + y - w + S.length;
      Xt(
        n,
        S,
        y,
        w,
        Q,
        b < F ? G + O : Math.max(F + J, G)
      );
    }
  }, m = (g, v, y, w, x, b, S, k) => {
    p(
      v,
      v.map(
        g ? (A) => A.slice(Zr(A) ? k - Zr(A) % k : 0) : (A) => A && S.repeat(k - Zr(A) % k) + A
      ),
      y,
      w,
      x,
      b
    );
  };
  s["<"] = (g, v, y) => d(v, "<>", y, !0), t.forEach(([g, v]) => {
    const y = g == v;
    s[g] = (w, x, b) => (y && f(x, v, b) || d(x, g + v, b)) && u(), y || (s[v] = (w, x, b) => f(x, v, b) && u());
  }), s[">"] = (g, v, y) => {
    var x, b;
    const w = (b = (x = mh[gh(n)]) == null ? void 0 : x.autoCloseTags) == null ? void 0 : b.call(x, v, y, n);
    w && (Xt(n, ">" + w, null, null, v[0] + 1), Ht(g));
  }, i.Tab = (g, [v, y], w) => {
    if (rg || o.readOnly || $a(g) & 6)
      return;
    const [x, b] = c(o), S = g.shiftKey, [k, A, $] = nr(w, v, y);
    return v < y || S ? m(S, k, A, $, v, y, x, b) : Xt(n, x.repeat(b - (v - A) % b)), u();
  }, i.Enter = (g, v, y) => {
    var x, b, S;
    const w = $a(g) & 7;
    if (!w || w == ui) {
      w && (v[0] = v[1] = nr(y, v[1])[2]);
      const [k, A] = c(), [$, O] = v, M = (x = mh[gh(n)]) == null ? void 0 : x.autoIndent, P = Math.floor(Zr(og(y, $)) / A) * A, F = (b = M == null ? void 0 : M[0]) != null && b.call(M, v, y, n) ? A : 0, J = (S = M == null ? void 0 : M[1]) == null ? void 0 : S.call(M, v, y, n), Q = `
` + k.repeat(P + F) + (J ? `
` + k.repeat(P) : "");
      if (Q[1] || y[O])
        return Xt(n, Q, $, O, $ + P + F + 1), u();
    }
  }, i.Backspace = (g, [v, y], w) => {
    if (v == y) {
      const x = og(w, v), b = o.tabSize || 2, S = t.includes(w.slice(v - 1, v + 1)), k = /[^ ]/.test(x) ? 0 : (x.length - 1) % b + 1;
      if (S || k > 1)
        return Xt(n, "", v - (S ? 1 : k), v + S), u();
    }
  };
  for (let g = 0; g < 2; g++)
    i[g ? "ArrowDown" : "ArrowUp"] = (v, [y, w], x) => {
      const b = $a(v);
      if (b == 1) {
        const S = g ? y : yd(x, y) - 1, k = g ? x.indexOf(`
`, w) + 1 : w;
        if (S > -1 && k > 0) {
          const [A, $, O] = nr(x, S, k), M = A[g ? "pop" : "shift"](), P = (M.length + 1) * (g ? 1 : -1);
          A[g ? "unshift" : "push"](M), Xt(n, A.join(`
`), $, O, y + P, w + P);
        }
        return u();
      } else if (b == 9) {
        const [S, k, A] = nr(x, y, w), $ = S.join(`
`), O = g ? $.length + 1 : 0;
        return Xt(n, $ + `
` + $, k, A, y + O, w + O), u();
      } else if (b == 2 && !gd)
        return l.scrollBy(0, HZ(l, "lineHeight") * (g ? 1 : -1)), !0;
    };
  Vt(n, "keydown", (g) => {
    var S;
    const v = $a(g), y = g.keyCode, [w, x, b] = a();
    if (v == ui && (y == 221 || y == 219))
      m(y == 219, ...nr(n.value, w, x), w, x, ...c()), u(), Ht(g);
    else if (v == (gd ? 10 : 2) && y == 77)
      VZ(!rg), Ht(g);
    else if (y == 191 && v == ui || y == 65 && v == 9) {
      const k = n.value, A = v == 9, $ = A ? w : yd(k, w), O = mh[gh(n, $)] || {}, { line: M, block: P } = ((S = O.getComments) == null ? void 0 : S.call(O, n, $, k)) || O.comments || {}, [F, J, Q] = nr(k, w, x), G = F.length - 1;
      if (A) {
        if (P) {
          const [V, B] = P, q = k.slice(w, x), z = k.slice(0, w).search(Ea(V) + " ?$"), H = RegExp("^ ?" + Ea(B)).test(k.slice(x));
          z + 1 && H ? Xt(
            n,
            q,
            z,
            x + +(k[x] == " ") + B.length,
            z,
            z + x - w
          ) : Xt(
            n,
            `${V} ${q} ${B}`,
            w,
            x,
            w + V.length + 1,
            x + V.length + 1
          ), u(), Ht(g);
        }
      } else if (M) {
        const V = Ea(M), B = RegExp(`^\\s*(${V} ?|$)`), q = RegExp(V + " ?"), z = !/\S/.test(k.slice(J, Q)), H = F.map(
          F.every((Z) => B.test(Z)) && !z ? (Z) => Z.replace(q, "") : (Z) => z || /\S/.test(Z) ? Z.replace(/^\s*/, `$&${M} `) : Z
        );
        p(F, H, J, Q, w, x), u(), Ht(g);
      } else if (P) {
        const [V, B] = P, q = Zr(F[0]), z = F[0].startsWith(V, q) && F[G].endsWith(B), H = F.slice();
        H[0] = F[0].replace(
          z ? RegExp(Ea(V) + " ?") : /(?=\S)|$/,
          z ? "" : V + " "
        );
        let Z = H[0].length - F[0].length;
        H[G] = z ? H[G].replace(RegExp(`( ?${Ea(B)})?$`), "") : H[G] + " " + B;
        let ne = H.join(`
`), he = q + J, we = he > w ? w : Math.max(w + Z, he), Ae = he > x - (w != x) ? x : Math.min(Math.max(he, x + Z), J + ne.length);
        Xt(n, ne, J, Q, we, Math.max(we, Ae)), u(), Ht(g);
      }
    } else if (v == 8 + ui && y == 75) {
      const k = n.value, [A, $, O] = nr(k, w, x), M = b > "f" ? x - O + A.pop().length : w - $, P = ep(k, O + 1) - O - 1;
      Xt(
        n,
        "",
        $ - !!$,
        O + !$,
        $ + Math.min(M, P)
      ), u(), Ht(g);
    }
  }), ["copy", "cut", "paste"].forEach(
    (g) => Vt(n, g, (v) => {
      const [y, w] = a();
      if (y == w && i2) {
        const [[x], b, S] = nr(n.value, y, w);
        g == "paste" ? v.clipboardData.getData("text/plain") == r && (Xt(n, r + `
`, b, b, y + r.length + 1), u(), Ht(v)) : (i2.writeText(r = x), g == "cut" && (Xt(n, "", b, S + 1), u()), Ht(v));
      }
    })
  );
}, jZ = (t = 999) => {
  let e = 0, n, o, r = !1, i, s, a, l, c, u;
  const d = [], f = (g) => {
    g >= t && (g--, d.shift()), d.splice(e = g, t, [n.value, u(), u()]);
  }, p = (g) => {
    var v;
    d[g] && (c.value = d[g][0], c.setSelectionRange(...d[g][g < e ? 2 : 1]), n.update(), (v = n.extensions.cursor) == null || v.scrollIntoView(), e = g, o = !1);
  }, m = (g, v) => {
    g.extensions.history = m, n = g, u = g.getSelection, c || f(0), c = g.textarea, g.addListener("selectionChange", () => {
      o = r, r = !1;
    }), Vt(g, "beforeinput", (y) => {
      let w = y.data, x = y.inputType, b = y.timeStamp;
      /history/.test(x) ? (p(e + (x[7] == "U" ? -1 : 1)), Ht(y)) : (l = o && (i == x || b - a < 99 && x.slice(-4) == "Drop") && !us && (w != " " || s == w)) || (d[e][2] = us || u()), r = !0, s = w, a = b, i = x;
    }), Vt(g, "input", () => f(e + !l)), Vt(g, "keydown", (y) => {
      if (!v.readOnly) {
        const w = $a(y), x = y.keyCode, b = w == ui && x == 90, S = w == ui + 8 && x == 90 || !gd && w == ui && x == 89;
        b ? (p(e - 1), Ht(y)) : S && (p(e + 1), Ht(y));
      }
    });
  };
  return m.clear = () => {
    f(0), o = !1;
  }, m.has = (g) => e + g in d, m.go = (g) => p(e + g), m;
}, WZ = Qf(
  "<div style=position:absolute;top:0;opacity:0;padding:inherit> <span><span></span> "
), KZ = () => {
  let t, e = " ", n = " ";
  const o = WZ(), [r, i] = o.childNodes, [s, a] = i.childNodes, l = (d) => {
    let { value: f, activeLine: p } = t, m = d[d[2] < "f" ? 0 : 1], g = og(f, m), v = f.slice(m, ep(f, m));
    !g && !v && (v = " "), e != g && (r.data = e = g), n != v && (a.data = n = v), o.parentNode != p && p.prepend(o);
  }, c = () => FZ(t, s), u = (d) => {
    d.addListener("selectionChange", l), t = d, d.extensions.cursor = u, Vt(d, "input", (f) => {
      /history/.test(f.inputType) && c();
    }), d.activeLine && l(d.getSelection());
  };
  return u.getPosition = () => {
    const d = s.getBoundingClientRect(), f = t.overlays.getBoundingClientRect();
    return {
      top: d.y - f.y,
      bottom: f.bottom - d.bottom,
      left: d.x - f.x,
      right: f.right - d.x,
      height: d.height
    };
  }, u.scrollIntoView = c, u.element = s, u;
}, GZ = Qf(
  "<div class=guide-indents style=left:var(--padding-left);bottom:auto;right:auto> "
), qZ = Qf(
  "<div style=width:1px;position:absolute;background:var(--bg-guide-indent)>"
), YZ = () => {
  let t, e = 0, n, o = -1, r;
  const i = [], s = [], a = GZ(), l = [], c = (p) => {
    n = [];
    const m = d(p.split(`
`)), g = m.length;
    for (let v = 0, y = [], w = m[0]; w; v++) {
      const x = (i[v] || (i[v] = qZ())).style, [b, S, k] = w, A = s[v];
      w = m[v + 1], b != (A == null ? void 0 : A[0]) && (x.top = b + "00%"), S != (A == null ? void 0 : A[1]) && (x.height = S + "00%"), k != (A == null ? void 0 : A[2]) && (x.left = k * 100 + "%");
      const $ = y[0] != b && (w == null ? void 0 : w[0]) != b, O = y[0] + y[1] != b + S && (w == null ? void 0 : w[0]) + (w == null ? void 0 : w[1]) != b + S;
      for (let M = -$, P = S + O; M < P; M++)
        n[M + b] = v;
      y = s[v] = m[v];
    }
    for (let v = e; v > g; )
      i[--v].remove();
    a.append(...i.slice(e, e = g));
  }, u = () => {
    const p = n[r.activeLineNumber - 1] ?? -1;
    p != o && (o > -1 && (i[o].className = ""), p > -1 && (i[p].className = "active")), o = p;
  }, d = (p) => {
    const m = p.length, g = [], v = [];
    for (let y = 0, w = -1, x = 0, b = 0; ; x++) {
      const S = x == m, k = S ? 0 : l[x] = f(p[x]);
      if (k < 0)
        w < 0 && (w = x);
      else {
        for (let A = k; A < y; A++)
          g[A][1] = (w < 0 || A == k && !S ? x : w) - g[A][0];
        for (let A = y; A < k; )
          v[b++] = g[A] = [
            w < 0 || A > y ? x : w,
            0,
            A++ * t
          ];
        w = -1, y = k;
      }
      if (S)
        break;
    }
    return l.length = m, v;
  }, f = (p) => {
    let m = p.search(/\S/), g = 0;
    if (m < 0)
      return m;
    for (let v = 0; v < m; )
      g += p[v++] == "	" ? t - g % t : 1;
    return Math.ceil(g / t);
  };
  return {
    lines: a.children,
    indentLevels: l,
    update(p, m) {
      r || (r = p, p.extensions.indentGuides = this, p.overlays.append(a), p.addListener("update", c), p.addListener("selectionChange", u)), a.style.display = m.wordWrap ? "none" : "", t != (t = m.tabSize || 2) && (c(p.value), u());
    }
  };
}, JZ = () => (t) => {
  let e, n, o, r = -1, i = [], s = () => {
    n || (n = t.extensions.matchBrackets);
    let [c, u] = t.getSelection(), d = c == u && t.focused && n && a(u) || -1;
    if (d != r) {
      if (l(), d + 1) {
        let f = e[o[d]], p = e[d];
        i = [f, p].map(
          (m) => bd(t, ".punctuation", 0, -1, m[1])
        ), i[0] != i[1] && f[1] + f[3].length == p[1] && (i[0].textContent += i[1].textContent, i[1].textContent = "", i[1] = i[0]), l(!0);
      } else
        i = [];
      r = d;
    }
  }, a = (c) => {
    var u;
    ({ brackets: e, pairs: o } = n);
    for (let d = 0, f; f = e[++d]; )
      if (!f[4] && f[5] >= c && ((u = e[o[d]]) == null ? void 0 : u[1]) <= c)
        return d;
  }, l = (c) => i.forEach((u) => u.classList.toggle("active-bracket", !!c));
  Vt(t, "focus", s), Vt(t, "blur", s), t.addListener("selectionChange", s), t.addListener("update", () => {
    l(), r = -1;
  });
}, XZ = (t = !0, e = "([{", n = ")]}") => {
  let o, r;
  const i = [], s = (d) => {
    d.extensions.matchBrackets = s, d.addListener("tokenize", c), t && d.tokens[0] ? d.update() : c(d.tokens);
  }, a = s.brackets = [], l = s.pairs = [], c = (d) => {
    if (l.length = a.length = r = o = 0, u(d, 0), t)
      for (let f = 0, p; p = a[f]; ) {
        let m = p[0].alias;
        p[0].alias = (m ? m + " " : "") + `bracket-${f++ in l ? "level-" + p[2] % 12 : "error"}`;
      }
  }, u = (d, f) => {
    let p, m = 0;
    for (; p = d[m++]; ) {
      let g = p.length;
      if (typeof p != "string") {
        let v = p.content;
        if (Array.isArray(v))
          u(v, f);
        else if ((p.alias || p.type) == "punctuation") {
          let y = s2(v, e, g - 1), w = y || s2(v, n, g - 1);
          if (w) {
            if (a[o] = [p, f, 0, v, !!y, f + g], y)
              i[r++] = [o, y];
            else
              for (let x = r; x; ) {
                let [b, S] = i[--x];
                w == S && (l[l[o] = b] = o, a[o][2] = a[b][2] = r = x, x = 0);
              }
            o++;
          }
        }
      }
      f += g;
    }
  };
  return s;
}, s2 = (t, e, n) => e.indexOf(t[0]) + 1 || n && e.indexOf(t[n]) + 1, ZZ = "xml,rss,atom,jsx,tsx,xquery,actionscript".split(","), QZ = /^(?:area|base|w?br|col|embed|hr|img|input|link|meta|source|track)$/i, eQ = (t) => {
  let e = [], n, o = [], r, i, s = [], a = (c, u, d) => {
    n = d, o.length = e.length = r = i = 0, l(c, u, 0);
  }, l = (c, u, d) => {
    let f = ZZ.includes(u), p = 0, m = c.length;
    for (; p < m; ) {
      const g = c[p++], v = g.content, y = g.length;
      if (Array.isArray(v))
        if (g.type == "tag" && n[d] == "<") {
          const w = v[0].length, x = v[2] ? n.substr(d + w, v[1].length) : "", b = v[v.length - 1].length < 2 && (f || !QZ.test(x));
          if (v[2] && f && l(v, u, d), b)
            if (w > 1)
              for (let S = i; S; )
                x == s[--S][1] && (e[e[r] = s[i = S][0]] = r, S = 0);
            else
              s[i++] = [r, x];
          o[r++] = [
            g,
            d,
            d + y,
            x,
            w > 1,
            b
          ];
        } else {
          let w = g.alias || g.type;
          l(
            v,
            w.slice(0, 9) == "language-" ? w.slice(9) : u,
            d
          );
        }
      d += y;
    }
  };
  return t.addListener("tokenize", a), a(t.tokens, t.options.language, t.value), {
    tags: o,
    pairs: e
  };
}, tQ = (t, e) => {
  for (let n = 0, o = e.length; n < o; n++)
    if (e[n][1] <= t && e[n][2] >= t)
      return n;
}, nQ = () => (t) => {
  var e;
  let n, o;
  const { tags: r, pairs: i } = (e = t.extensions).matchTags || (e.matchTags = eQ(t)), s = (a) => [n, o].forEach((l) => {
    l && l.classList.toggle("active-tagname", !a);
  });
  t.addListener("selectionChange", ([a, l]) => {
    let c, u, d;
    a == l && t.focused && (d = tQ(a, r), d + 1 && (d = i[d], d + 1 && (c = bd(t, ".tag>.tag")) && (u = bd(t, ".tag>.tag", 2, 0, r[d][1])))), n != c && (s(!0), n = c, o = u, s());
  });
}, a2 = /* @__PURE__ */ I({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    by: { type: [String, Function] },
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(t, { emit: e }) {
    const r = Ie(t, e);
    return (i, s) => (E(), T(h(Hj), _e(Me(h(r))), {
      default: C(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), l2 = /* @__PURE__ */ I({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = L(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = Ie(r, o);
    return (s, a) => (E(), T(h(Uj), null, {
      default: C(() => [
        _(h(Xj), j({ ...h(i), ...s.$attrs }, {
          class: h(ve)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            s.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: C(() => [
            _(h(iQ)),
            _(h(nW), {
              class: He(h(ve)("p-1", s.position === "popper" && "h-[--reka-select-trigger-height] w-full min-w-[--reka-select-trigger-width]"))
            }, {
              default: C(() => [
                D(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            _(h(rQ))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), oQ = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, c2 = /* @__PURE__ */ I({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(Qj), j(h(o), {
      class: h(ve)(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.class
      )
    }), {
      default: C(() => [
        N("span", oQ, [
          _(h(eW), null, {
            default: C(() => [
              _(h(rc), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(h(tW), null, {
          default: C(() => [
            D(r.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rQ = /* @__PURE__ */ I({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(rW), j(h(o), {
      class: h(ve)("flex cursor-default items-center justify-center py-1", e.class)
    }), {
      default: C(() => [
        D(r.$slots, "default", {}, () => [
          _(h(Dk))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), iQ = /* @__PURE__ */ I({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(oW), j(h(o), {
      class: h(ve)("flex cursor-default items-center justify-center py-1", e.class)
    }), {
      default: C(() => [
        D(r.$slots, "default", {}, () => [
          _(h(wK))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), u2 = /* @__PURE__ */ I({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = vt(n);
    return (r, i) => (E(), T(h(Vj), j(h(o), {
      class: h(ve)(
        "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:truncate text-start",
        e.class
      )
    }), {
      default: C(() => [
        D(r.$slots, "default"),
        _(h(sW), { "as-child": "" }, {
          default: C(() => [
            _(h(Dk), { class: "w-4 h-4 opacity-50 shrink-0" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), d2 = /* @__PURE__ */ I({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(iW), _e(Me(e)), {
      default: C(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sQ = {
  key: 0,
  class: "echo-code-block-toolbar"
}, aQ = /* @__PURE__ */ I({
  __name: "NodeView",
  props: jl,
  setup(t) {
    const e = t, { t: n } = Ge(), o = R(null), r = R(e.node.attrs.code || e.node.textContent || "");
    let i = R(null);
    const s = [
      { value: "plaintext", label: "plaintext" },
      { value: "javascript", label: "JavaScript" },
      { value: "typescript", label: "TypeScript" },
      { value: "html", label: "HTML" },
      { value: "css", label: "CSS" },
      { value: "python", label: "Python" },
      { value: "java", label: "Java" },
      { value: "cpp", label: "C++" },
      { value: "go", label: "Go" },
      { value: "rust", label: "Rust" },
      { value: "sql", label: "SQL" },
      { value: "json", label: "JSON" },
      { value: "yaml", label: "YAML" },
      { value: "markdown", label: "Markdown" },
      { value: "bash", label: "Bash" },
      { value: "php", label: "PHP" }
    ], a = [2, 4, 8], l = () => {
      r.value && navigator.clipboard.writeText(r.value).then(() => {
        console.log("代码已复制到剪贴板");
      }).catch((f) => {
        console.error("复制失败:", f);
      });
    }, c = () => {
      e.updateAttributes({
        lineNumbers: !e.node.attrs.lineNumbers
      });
    }, u = () => {
      e.updateAttributes({
        wordWrap: !e.node.attrs.wordWrap
      });
    }, d = (f) => {
      const p = { ...f };
      return p.language && !s.some((m) => m.value === p.language) && (p.language = "plaintext", e.updateAttributes({
        language: "plaintext"
      })), p;
    };
    return be(() => {
      const f = d(e.node.attrs);
      i.value = DZ(o.value, {
        readOnly: !e.editor.isEditable,
        language: f.language || "plaintext",
        tabSize: f.tabSize ?? 2,
        lineNumbers: f.lineNumbers ?? !0,
        wordWrap: f.wordWrap ?? !1,
        value: r.value,
        rtl: !1,
        onUpdate(p) {
          e.updateAttributes({ code: p });
        }
      }), i.value.addExtensions(
        XZ(),
        nQ(),
        YZ(),
        JZ(),
        KZ(),
        UZ(),
        jZ()
      ), e.node.attrs.shouldFocus && ze(() => {
        var p;
        (p = i.value) == null || p.textarea.focus(), e.updateAttributes({
          shouldFocus: !1
        });
      });
    }), mo(() => {
      var f;
      (f = i.value) == null || f.remove();
    }), le(
      () => e.editor.isEditable,
      (f) => {
        var p;
        (p = i.value) == null || p.setOptions({
          readOnly: f
        });
      }
    ), le(
      () => [e.node.attrs.language, e.node.attrs.lineNumbers, e.node.attrs.wordWrap, e.node.attrs.tabSize],
      () => {
        var p;
        const f = d(e.node.attrs);
        (p = i.value) == null || p.setOptions(f);
      }
    ), (f, p) => {
      const m = ye;
      return E(), T(h(Ul), {
        id: f.node.attrs.id,
        class: "echo-node-view my-8"
      }, {
        default: C(() => [
          N("div", {
            ref_key: "containerRef",
            ref: o,
            class: "echo-node-container echo-hover-shadow echo-select-outline echo-node-code-block"
          }, [
            f.editor.isEditable ? (E(), W("div", sQ, [
              _(h(Fn), { "delay-duration": 0 }, {
                default: C(() => [
                  _(h(Nn), null, {
                    default: C(() => [
                      _(h(zn), { class: "w-[160px]" }, {
                        default: C(() => [
                          _(h(a2), {
                            "model-value": f.node.attrs.language,
                            "onUpdate:modelValue": p[1] || (p[1] = (g) => f.node.attrs.language = g)
                          }, {
                            default: C(() => [
                              _(h(u2), { class: "w-[160px] border-none outline-none text-sm h-7 hover:bg-[#5a5d5e4f]" }, {
                                default: C(() => [
                                  _(h(d2), { placeholder: "Select language" })
                                ]),
                                _: 1
                              }),
                              _(h(l2), {
                                class: "bg-[#21252b] text-[#ccc] border-[#3a3f4b]",
                                onCloseAutoFocus: p[0] || (p[0] = (g) => g.preventDefault())
                              }, {
                                default: C(() => [
                                  (E(), W(me, null, Oe(s, (g) => _(h(c2), {
                                    class: "focus:bg-[#5a5d5e4f] focus:text-[#fff]",
                                    key: g.value,
                                    value: g.value
                                  }, {
                                    default: C(() => [
                                      ue(Y(g.label), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }, 8, ["model-value"])
                        ]),
                        _: 1
                      }),
                      _(h(Bn), { "side-offset": 5 }, {
                        default: C(() => [
                          ue(Y(h(n)("editor.codeblock.selectLang")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              p[4] || (p[4] = N("div", { class: "toolbar-divider" }, null, -1)),
              _(h(Fn), { "delay-duration": 0 }, {
                default: C(() => [
                  _(h(Nn), null, {
                    default: C(() => [
                      _(h(zn), null, {
                        default: C(() => [
                          N("div", {
                            onClick: l,
                            class: "h-7 w-7 hover:bg-[#5a5d5e4f] rounded-sm flex justify-center items-center cursor-pointer"
                          }, [
                            _(m, {
                              name: "Copy",
                              class: "w-4 h-4"
                            })
                          ])
                        ]),
                        _: 1
                      }),
                      _(h(Bn), { "side-offset": 5 }, {
                        default: C(() => [
                          ue(Y(h(n)("editor.codeblock.copy")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              p[5] || (p[5] = N("div", { class: "toolbar-divider" }, null, -1)),
              _(h(Fn), { "delay-duration": 0 }, {
                default: C(() => [
                  _(h(Nn), null, {
                    default: C(() => [
                      _(h(zn), null, {
                        default: C(() => [
                          N("div", {
                            onClick: c,
                            class: He(["h-7 w-7 hover:bg-[#5a5d5e4f] rounded-sm flex justify-center items-center cursor-pointer", { "bg-[#5a5d5e4f]": f.node.attrs.lineNumbers }])
                          }, [
                            _(m, {
                              name: "List",
                              class: "w-4 h-4"
                            })
                          ], 2)
                        ]),
                        _: 1
                      }),
                      _(h(Bn), { "side-offset": 5 }, {
                        default: C(() => [
                          ue(Y(h(n)("editor.codeblock.lineNumbers")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              p[6] || (p[6] = N("div", { class: "toolbar-divider" }, null, -1)),
              _(h(Fn), { "delay-duration": 0 }, {
                default: C(() => [
                  _(h(Nn), null, {
                    default: C(() => [
                      _(h(zn), null, {
                        default: C(() => [
                          N("div", {
                            onClick: u,
                            class: He(["h-7 w-7 hover:bg-[#5a5d5e4f] rounded-sm flex justify-center items-center cursor-pointer", { "bg-[#5a5d5e4f]": f.node.attrs.wordWrap }])
                          }, [
                            _(m, {
                              name: "WrapText",
                              class: "w-4 h-4"
                            })
                          ], 2)
                        ]),
                        _: 1
                      }),
                      _(h(Bn), { "side-offset": 5 }, {
                        default: C(() => [
                          ue(Y(h(n)("editor.codeblock.wordWrap")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              p[7] || (p[7] = N("div", { class: "toolbar-divider" }, null, -1)),
              _(h(Fn), { "delay-duration": 0 }, {
                default: C(() => [
                  _(h(Nn), null, {
                    default: C(() => [
                      _(h(zn), null, {
                        default: C(() => [
                          _(h(a2), {
                            "model-value": f.node.attrs.tabSize,
                            "onUpdate:modelValue": p[3] || (p[3] = (g) => f.node.attrs.tabSize = g)
                          }, {
                            default: C(() => [
                              _(h(u2), { class: "w-[60px] border-none outline-none text-sm h-7 hover:bg-[#5a5d5e4f]" }, {
                                default: C(() => {
                                  var g;
                                  return [
                                    _(h(d2), {
                                      placeholder: ((g = f.node.attrs) == null ? void 0 : g.tabSize.toString()) ?? ""
                                    }, null, 8, ["placeholder"])
                                  ];
                                }),
                                _: 1
                              }),
                              _(h(l2), {
                                class: "bg-[#21252b] text-[#ccc] border-[#3a3f4b]",
                                onCloseAutoFocus: p[2] || (p[2] = (g) => g.preventDefault())
                              }, {
                                default: C(() => [
                                  (E(), W(me, null, Oe(a, (g) => _(h(c2), {
                                    class: "focus:bg-[#5a5d5e4f] focus:text-[#fff]",
                                    key: g,
                                    value: g
                                  }, {
                                    default: C(() => [
                                      ue(Y(g), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }, 8, ["model-value"])
                        ]),
                        _: 1
                      }),
                      _(h(Bn), { "side-offset": 5 }, {
                        default: C(() => [
                          ue(Y(h(n)("editor.codeblock.tabSize")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ])) : oe("", !0)
          ], 512)
        ]),
        _: 1
      }, 8, ["id"]);
    };
  }
}), lQ = /^```([a-z]+)?[\s\n]$/, cQ = /^~~~([a-z]+)?[\s\n]$/, mre = Ze.create({
  name: "codeBlock",
  group: "block",
  atom: !0,
  content: "text*",
  addAttributes() {
    return {
      vnode: {
        default: !0
      },
      code: {
        default: "",
        parseHTML: (t) => t.textContent || ""
      },
      language: {
        default: "plaintext"
      },
      lineNumbers: {
        default: !0
      },
      wordWrap: {
        default: !1
      },
      tabSize: {
        default: 2
      },
      shouldFocus: {
        default: !0,
        parseHTML: () => !1,
        renderHTML: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full",
        getAttrs: (t) => ({
          code: t.textContent || ""
        })
      },
      {
        tag: "pre code",
        preserveWhitespace: "full",
        getAttrs: (t) => ({
          code: t.textContent || ""
        })
      }
    ];
  },
  renderHTML({ HTMLAttributes: t, node: e }) {
    var o;
    let n = e.attrs.code || ((o = e.content.firstChild) == null ? void 0 : o.text) || "";
    return [
      "pre",
      Le(this.options.HTMLAttributes, t),
      ["code", {}, n]
    ];
  },
  addNodeView() {
    return Wl(aQ);
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: {
          ...t,
          shouldFocus: !0
        }
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.setCodeBlock({})
    };
  },
  addInputRules() {
    return [
      Jh({
        find: lQ,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      Jh({
        find: cQ,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  }
}), uQ = Ze.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Le(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => Jh({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), dQ = { class: "flex items-center h-full justify-between font-normal w-full" }, fQ = {
  key: 0,
  class: "text-left truncate text-sm flex-grow"
}, pQ = { class: "max-w-24 text-center flex flex-col items-center" }, hQ = {
  key: 0,
  class: "flex"
}, mQ = /* @__PURE__ */ I({
  __name: "ActionMenuButton",
  props: {
    icon: { default: void 0 },
    class: { default: "" },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Fn), null, {
      default: C(() => [
        _(h(Nn), { "delay-duration": 0 }, {
          default: C(() => [
            _(h(zn), { "as-child": "" }, {
              default: C(() => [
                _(h(Rt), {
                  class: He(h(Yo)("h-[32px] px-1.5 py-0", e.class)),
                  variant: "ghost",
                  disabled: n.disabled
                }, {
                  default: C(() => [
                    N("div", dQ, [
                      n.title ? (E(), W("div", fQ, Y(n.title), 1)) : oe("", !0),
                      n.icon ? (E(), T(h(ye), {
                        key: 1,
                        class: "w-[16px] h-[16px]",
                        name: n.icon
                      }, null, 8, ["name"])) : oe("", !0),
                      _(h(ye), {
                        class: "w-3 h-3 ml-1 text-zinc-500 flex-shrink-0",
                        name: "MenuDown"
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["class", "disabled"])
              ]),
              _: 1
            }),
            n.tooltip || n.shortcutKeys && n.shortcutKeys.length ? (E(), T(h(Bn), {
              key: 0,
              hideWhenDetached: ""
            }, {
              default: C(() => [
                N("div", pQ, [
                  N("div", null, Y(n.tooltip), 1),
                  n.shortcutKeys && n.shortcutKeys.length ? (E(), W("div", hQ, [
                    N("span", null, Y(h(Ro)(n.shortcutKeys)), 1)
                  ])) : oe("", !0)
                ])
              ]),
              _: 1
            })) : oe("", !0)
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), Bi = /* @__PURE__ */ I({
  __name: "ActionDropdownButton",
  props: {
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    class: { default: "" },
    btn_class: { default: "" },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (E(), T(h(Vr), null, {
      default: C(() => [
        _(h(jr), { disabled: n.disabled }, {
          default: C(() => [
            _(mQ, {
              class: He(n.btn_class),
              title: n.title,
              icon: n.icon,
              tooltip: n.tooltip,
              disabled: n.disabled,
              "is-active": n.isActive
            }, null, 8, ["class", "title", "icon", "tooltip", "disabled", "is-active"])
          ]),
          _: 1
        }, 8, ["disabled"]),
        _(h(Ur), {
          class: He(h(Yo)("p-1 min-w-32 w-full", e.class)),
          align: "start",
          side: "bottom"
        }, {
          default: C(() => [
            D(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }));
  }
}), gQ = /* @__PURE__ */ I({
  __name: "HeadingButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    shortcutKeys: { default: void 0 },
    maxHeight: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, n = L(() => {
      const o = e.items.find((i) => i.isActive());
      return o && !o.default ? {
        ...o
      } : {
        title: e.tooltip,
        level: 0,
        isActive: () => !1
      };
    });
    return (o, r) => {
      var i;
      return E(), T(Bi, {
        disabled: o.disabled,
        tooltip: o.tooltip,
        title: (i = n.value) == null ? void 0 : i.title,
        btn_class: "min-w-24 max-w-32"
      }, {
        default: C(() => [
          (E(!0), W(me, null, Oe(e.items, (s, a) => (E(), W(me, { key: a }, [
            _(h(na), {
              "model-value": n.value.title === s.title,
              onClick: s.action
            }, {
              default: C(() => [
                N("div", {
                  class: He(["ml-1 h-full", "heading-" + s.level])
                }, Y(s.title), 3),
                _(h(j3), { class: "pl-4" }, {
                  default: C(() => {
                    var l;
                    return [
                      ue(Y((l = s.shortcutKeys) == null ? void 0 : l.map((c) => h(jf)(c)).join(" ")), 1)
                    ];
                  }),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1032, ["model-value", "onClick"]),
            s.level === 0 ? (E(), T(h(vv), { key: 0 })) : oe("", !0)
          ], 64))), 128))
        ]),
        _: 1
      }, 8, ["disabled", "tooltip", "title"]);
    };
  }
}), gre = uQ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      levels: [1, 2, 3, 4, 5, 6],
      button({ editor: e, extension: n, t: o }) {
        var c;
        const { extensions: r = [] } = e.extensionManager ?? [], i = ((c = n.options) == null ? void 0 : c.levels) || [], s = r.find((u) => u.name === "base-kit"), a = i.map((u) => ({
          action: () => e == null ? void 0 : e.chain().toggleHeading({ level: u }).focus().run(),
          isActive: () => e.isActive("heading", { level: u }) || !1,
          disabled: !(e != null && e.isEditable) || !e.can().toggleHeading({ level: u }),
          title: o(`editor.heading.h${u}.tooltip`),
          level: u,
          shortcutKeys: ["alt", "mod", `${u}`]
        }));
        s && s.options.paragraph !== !1 && a.unshift({
          action: () => e == null ? void 0 : e.chain().setParagraph().focus().run(),
          isActive: () => e.isActive("paragraph") || !1,
          disabled: !(e != null && e.isEditable) || !e.can().setParagraph(),
          level: 0,
          title: o("editor.paragraph.tooltip"),
          shortcutKeys: ["alt", "mod", "0"]
        });
        const l = a.filter((u) => u.disabled).length === a.length;
        return {
          component: gQ,
          componentProps: {
            tooltip: o("editor.heading.tooltip"),
            disabled: l,
            items: a
          }
        };
      }
    };
  }
}), vQ = ke.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), yQ = /* @__PURE__ */ I({
  __name: "TextAlignMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    maxHeight: { default: void 0 },
    icon: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, n = L(() => {
      const o = e.items.find((i) => i.isActive());
      return o && !o.default ? {
        ...o,
        icon: o.icon ? o.icon : e.icon
      } : {
        title: e.tooltip,
        icon: e.icon,
        isActive: () => !1
      };
    });
    return (o, r) => (E(), T(Bi, {
      icon: o.icon,
      tooltip: o.tooltip,
      disabled: o.disabled,
      class: "min-w-4 w-full flex flex-row gap-1"
    }, {
      default: C(() => [
        _(h(Fn), null, {
          default: C(() => [
            (E(!0), W(me, null, Oe(e.items, (i, s) => (E(), T(h(Nn), { key: s }, {
              default: C(() => [
                _(h(zn), { "as-child": "" }, {
                  default: C(() => [
                    _(h(ci), {
                      class: "p-0",
                      onClick: i.action
                    }, {
                      default: C(() => [
                        _(h(Zk), {
                          size: "sm",
                          class: "w-7 h-7 p-1",
                          pressed: n.value.title === i.title
                        }, {
                          default: C(() => [
                            i.icon ? (E(), T(h(ye), {
                              key: 0,
                              name: i.icon
                            }, null, 8, ["name"])) : oe("", !0)
                          ]),
                          _: 2
                        }, 1032, ["pressed"])
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  _: 2
                }, 1024),
                _(h(Bn), { class: "flex flex-col items-center" }, {
                  default: C(() => {
                    var a;
                    return [
                      N("span", null, Y(i.title), 1),
                      N("span", null, Y((a = i.shortcutKeys) == null ? void 0 : a.map((l) => h(jf)(l)).join(" ")), 1)
                    ];
                  }),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["icon", "tooltip", "disabled"]));
  }
}), vre = vQ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["heading", "paragraph", "list_item", "title"],
      button({ editor: e, extension: n, t: o }) {
        var c;
        const r = ((c = n.options) == null ? void 0 : c.alignments) || [], i = {
          left: ["mod", "Shift", "L"],
          center: ["mod", "Shift", "E"],
          right: ["mod", "Shift", "R"],
          justify: ["mod", "Shift", "J"]
        }, s = {
          left: "AlignLeft",
          center: "AlignCenter",
          right: "AlignRight",
          justify: "AlignJustify"
        }, a = r.map((u) => ({
          title: o(`editor.textalign.${u}.tooltip`),
          icon: s[u],
          shortcutKeys: i[u],
          isActive: () => e.isActive({ textAlign: u }) || !1,
          action: () => e.chain().setTextAlign(u).focus().run(),
          disabled: !e.isEditable || !e.can().setTextAlign(u)
        })), l = a.filter((u) => u.disabled).length === a.length;
        return {
          component: yQ,
          componentProps: {
            icon: "AlignJustify",
            tooltip: o("editor.textalign.tooltip"),
            disabled: l,
            items: a
          }
        };
      }
    };
  }
}), bQ = { class: "ml-1 h-full" }, wQ = /* @__PURE__ */ I({
  __name: "FontSizeMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    shortcutKeys: { default: void 0 },
    maxHeight: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = L(() => {
      const r = e.items.find((s) => s.isActive());
      return r || {
        title: n.value("editor.fontSize.default.tooltip"),
        isActive: () => !1
      };
    });
    return (r, i) => (E(), T(Bi, {
      disabled: r.disabled,
      tooltip: r.tooltip,
      title: o.value.title,
      btn_class: "min-w-24 max-w-32"
    }, {
      default: C(() => [
        _(h(K3), { class: "w-32 h-96" }, {
          default: C(() => [
            (E(!0), W(me, null, Oe(e.items, (s, a) => (E(), W(me, { key: a }, [
              _(h(na), {
                "model-value": o.value.title === s.title,
                onSelect: s.action
              }, {
                default: C(() => [
                  N("div", bQ, Y(s.title), 1)
                ]),
                _: 2
              }, 1032, ["model-value", "onSelect"]),
              s.title === h(n)("editor.fontSize.default.tooltip") ? (E(), T(h(vv), { key: 0 })) : oe("", !0)
            ], 64))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["disabled", "tooltip", "title"]));
  }
}), yre = ke.create({
  name: "fontSize",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["textStyle"],
      fontSizes: [...zO],
      button({ editor: e, extension: n, t: o }) {
        var a;
        const r = ((a = n.options) == null ? void 0 : a.fontSizes) || [], i = [Ki, ...r].map((l) => ({
          title: l === Ki ? o("editor.fontSize.default.tooltip") : String(l),
          isActive: () => {
            const { fontSize: c } = e.getAttributes("textStyle");
            return l === Ki && c === void 0 ? !0 : e.isActive({ fontSize: String(l) }) || !1;
          },
          action: () => {
            if (l === Ki) {
              e == null || e.chain().unsetFontSize().focus().run();
              return;
            }
            e == null || e.chain().setFontSize(String(l)).focus().run();
          },
          disabled: !(e != null && e.isEditable) || !e.can().setFontSize(String(l)),
          divider: l === Ki || !1,
          default: l === Ki || !1
        })), s = i.filter((l) => l.disabled).length === i.length;
        return {
          component: wQ,
          componentProps: {
            editor: e,
            tooltip: o("editor.fontSize.tooltip"),
            disabled: s,
            items: i,
            maxHeight: 280
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize.replace(/['"]+/g, ""),
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
}), xQ = (t) => {
  if (!t.children.length)
    return;
  const e = t.querySelectorAll("span");
  e && e.forEach((n) => {
    var o, r;
    const i = n.getAttribute("style"), s = (r = (o = n.parentElement) === null || o === void 0 ? void 0 : o.closest("span")) === null || r === void 0 ? void 0 : r.getAttribute("style");
    n.setAttribute("style", `${s};${i}`);
  });
}, CQ = on.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !1
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && xQ(t), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ tr: t }) => {
        const { selection: e } = t;
        return t.doc.nodesBetween(e.from, e.to, (n, o) => {
          if (n.isTextblock)
            return !0;
          n.marks.filter((r) => r.type === this.type).some((r) => Object.values(r.attrs).some((i) => !!i)) || t.removeMark(o, o + n.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), SQ = ke.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), kQ = { class: "flex items-center h-[32px] hover:bg-muted rounded-md" }, EQ = { class: "text-sm flex justify-center items-center" }, _Q = {
  width: "18px",
  height: "18px",
  viewBox: "0 0 240 240",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, AQ = {
  id: "icon/字体颜色",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, TQ = { transform: "translate(0.000000, 0.500000)" }, OQ = { transform: "translate(39.000000, 17.353553)" }, MQ = ["fill"], IQ = /* @__PURE__ */ I({
  __name: "ColorActionButton",
  props: {
    editor: {},
    icon: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, n = R(void 0);
    function o(i) {
      var s;
      (s = e.action) == null || s.call(e, i);
    }
    function r(i) {
      var s;
      (s = e.action) == null || s.call(e, n.value);
    }
    return (i, s) => (E(), W("div", kQ, [
      _(ge, {
        tooltip: i.tooltip,
        disabled: i.disabled,
        action: r
      }, {
        icon: C(() => [
          N("span", EQ, [
            (E(), W("svg", _Q, [
              N("g", AQ, [
                N("g", TQ, [
                  N("g", OQ, [
                    N("path", {
                      d: "M11,201.146447 L167,201.146447 C173.075132,201.146447 178,206.071314 178,212.146447 C178,218.221579 173.075132,223.146447 167,223.146447 L11,223.146447 C4.92486775,223.146447 7.43989126e-16,218.221579 0,212.146447 C-7.43989126e-16,206.071314 4.92486775,201.146447 11,201.146447 Z",
                      id: "矩形",
                      fill: n.value || "#DF2A3F",
                      "fill-rule": "evenodd"
                    }, null, 8, MQ),
                    s[1] || (s[1] = N("path", {
                      d: "M72.3425855,16.8295583 C75.799482,7.50883712 86.1577877,2.75526801 95.4785089,6.21216449 C100.284516,7.99463061 104.096358,11.7387855 105.968745,16.4968188 L106.112518,16.8745422 L159.385152,161.694068 C161.291848,166.877345 158.635655,172.624903 153.452378,174.531599 C148.358469,176.405421 142.719567,173.872338 140.716873,168.864661 L140.614848,168.598825 L89.211,28.86 L37.3759214,168.623816 C35.4885354,173.712715 29.8981043,176.351047 24.7909589,174.617647 L24.5226307,174.522368 C19.4337312,172.634982 16.7953993,167.044551 18.5287999,161.937406 L18.6240786,161.669077 L72.3425855,16.8295583 Z",
                      id: "路径-21",
                      fill: "currentColor",
                      "fill-rule": "nonzero"
                    }, null, -1)),
                    s[2] || (s[2] = N("path", {
                      d: "M121,103.146447 C126.522847,103.146447 131,107.623599 131,113.146447 C131,118.575687 126.673329,122.994378 121.279905,123.142605 L121,123.146447 L55,123.146447 C49.4771525,123.146447 45,118.669294 45,113.146447 C45,107.717207 49.3266708,103.298515 54.7200952,103.150288 L55,103.146447 L121,103.146447 Z",
                      id: "路径-22",
                      fill: "currentColor",
                      "fill-rule": "nonzero"
                    }, null, -1))
                  ])
                ])
              ])
            ]))
          ])
        ]),
        _: 1
      }, 8, ["tooltip", "disabled"]),
      _(e3, {
        modelValue: n.value,
        "onUpdate:modelValue": s[0] || (s[0] = (a) => n.value = a),
        onChange: o,
        disabled: i.disabled
      }, {
        default: C(() => [
          _(h(Rt), {
            variant: "ghost",
            size: "icon",
            class: "h-[32px] w-3 rounded-l-none hover:bg-muted-foreground/20",
            disabled: i.disabled
          }, {
            default: C(() => [
              _(h(ye), {
                class: "w-3 h-3 text-zinc-500",
                name: "MenuDown"
              })
            ]),
            _: 1
          }, 8, ["disabled"])
        ]),
        _: 1
      }, 8, ["modelValue", "disabled"])
    ]));
  }
}), bre = SQ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: IQ,
          componentProps: {
            action: (o) => {
              typeof o > "u" && e.chain().focus().unsetColor().run(), typeof o == "string" && e.chain().focus().setColor(o).run();
            },
            isActive: () => {
              const { color: o } = e.getAttributes("textStyle");
              return o && e.isActive({ color: o }) || !1;
            },
            editor: e,
            disabled: !(e != null && e.isEditable) || !e.can().setColor(""),
            tooltip: n("editor.color.tooltip")
          }
        };
      }
    };
  }
}), RQ = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, $Q = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, PQ = on.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      Ci({
        find: RQ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: $Q,
        type: this.type
      })
    ];
  }
}), wre = PQ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      multicolor: !0,
      button: ({ editor: e, t: n }) => ({
        component: t3,
        componentProps: {
          action: (o) => {
            typeof o == "string" && e.chain().focus().setHighlight({ color: o }).run(), typeof o > "u" && e.chain().focus().unsetHighlight().run();
          },
          editor: e,
          isActive: () => e.isActive("highlight") || !1,
          disabled: !(e != null && e.isEditable) || !e.can().setHighlight(),
          shortcutKeys: ["⇧", "mod", "H"],
          tooltip: n("editor.highlight.tooltip")
        }
      })
    };
  }
}), LQ = "listItem", f2 = "textStyle", p2 = /^\s*([-+*])\s$/, DQ = Ze.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(LQ, this.editor.getAttributes(f2)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Cs({
      find: p2,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Cs({
      find: p2,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(f2),
      editor: this.editor
    })), [
      t
    ];
  }
}), bE = /* @__PURE__ */ I({
  __name: "ActionDropdownButtonSplit",
  props: {
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    class: { default: "" },
    shortcutKeys: { default: void 0 },
    btn_class: { default: "" },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => {
      var r;
      return E(), W("div", {
        class: He(["flex items-center h-[32px] hover:bg-muted rounded-md", [((r = n.isActive) == null ? void 0 : r.call(n)) && "bg-muted"]])
      }, [
        _(ge, {
          class: He(n.btn_class),
          action: n.action,
          title: n.title,
          icon: n.icon,
          tooltip: n.tooltip,
          disabled: n.disabled,
          "shortcut-keys": n.shortcutKeys
        }, null, 8, ["class", "action", "title", "icon", "tooltip", "disabled", "shortcut-keys"]),
        _(h(Vr), null, {
          default: C(() => [
            _(h(jr), { disabled: n.disabled }, {
              default: C(() => [
                _(Rt, {
                  variant: "ghost",
                  size: "icon",
                  class: "h-[32px] w-3 rounded-l-none hover:bg-muted-foreground/20",
                  disabled: n.disabled
                }, {
                  default: C(() => [
                    _(h(ye), {
                      class: "w-3 h-3 text-zinc-500",
                      name: "MenuDown"
                    })
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ]),
              _: 1
            }, 8, ["disabled"]),
            _(h(Ur), j({
              class: h(Yo)("min-w-32 p-1 w-full", e.class),
              align: "start",
              side: "bottom"
            }, n.$attrs), {
              default: C(() => [
                D(n.$slots, "default")
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ], 2);
    };
  }
}), NQ = /* @__PURE__ */ I({
  __name: "BulletListMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    tooltip: { default: "" }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = [
      { label: "editor.bulletlist.disc.tooltip", value: "disc" },
      { label: "editor.bulletlist.circle.tooltip", value: "circle" },
      { label: "editor.bulletlist.square.tooltip", value: "square" }
    ], r = L(() => {
      var s;
      return (s = e.editor) != null && s.isActive("bulletList") ? e.editor.getAttributes("bulletList").listStyleType : "disc";
    });
    function i(s) {
      e.editor.isActive("bulletList") ? e.editor.getAttributes("bulletList").listStyleType === s.value ? e.editor.chain().focus().toggleBulletList().run() : e.editor.chain().focus().updateAttributes("bulletList", { listStyleType: s.value }).run() : e.editor.chain().focus().toggleBulletList().updateAttributes("bulletList", { listStyleType: s.value }).run();
    }
    return (s, a) => (E(), T(bE, {
      action: i,
      disabled: s.disabled,
      tooltip: s.tooltip,
      class: "min-w-4 w-full grid grid-cols-3 gap-1"
    }, {
      default: C(() => [
        _(h(Fn), null, {
          default: C(() => [
            (E(), W(me, null, Oe(o, (l) => _(h(Nn), {
              "delay-duration": 0,
              key: l.value
            }, {
              default: C(() => [
                _(h(zn), null, {
                  default: C(() => [
                    _(h(ci), {
                      class: "p-0",
                      onClick: (c) => i(l)
                    }, {
                      default: C(() => [
                        N("div", {
                          class: He([[r.value === l.value ? "bg-accent border border-accent-foreground" : ""], "h-[48px] flex flex-col w-[48px] box-border rounded-sm border"])
                        }, [
                          N("ol", {
                            style: pt({ listStyleType: l.value, lineHeight: 1 }),
                            class: "text-[10px] pl-3 flex-1 list-outside flex flex-col items-center justify-center"
                          }, [
                            (E(), W(me, null, Oe(3, (c) => N("li", { key: c }, a[0] || (a[0] = [
                              N("hr", { class: "border-0 bg-gray-200 h-[3px] w-6 my-1" }, null, -1)
                            ]))), 64))
                          ], 4)
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  _: 2
                }, 1024),
                _(h(Bn), { side: "bottom" }, {
                  default: C(() => [
                    ue(Y(h(n)(l.label)), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024)), 64))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["disabled", "tooltip"]));
  }
}), xre = DQ.extend({
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      listStyleType: {
        default: "disc",
        parseHTML: (e) => ({ listStyleType: e.style["list-style-type"] ?? "disc" }),
        renderHTML: ({ listStyleType: e }) => ({
          style: `list-style-type: ${(e == null ? void 0 : e.listStyleType) || e}`
        })
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: NQ,
        componentProps: {
          action: () => e == null ? void 0 : e.chain().focus().toggleBulletList().run(),
          isActive: () => e.isActive("bulletList") || !1,
          disabled: !(e != null && e.isEditable) || !e.can().toggleBulletList(),
          shortcutKeys: ["shift", "mod", "8"],
          icon: "List",
          tooltip: n("editor.bulletlist.tooltip")
        }
      })
    };
  }
}), Cre = Ze.create({
  name: "clear",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e.chain().focus().clearNodes().unsetAllMarks().run(),
          disabled: !e.can().chain().focus().clearNodes().unsetAllMarks().run(),
          icon: "Eraser",
          tooltip: n("editor.clear.tooltip")
        }
      })
    };
  }
}), BQ = "listItem", h2 = "textStyle", m2 = /^(\d+)\.\s$/, FQ = Ze.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", Le(this.options.HTMLAttributes, n), 0] : ["ol", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(BQ, this.editor.getAttributes(h2)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Cs({
      find: m2,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Cs({
      find: m2,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(h2) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), zQ = /* @__PURE__ */ I({
  __name: "OrderedListMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    tooltip: { default: "" },
    shortcutKeys: { default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = [
      { label: "editor.orderedlist.decimal.tooltip", value: "decimal" },
      {
        label: "editor.orderedlist.decimalLeadingZero.tooltip",
        value: "decimal-leading-zero"
      },
      { label: "editor.orderedlist.lowerRoman.tooltip", value: "lower-roman" },
      { label: "editor.orderedlist.upperRoman.tooltip", value: "upper-roman" },
      { label: "editor.orderedlist.lowerLatin.tooltip", value: "lower-latin" },
      { label: "editor.orderedlist.upperLatin.tooltip", value: "upper-latin" },
      {
        label: "editor.orderedlist.tradChineseInformal.tooltip",
        value: "trad-chinese-informal"
      },
      {
        label: "editor.orderedlist.simpChineseFormal.tooltip",
        value: "simp-chinese-formal"
      }
    ], r = L(() => {
      var s;
      return (s = e.editor) != null && s.isActive("orderedList") ? e.editor.getAttributes("orderedList").listType : "decimal";
    });
    function i(s) {
      var a, l;
      e.editor.isActive("orderedList") ? e.editor.getAttributes("orderedList").listType === s.value ? (a = e.editor.chain()) == null || a.toggleOrderedList().run() : (l = e.editor.chain()) == null || l.updateAttributes("orderedList", { listType: s.value }).run() : e.editor.chain().focus().toggleOrderedList().updateAttributes("orderedList", { listType: s.value }).run();
    }
    return (s, a) => (E(), T(bE, {
      action: i,
      disabled: s.disabled,
      tooltip: s.tooltip,
      "is-active": s.isActive,
      shortcutKeys: s.shortcutKeys,
      class: "min-w-4 w-full grid grid-cols-3 gap-1"
    }, {
      default: C(() => [
        _(h(Fn), null, {
          default: C(() => [
            (E(), W(me, null, Oe(o, (l) => _(h(Nn), {
              "delay-duration": 0,
              key: l.value
            }, {
              default: C(() => [
                _(h(zn), { "as-child": "" }, {
                  default: C(() => [
                    _(h(ci), {
                      class: "p-0",
                      onClick: (c) => i(l)
                    }, {
                      default: C(() => [
                        N("div", {
                          class: He([[r.value === l.value ? "bg-accent border border-accent-foreground" : ""], "h-[72px] flex flex-col w-[72px] box-border rounded-sm border"])
                        }, [
                          N("ol", {
                            style: pt({ listStyleType: l.value, lineHeight: 1 }),
                            class: "text-[12px] pl-3 flex-1 list-outside flex flex-col items-center justify-center"
                          }, [
                            (E(), W(me, null, Oe(3, (c) => N("li", { key: c }, a[0] || (a[0] = [
                              N("hr", { class: "border-0 bg-gray-200 h-[3px] w-6 my-1" }, null, -1)
                            ]))), 64))
                          ], 4)
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  _: 2
                }, 1024),
                _(h(Bn), { side: "bottom" }, {
                  default: C(() => [
                    ue(Y(h(n)(l.label)), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024)), 64))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["disabled", "tooltip", "is-active", "shortcutKeys"]));
  }
}), Sre = FQ.extend({
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      listType: {
        default: "decimal",
        parseHTML: (e) => {
          e.style.getPropertyValue("list-style-type");
        },
        renderHTML: ({ listType: e }) => ({
          style: `list-style-type: ${e}`
        })
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: zQ,
        componentProps: {
          action: () => e.chain().toggleOrderedList().focus().run(),
          isActive: () => e.isActive("orderedList") || !1,
          disabled: !e.isEditable || !e.can().toggleOrderedList(),
          icon: "ListOrdered",
          shortcutKeys: ["mod", "shift", "7"],
          tooltip: n("editor.orderedlist.tooltip")
        }
      })
    };
  }
}), HQ = /^\s*(\[([( |x])?\])\s$/, VQ = Ze.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      Le(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: o }) => {
      const r = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
      return i.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c) => c.preventDefault()), a.addEventListener("change", (c) => {
        if (!o.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: u } = c.target;
        o.isEditable && typeof n == "function" && o.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: d }) => {
          const f = n();
          if (typeof f != "number")
            return !1;
          const p = d.doc.nodeAt(f);
          return d.setNodeMarkup(f, void 0, {
            ...p == null ? void 0 : p.attrs,
            checked: u
          }), !0;
        }).run(), !o.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, u) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
        r.setAttribute(c, u);
      }), r.dataset.checked = t.attrs.checked, a.checked = t.attrs.checked, i.append(a, s), r.append(i, l), Object.entries(e).forEach(([c, u]) => {
        r.setAttribute(c, u);
      }), {
        dom: r,
        contentDOM: l,
        update: (c) => c.type !== this.type ? !1 : (r.dataset.checked = c.attrs.checked, a.checked = c.attrs.checked, !0)
      };
    };
  },
  addInputRules() {
    return [
      Cs({
        find: HQ,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), UQ = Ze.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Le(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
}), kre = UQ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "task-list"
      },
      taskItem: {
        HTMLAttributes: {
          class: "task-list-item"
        }
      },
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e.chain().toggleTaskList().focus().run(),
          isActive: () => e.isActive("taskList") || !1,
          disabled: !e.isEditable || !e.can().toggleTaskList(),
          icon: "ListTodo",
          shortcutKeys: ["shift", "mod", "9"],
          tooltip: n("editor.tasklist.tooltip")
        }
      })
    };
  },
  addExtensions() {
    return [VQ.configure(this.options.taskItem)];
  }
}), jQ = /^\s*>\s$/, WQ = Ze.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Cs({
        find: jQ,
        type: this.type
      })
    ];
  }
}), Ere = WQ.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "blockquote"
      },
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e == null ? void 0 : e.chain().focus().toggleBlockquote().run(),
          isActive: () => e.isActive("blockquote") || !1,
          disabled: !(e != null && e.isEditable) || !e.can().toggleBlockquote(),
          icon: "TextQuote",
          shortcutKeys: ["shift", "mod", "B"],
          tooltip: n("editor.blockquote.tooltip")
        }
      })
    };
  }
}), KQ = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", GQ = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Ns = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, ig = "numeric", sg = "ascii", ag = "alpha", qa = "asciinumeric", Pa = "alphanumeric", lg = "domain", wE = "emoji", qQ = "scheme", YQ = "slashscheme", vh = "whitespace";
function JQ(t, e) {
  return t in e || (e[t] = []), e[t];
}
function di(t, e, n) {
  e[ig] && (e[qa] = !0, e[Pa] = !0), e[sg] && (e[qa] = !0, e[ag] = !0), e[qa] && (e[Pa] = !0), e[ag] && (e[Pa] = !0), e[Pa] && (e[lg] = !0), e[wE] && (e[lg] = !0);
  for (const o in e) {
    const r = JQ(o, n);
    r.indexOf(t) < 0 && r.push(t);
  }
}
function XQ(t, e) {
  const n = {};
  for (const o in e)
    e[o].indexOf(t) >= 0 && (n[o] = !0);
  return n;
}
function Zt(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
Zt.groups = {};
Zt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let o = 0; o < e.jr.length; o++) {
      const r = e.jr[o][0], i = e.jr[o][1];
      if (i && r.test(t))
        return i;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, o) {
    for (let r = 0; r < t.length; r++)
      this.tt(t[r], e, n, o);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, o) {
    o = o || Zt.groups;
    let r;
    return e && e.j ? r = e : (r = new Zt(e), n && o && di(e, n, o)), this.jr.push([t, r]), r;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, o) {
    let r = this;
    const i = t.length;
    if (!i)
      return r;
    for (let s = 0; s < i - 1; s++)
      r = r.tt(t[s]);
    return r.tt(t[i - 1], e, n, o);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, o) {
    o = o || Zt.groups;
    const r = this;
    if (e && e.j)
      return r.j[t] = e, e;
    const i = e;
    let s, a = r.go(t);
    if (a ? (s = new Zt(), Ns(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new Zt(), i) {
      if (o)
        if (s.t && typeof s.t == "string") {
          const l = Ns(XQ(s.t, o), n);
          di(i, l, o);
        } else n && di(i, n, o);
      s.t = i;
    }
    return r.j[t] = s, s;
  }
};
const Ce = (t, e, n, o, r) => t.ta(e, n, o, r), ct = (t, e, n, o, r) => t.tr(e, n, o, r), g2 = (t, e, n, o, r) => t.ts(e, n, o, r), X = (t, e, n, o, r) => t.tt(e, n, o, r), _o = "WORD", cg = "UWORD", xE = "ASCIINUMERICAL", CE = "ALPHANUMERICAL", Pl = "LOCALHOST", ug = "TLD", dg = "UTLD", Au = "SCHEME", rs = "SLASH_SCHEME", Tv = "NUM", fg = "WS", Ov = "NL", Ya = "OPENBRACE", Ja = "CLOSEBRACE", wd = "OPENBRACKET", xd = "CLOSEBRACKET", Cd = "OPENPAREN", Sd = "CLOSEPAREN", kd = "OPENANGLEBRACKET", Ed = "CLOSEANGLEBRACKET", _d = "FULLWIDTHLEFTPAREN", Ad = "FULLWIDTHRIGHTPAREN", Td = "LEFTCORNERBRACKET", Od = "RIGHTCORNERBRACKET", Md = "LEFTWHITECORNERBRACKET", Id = "RIGHTWHITECORNERBRACKET", Rd = "FULLWIDTHLESSTHAN", $d = "FULLWIDTHGREATERTHAN", Pd = "AMPERSAND", Mv = "APOSTROPHE", Ld = "ASTERISK", ar = "AT", Dd = "BACKSLASH", Nd = "BACKTICK", Bd = "CARET", fr = "COLON", Iv = "COMMA", Fd = "DOLLAR", Xn = "DOT", zd = "EQUALS", Rv = "EXCLAMATION", Cn = "HYPHEN", Xa = "PERCENT", Hd = "PIPE", Vd = "PLUS", Ud = "POUND", Za = "QUERY", $v = "QUOTE", SE = "FULLWIDTHMIDDLEDOT", Pv = "SEMI", Zn = "SLASH", Qa = "TILDE", jd = "UNDERSCORE", kE = "EMOJI", Wd = "SYM";
var EE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: _o,
  UWORD: cg,
  ASCIINUMERICAL: xE,
  ALPHANUMERICAL: CE,
  LOCALHOST: Pl,
  TLD: ug,
  UTLD: dg,
  SCHEME: Au,
  SLASH_SCHEME: rs,
  NUM: Tv,
  WS: fg,
  NL: Ov,
  OPENBRACE: Ya,
  CLOSEBRACE: Ja,
  OPENBRACKET: wd,
  CLOSEBRACKET: xd,
  OPENPAREN: Cd,
  CLOSEPAREN: Sd,
  OPENANGLEBRACKET: kd,
  CLOSEANGLEBRACKET: Ed,
  FULLWIDTHLEFTPAREN: _d,
  FULLWIDTHRIGHTPAREN: Ad,
  LEFTCORNERBRACKET: Td,
  RIGHTCORNERBRACKET: Od,
  LEFTWHITECORNERBRACKET: Md,
  RIGHTWHITECORNERBRACKET: Id,
  FULLWIDTHLESSTHAN: Rd,
  FULLWIDTHGREATERTHAN: $d,
  AMPERSAND: Pd,
  APOSTROPHE: Mv,
  ASTERISK: Ld,
  AT: ar,
  BACKSLASH: Dd,
  BACKTICK: Nd,
  CARET: Bd,
  COLON: fr,
  COMMA: Iv,
  DOLLAR: Fd,
  DOT: Xn,
  EQUALS: zd,
  EXCLAMATION: Rv,
  HYPHEN: Cn,
  PERCENT: Xa,
  PIPE: Hd,
  PLUS: Vd,
  POUND: Ud,
  QUERY: Za,
  QUOTE: $v,
  FULLWIDTHMIDDLEDOT: SE,
  SEMI: Pv,
  SLASH: Zn,
  TILDE: Qa,
  UNDERSCORE: jd,
  EMOJI: kE,
  SYM: Wd
});
const ko = /[a-z]/, _a = new RegExp("\\p{L}", "u"), yh = new RegExp("\\p{Emoji}", "u"), Eo = /\d/, bh = /\s/, v2 = "\r", wh = `
`, ZQ = "️", QQ = "‍", xh = "￼";
let Zc = null, Qc = null;
function eee(t = []) {
  const e = {};
  Zt.groups = e;
  const n = new Zt();
  Zc == null && (Zc = y2(KQ)), Qc == null && (Qc = y2(GQ)), X(n, "'", Mv), X(n, "{", Ya), X(n, "}", Ja), X(n, "[", wd), X(n, "]", xd), X(n, "(", Cd), X(n, ")", Sd), X(n, "<", kd), X(n, ">", Ed), X(n, "（", _d), X(n, "）", Ad), X(n, "「", Td), X(n, "」", Od), X(n, "『", Md), X(n, "』", Id), X(n, "＜", Rd), X(n, "＞", $d), X(n, "&", Pd), X(n, "*", Ld), X(n, "@", ar), X(n, "`", Nd), X(n, "^", Bd), X(n, ":", fr), X(n, ",", Iv), X(n, "$", Fd), X(n, ".", Xn), X(n, "=", zd), X(n, "!", Rv), X(n, "-", Cn), X(n, "%", Xa), X(n, "|", Hd), X(n, "+", Vd), X(n, "#", Ud), X(n, "?", Za), X(n, '"', $v), X(n, "/", Zn), X(n, ";", Pv), X(n, "~", Qa), X(n, "_", jd), X(n, "\\", Dd), X(n, "・", SE);
  const o = ct(n, Eo, Tv, {
    [ig]: !0
  });
  ct(o, Eo, o);
  const r = ct(o, ko, xE, {
    [qa]: !0
  }), i = ct(o, _a, CE, {
    [Pa]: !0
  }), s = ct(n, ko, _o, {
    [sg]: !0
  });
  ct(s, Eo, r), ct(s, ko, s), ct(r, Eo, r), ct(r, ko, r);
  const a = ct(n, _a, cg, {
    [ag]: !0
  });
  ct(a, ko), ct(a, Eo, i), ct(a, _a, a), ct(i, Eo, i), ct(i, ko), ct(i, _a, i);
  const l = X(n, wh, Ov, {
    [vh]: !0
  }), c = X(n, v2, fg, {
    [vh]: !0
  }), u = ct(n, bh, fg, {
    [vh]: !0
  });
  X(n, xh, u), X(c, wh, l), X(c, xh, u), ct(c, bh, u), X(u, v2), X(u, wh), ct(u, bh, u), X(u, xh, u);
  const d = ct(n, yh, kE, {
    [wE]: !0
  });
  X(d, "#"), ct(d, yh, d), X(d, ZQ, d);
  const f = X(d, QQ);
  X(f, "#"), ct(f, yh, d);
  const p = [[ko, s], [Eo, r]], m = [[ko, null], [_a, a], [Eo, i]];
  for (let g = 0; g < Zc.length; g++)
    or(n, Zc[g], ug, _o, p);
  for (let g = 0; g < Qc.length; g++)
    or(n, Qc[g], dg, cg, m);
  di(ug, {
    tld: !0,
    ascii: !0
  }, e), di(dg, {
    utld: !0,
    alpha: !0
  }, e), or(n, "file", Au, _o, p), or(n, "mailto", Au, _o, p), or(n, "http", rs, _o, p), or(n, "https", rs, _o, p), or(n, "ftp", rs, _o, p), or(n, "ftps", rs, _o, p), di(Au, {
    scheme: !0,
    ascii: !0
  }, e), di(rs, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((g, v) => g[0] > v[0] ? 1 : -1);
  for (let g = 0; g < t.length; g++) {
    const v = t[g][0], w = t[g][1] ? {
      [qQ]: !0
    } : {
      [YQ]: !0
    };
    v.indexOf("-") >= 0 ? w[lg] = !0 : ko.test(v) ? Eo.test(v) ? w[qa] = !0 : w[sg] = !0 : w[ig] = !0, g2(n, v, v, w);
  }
  return g2(n, "localhost", Pl, {
    ascii: !0
  }), n.jd = new Zt(Wd), {
    start: n,
    tokens: Ns({
      groups: e
    }, EE)
  };
}
function _E(t, e) {
  const n = tee(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), o = n.length, r = [];
  let i = 0, s = 0;
  for (; s < o; ) {
    let a = t, l = null, c = 0, u = null, d = -1, f = -1;
    for (; s < o && (l = a.go(n[s])); )
      a = l, a.accepts() ? (d = 0, f = 0, u = a) : d >= 0 && (d += n[s].length, f++), c += n[s].length, i += n[s].length, s++;
    i -= d, s -= f, c -= d, r.push({
      t: u.t,
      // token type/name
      v: e.slice(i - c, i),
      // string value
      s: i - c,
      // start index
      e: i
      // end index (excluding)
    });
  }
  return r;
}
function tee(t) {
  const e = [], n = t.length;
  let o = 0;
  for (; o < n; ) {
    let r = t.charCodeAt(o), i, s = r < 55296 || r > 56319 || o + 1 === n || (i = t.charCodeAt(o + 1)) < 56320 || i > 57343 ? t[o] : t.slice(o, o + 2);
    e.push(s), o += s.length;
  }
  return e;
}
function or(t, e, n, o, r) {
  let i;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? i = t.j[l] : (i = new Zt(o), i.jr = r.slice(), t.j[l] = i), t = i;
  }
  return i = new Zt(n), i.jr = r.slice(), t.j[e[s - 1]] = i, i;
}
function y2(t) {
  const e = [], n = [];
  let o = 0, r = "0123456789";
  for (; o < t.length; ) {
    let i = 0;
    for (; r.indexOf(t[o + i]) >= 0; )
      i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(o, o + i), 10); s > 0; s--)
        n.pop();
      o += i;
    } else
      n.push(t[o]), o++;
  }
  return e;
}
const Ll = {
  defaultProtocol: "http",
  events: null,
  format: b2,
  formatHref: b2,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Lv(t, e = null) {
  let n = Ns({}, Ll);
  t && (n = Ns(n, t instanceof Lv ? t.o : t));
  const o = n.ignoreTags, r = [];
  for (let i = 0; i < o.length; i++)
    r.push(o[i].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = r;
}
Lv.prototype = {
  o: Ll,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const o = e != null;
    let r = this.o[t];
    return r && (typeof r == "object" ? (r = n.t in r ? r[n.t] : Ll[t], typeof r == "function" && o && (r = r(e, n))) : typeof r == "function" && o && (r = r(e, n.t, n)), r);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let o = this.o[t];
    return typeof o == "function" && e != null && (o = o(e, n.t, n)), o;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function b2(t) {
  return t;
}
function AE(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
AE.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), o = t.get("format", e, this);
    return n && o.length > n ? o.substring(0, n) + "…" : o;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = Ll.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), o = t.get("formatHref", n, this), r = t.get("tagName", n, e), i = this.toFormattedString(t), s = {}, a = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), u = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return s.href = o, a && (s.class = a), l && (s.target = l), c && (s.rel = c), u && Ns(s, u), {
      tagName: r,
      attributes: s,
      content: i,
      eventListeners: d
    };
  }
};
function tp(t, e) {
  class n extends AE {
    constructor(r, i) {
      super(r, i), this.t = t;
    }
  }
  for (const o in e)
    n.prototype[o] = e[o];
  return n.t = t, n;
}
const w2 = tp("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), x2 = tp("text"), nee = tp("nl"), eu = tp("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = Ll.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== Pl && t[1].t === fr;
  }
}), xn = (t) => new Zt(t);
function oee({
  groups: t
}) {
  const e = t.domain.concat([Pd, Ld, ar, Dd, Nd, Bd, Fd, zd, Cn, Tv, Xa, Hd, Vd, Ud, Zn, Wd, Qa, jd]), n = [fr, Iv, Xn, Rv, Xa, Za, $v, Pv, kd, Ed, Ya, Ja, xd, wd, Cd, Sd, _d, Ad, Td, Od, Md, Id, Rd, $d], o = [Pd, Mv, Ld, Dd, Nd, Bd, Fd, zd, Cn, Ya, Ja, Xa, Hd, Vd, Ud, Za, Zn, Wd, Qa, jd], r = xn(), i = X(r, Qa);
  Ce(i, o, i), Ce(i, t.domain, i);
  const s = xn(), a = xn(), l = xn();
  Ce(r, t.domain, s), Ce(r, t.scheme, a), Ce(r, t.slashscheme, l), Ce(s, o, i), Ce(s, t.domain, s);
  const c = X(s, ar);
  X(i, ar, c), X(a, ar, c), X(l, ar, c);
  const u = X(i, Xn);
  Ce(u, o, i), Ce(u, t.domain, i);
  const d = xn();
  Ce(c, t.domain, d), Ce(d, t.domain, d);
  const f = X(d, Xn);
  Ce(f, t.domain, d);
  const p = xn(w2);
  Ce(f, t.tld, p), Ce(f, t.utld, p), X(c, Pl, p);
  const m = X(d, Cn);
  X(m, Cn, m), Ce(m, t.domain, d), Ce(p, t.domain, d), X(p, Xn, f), X(p, Cn, m);
  const g = X(p, fr);
  Ce(g, t.numeric, w2);
  const v = X(s, Cn), y = X(s, Xn);
  X(v, Cn, v), Ce(v, t.domain, s), Ce(y, o, i), Ce(y, t.domain, s);
  const w = xn(eu);
  Ce(y, t.tld, w), Ce(y, t.utld, w), Ce(w, t.domain, s), Ce(w, o, i), X(w, Xn, y), X(w, Cn, v), X(w, ar, c);
  const x = X(w, fr), b = xn(eu);
  Ce(x, t.numeric, b);
  const S = xn(eu), k = xn();
  Ce(S, e, S), Ce(S, n, k), Ce(k, e, S), Ce(k, n, k), X(w, Zn, S), X(b, Zn, S);
  const A = X(a, fr), $ = X(l, fr), O = X($, Zn), M = X(O, Zn);
  Ce(a, t.domain, s), X(a, Xn, y), X(a, Cn, v), Ce(l, t.domain, s), X(l, Xn, y), X(l, Cn, v), Ce(A, t.domain, S), X(A, Zn, S), X(A, Za, S), Ce(M, t.domain, S), Ce(M, e, S), X(M, Zn, S);
  const P = [
    [Ya, Ja],
    // {}
    [wd, xd],
    // []
    [Cd, Sd],
    // ()
    [kd, Ed],
    // <>
    [_d, Ad],
    // （）
    [Td, Od],
    // 「」
    [Md, Id],
    // 『』
    [Rd, $d]
    // ＜＞
  ];
  for (let F = 0; F < P.length; F++) {
    const [J, Q] = P[F], G = X(S, J);
    X(k, J, G), X(G, Q, S);
    const V = xn(eu);
    Ce(G, e, V);
    const B = xn();
    Ce(G, n), Ce(V, e, V), Ce(V, n, B), Ce(B, e, V), Ce(B, n, B), X(V, Q, S), X(B, Q, S);
  }
  return X(r, Pl, w), X(r, Ov, nee), {
    start: r,
    tokens: EE
  };
}
function ree(t, e, n) {
  let o = n.length, r = 0, i = [], s = [];
  for (; r < o; ) {
    let a = t, l = null, c = null, u = 0, d = null, f = -1;
    for (; r < o && !(l = a.go(n[r].t)); )
      s.push(n[r++]);
    for (; r < o && (c = l || a.go(n[r].t)); )
      l = null, a = c, a.accepts() ? (f = 0, d = a) : f >= 0 && f++, r++, u++;
    if (f < 0)
      r -= u, r < o && (s.push(n[r]), r++);
    else {
      s.length > 0 && (i.push(Ch(x2, e, s)), s = []), r -= f, u -= f;
      const p = d.t, m = n.slice(r - u, r);
      i.push(Ch(p, e, m));
    }
  }
  return s.length > 0 && i.push(Ch(x2, e, s)), i;
}
function Ch(t, e, n) {
  const o = n[0].s, r = n[n.length - 1].e, i = e.slice(o, r);
  return new t(i, n);
}
const iee = typeof console < "u" && console && console.warn || (() => {
}), see = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", tt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function aee() {
  return Zt.groups = {}, tt.scanner = null, tt.parser = null, tt.tokenQueue = [], tt.pluginQueue = [], tt.customSchemes = [], tt.initialized = !1, tt;
}
function C2(t, e = !1) {
  if (tt.initialized && iee(`linkifyjs: already initialized - will not register custom scheme "${t}" ${see}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  tt.customSchemes.push([t, e]);
}
function lee() {
  tt.scanner = eee(tt.customSchemes);
  for (let t = 0; t < tt.tokenQueue.length; t++)
    tt.tokenQueue[t][1]({
      scanner: tt.scanner
    });
  tt.parser = oee(tt.scanner.tokens);
  for (let t = 0; t < tt.pluginQueue.length; t++)
    tt.pluginQueue[t][1]({
      scanner: tt.scanner,
      parser: tt.parser
    });
  return tt.initialized = !0, tt;
}
function Dv(t) {
  return tt.initialized || lee(), ree(tt.parser.start, t, _E(tt.scanner.start, t));
}
Dv.scan = _E;
function TE(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const o = new Lv(n), r = Dv(t), i = [];
  for (let s = 0; s < r.length; s++) {
    const a = r[s];
    a.isLink && (!e || a.t === e) && o.check(a) && i.push(a.toFormattedObject(o));
  }
  return i;
}
function cee(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function uee(t) {
  return new De({
    key: new Ne("autolink"),
    appendTransaction: (e, n, o) => {
      const r = e.some((c) => c.docChanged) && !n.doc.eq(o.doc), i = e.some((c) => c.getMeta("preventAutolink"));
      if (!r || i)
        return;
      const { tr: s } = o, a = mT(n.doc, [...e]);
      if (xT(a).forEach(({ newRange: c }) => {
        const u = vT(o.doc, c, (p) => p.isTextblock);
        let d, f;
        if (u.length > 1 ? (d = u[0], f = o.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && o.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (d = u[0], f = o.doc.textBetween(d.pos, c.to, void 0, " ")), d && f) {
          const p = f.split(" ").filter((y) => y !== "");
          if (p.length <= 0)
            return !1;
          const m = p[p.length - 1], g = d.pos + f.lastIndexOf(m);
          if (!m)
            return !1;
          const v = Dv(m).map((y) => y.toObject(t.defaultProtocol));
          if (!cee(v))
            return !1;
          v.filter((y) => y.isLink).map((y) => ({
            ...y,
            from: g + y.start + 1,
            to: g + y.end + 1
          })).filter((y) => o.schema.marks.code ? !o.doc.rangeHasMark(y.from, y.to, o.schema.marks.code) : !0).filter((y) => t.validate(y.value)).filter((y) => t.shouldAutoLink(y.value)).forEach((y) => {
            Xg(y.from, y.to, o.doc).some((w) => w.mark.type === t.type) || s.addMark(y.from, y.to, t.type.create({
              href: y.href
            }));
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function dee(t) {
  return new De({
    key: new Ne("handleClickLink"),
    props: {
      handleClick: (e, n, o) => {
        var r, i;
        if (o.button !== 0 || !e.editable)
          return !1;
        let s = o.target;
        const a = [];
        for (; s.nodeName !== "DIV"; )
          a.push(s), s = s.parentNode;
        if (!a.find((f) => f.nodeName === "A"))
          return !1;
        const l = IC(e.state, t.type.name), c = o.target, u = (r = c == null ? void 0 : c.href) !== null && r !== void 0 ? r : l.href, d = (i = c == null ? void 0 : c.target) !== null && i !== void 0 ? i : l.target;
        return c && u ? (window.open(u, d), !0) : !1;
      }
    }
  });
}
function fee(t) {
  return new De({
    key: new Ne("handlePasteLink"),
    props: {
      handlePaste: (e, n, o) => {
        const { state: r } = e, { selection: i } = r, { empty: s } = i;
        if (s)
          return !1;
        let a = "";
        o.content.forEach((c) => {
          a += c.textContent;
        });
        const l = TE(a, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === a);
        return !a || !l ? !1 : t.editor.commands.setMark(t.type, {
          href: l.href
        });
      }
    }
  });
}
const pee = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function Qr(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((o) => {
    const r = typeof o == "string" ? o : o.scheme;
    r && n.push(r);
  }), !t || t.replace(pee, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const hee = on.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        C2(t);
        return;
      }
      C2(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    aee();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!Qr(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!Qr(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!Qr(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Le(this.options.HTMLAttributes, t), 0] : [
      "a",
      Le(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (o) => !!Qr(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (o) => !!Qr(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1;
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Er({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: o } = this.options, r = TE(t).filter((i) => i.isLink && this.options.isAllowedUri(i.value, {
              defaultValidate: (s) => !!Qr(s, n),
              protocols: n,
              defaultProtocol: o
            }));
            r.length && r.forEach((i) => e.push({
              text: i.value,
              data: {
                href: i.href
              },
              index: i.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(uee({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (o) => this.options.isAllowedUri(o, {
        defaultValidate: (r) => !!Qr(r, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push(dee({
      type: this.type
    })), this.options.linkOnPaste && t.push(fee({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
}), mee = /* @__PURE__ */ I({
  __name: "LinkEditPopover",
  props: {
    editor: {},
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    isActive: { type: Function, default: void 0 },
    action: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    function n(o, r, i) {
      e.action && e.action({ link: o, text: r, openInNewTab: i });
    }
    return (o, r) => (E(), T(h(Vr), null, {
      default: C(() => [
        _(h(jr), { disabled: o.disabled }, {
          default: C(() => [
            _(ge, {
              icon: o.icon,
              tooltip: o.tooltip,
              "is-active": o.isActive,
              disabled: o.disabled
            }, null, 8, ["icon", "tooltip", "is-active", "disabled"])
          ]),
          _: 1
        }, 8, ["disabled"]),
        _(h(Ur), {
          "hide-when-detached": "",
          "as-child": "",
          class: "w-full",
          align: "start",
          side: "bottom"
        }, {
          default: C(() => [
            _(Xk, {
              editor: o.editor,
              onOnSetLink: n
            }, null, 8, ["editor"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), _re = hee.extend({
  inclusive: !1,
  parseHTML() {
    return [
      {
        tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "a",
      Le(this.options.HTMLAttributes, t, {
        class: "link"
      }),
      0
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      openOnClick: !0,
      button: ({ editor: e, t: n }) => ({
        component: mee,
        componentProps: {
          action: (o) => {
            const { link: r, text: i, openInNewTab: s } = o;
            e.chain().extendMarkRange("link").insertContent({
              type: "text",
              text: i,
              marks: [
                {
                  type: "link",
                  attrs: {
                    href: r,
                    target: s ? "_blank" : ""
                  }
                }
              ]
            }).setLink({ href: r }).focus().run();
          },
          isActive: () => e.isActive("link") || !1,
          disabled: !e.isEditable || !e.can().setLink({ href: "" }),
          icon: "Link",
          tooltip: n("editor.link.tooltip")
        }
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      new De({
        props: {
          handleClick: (t, e) => {
            const { schema: n, doc: o, tr: r } = t.state, i = lf(o.resolve(e), n.marks.link);
            if (!i) return !1;
            const s = o.resolve(i.from), a = o.resolve(i.to), l = r.setSelection(new ce(s, a));
            t.dispatch(l);
          }
        }
      })
    ];
  }
}), gee = Ze.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Le(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: o, $to: r } = n, i = t();
        return o.parentOffset === 0 ? i.insertContentAt({
          from: Math.max(o.pos - 1, 0),
          to: r.pos
        }, {
          type: this.name
        }) : RC(n) ? i.insertContentAt(r.pos, {
          type: this.name
        }) : i.insertContent({ type: this.name }), i.command(({ tr: s, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: c } = s.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? s.setSelection(ce.create(s.doc, c.pos + 1)) : c.nodeAfter.isBlock ? s.setSelection(de.create(s.doc, c.pos)) : s.setSelection(ce.create(s.doc, c.pos));
            else {
              const d = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (s.insert(u, d), s.setSelection(ce.create(s.doc, u + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      LC({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), Are = gee.extend({
  renderHTML() {
    return [
      "div",
      Le(this.options.HTMLAttributes, {
        "data-type": this.name
      }),
      ["hr"]
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e == null ? void 0 : e.chain().focus().setHorizontalRule().run(),
          disabled: !(e != null && e.isEditable) || !e.can().setHorizontalRule(),
          icon: "Minus",
          shortcutKeys: ["mod", "alt", "S"],
          tooltip: n("editor.horizontalrule.tooltip")
        }
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-s": () => this.editor.chain().setHorizontalRule().focus().run()
    };
  }
});
var Kd = 200, xt = function() {
};
xt.prototype.append = function(e) {
  return e.length ? (e = xt.from(e), !this.length && e || e.length < Kd && this.leafAppend(e) || this.length < Kd && e.leafPrepend(this) || this.appendInner(e)) : this;
};
xt.prototype.prepend = function(e) {
  return e.length ? xt.from(e).append(this) : this;
};
xt.prototype.appendInner = function(e) {
  return new vee(this, e);
};
xt.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? xt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
xt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
xt.prototype.forEach = function(e, n, o) {
  n === void 0 && (n = 0), o === void 0 && (o = this.length), n <= o ? this.forEachInner(e, n, o, 0) : this.forEachInvertedInner(e, n, o, 0);
};
xt.prototype.map = function(e, n, o) {
  n === void 0 && (n = 0), o === void 0 && (o = this.length);
  var r = [];
  return this.forEach(function(i, s) {
    return r.push(e(i, s));
  }, n, o), r;
};
xt.from = function(e) {
  return e instanceof xt ? e : e && e.length ? new OE(e) : xt.empty;
};
var OE = /* @__PURE__ */ function(t) {
  function e(o) {
    t.call(this), this.values = o;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(r, i) {
    return r == 0 && i == this.length ? this : new e(this.values.slice(r, i));
  }, e.prototype.getInner = function(r) {
    return this.values[r];
  }, e.prototype.forEachInner = function(r, i, s, a) {
    for (var l = i; l < s; l++)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, a) {
    for (var l = i - 1; l >= s; l--)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(r) {
    if (this.length + r.length <= Kd)
      return new e(this.values.concat(r.flatten()));
  }, e.prototype.leafPrepend = function(r) {
    if (this.length + r.length <= Kd)
      return new e(r.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(xt);
xt.empty = new OE([]);
var vee = /* @__PURE__ */ function(t) {
  function e(n, o) {
    t.call(this), this.left = n, this.right = o, this.length = n.length + o.length, this.depth = Math.max(n.depth, o.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(o) {
    return o < this.left.length ? this.left.get(o) : this.right.get(o - this.left.length);
  }, e.prototype.forEachInner = function(o, r, i, s) {
    var a = this.left.length;
    if (r < a && this.left.forEachInner(o, r, Math.min(i, a), s) === !1 || i > a && this.right.forEachInner(o, Math.max(r - a, 0), Math.min(this.length, i) - a, s + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(o, r, i, s) {
    var a = this.left.length;
    if (r > a && this.right.forEachInvertedInner(o, r - a, Math.max(i, a) - a, s + a) === !1 || i < a && this.left.forEachInvertedInner(o, Math.min(r, a), i, s) === !1)
      return !1;
  }, e.prototype.sliceInner = function(o, r) {
    if (o == 0 && r == this.length)
      return this;
    var i = this.left.length;
    return r <= i ? this.left.slice(o, r) : o >= i ? this.right.slice(o - i, r - i) : this.left.slice(o, i).append(this.right.slice(0, r - i));
  }, e.prototype.leafAppend = function(o) {
    var r = this.right.leafAppend(o);
    if (r)
      return new e(this.left, r);
  }, e.prototype.leafPrepend = function(o) {
    var r = this.left.leafPrepend(o);
    if (r)
      return new e(r, this.right);
  }, e.prototype.appendInner = function(o) {
    return this.left.depth >= Math.max(this.right.depth, o.depth) + 1 ? new e(this.left, new e(this.right, o)) : new e(this, o);
  }, e;
}(xt);
const yee = 500;
class Hn {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let o = this.items.length;
    for (; ; o--)
      if (this.items.get(o - 1).selection) {
        --o;
        break;
      }
    let r, i;
    n && (r = this.remapping(o, this.items.length), i = r.maps.length);
    let s = e.tr, a, l, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        r || (r = this.remapping(o, f + 1), i = r.maps.length), i--, u.push(d);
        return;
      }
      if (r) {
        u.push(new Qn(d.map));
        let p = d.step.map(r.slice(i)), m;
        p && s.maybeStep(p).doc && (m = s.mapping.maps[s.mapping.maps.length - 1], c.push(new Qn(m, void 0, void 0, c.length + u.length))), i--, m && r.appendMap(m, i);
      } else
        s.maybeStep(d.step);
      if (d.selection)
        return a = r ? d.selection.map(r.slice(i)) : d.selection, l = new Hn(this.items.slice(0, o).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, o, r) {
    let i = [], s = this.eventCount, a = this.items, l = !r && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new Qn(e.mapping.maps[u], d, n), p;
      (p = l && l.merge(f)) && (f = p, u ? i.pop() : a = a.slice(0, a.length - 1)), i.push(f), n && (s++, n = void 0), r || (l = f);
    }
    let c = s - o.depth;
    return c > wee && (a = bee(a, c), s -= c), new Hn(a.append(i), s);
  }
  remapping(e, n) {
    let o = new rl();
    return this.items.forEach((r, i) => {
      let s = r.mirrorOffset != null && i - r.mirrorOffset >= e ? o.maps.length - r.mirrorOffset : void 0;
      o.appendMap(r.map, s);
    }, e, n), o;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Hn(this.items.append(e.map((n) => new Qn(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let o = [], r = Math.max(0, this.items.length - n), i = e.mapping, s = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, r);
    let l = n;
    this.items.forEach((f) => {
      let p = i.getMirror(--l);
      if (p == null)
        return;
      s = Math.min(s, p);
      let m = i.maps[p];
      if (f.step) {
        let g = e.steps[p].invert(e.docs[p]), v = f.selection && f.selection.map(i.slice(l + 1, p));
        v && a++, o.push(new Qn(m, g, v));
      } else
        o.push(new Qn(m));
    }, r);
    let c = [];
    for (let f = n; f < s; f++)
      c.push(new Qn(i.maps[f]));
    let u = this.items.slice(0, r).append(c).append(o), d = new Hn(u, a);
    return d.emptyItemCount() > yee && (d = d.compress(this.items.length - o.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), o = n.maps.length, r = [], i = 0;
    return this.items.forEach((s, a) => {
      if (a >= e)
        r.push(s), s.selection && i++;
      else if (s.step) {
        let l = s.step.map(n.slice(o)), c = l && l.getMap();
        if (o--, c && n.appendMap(c, o), l) {
          let u = s.selection && s.selection.map(n.slice(o));
          u && i++;
          let d = new Qn(c.invert(), l, u), f, p = r.length - 1;
          (f = r.length && r[p].merge(d)) ? r[p] = f : r.push(d);
        }
      } else s.map && o--;
    }, this.items.length, 0), new Hn(xt.from(r.reverse()), i);
  }
}
Hn.empty = new Hn(xt.empty, 0);
function bee(t, e) {
  let n;
  return t.forEach((o, r) => {
    if (o.selection && e-- == 0)
      return n = r, !1;
  }), t.slice(n);
}
class Qn {
  constructor(e, n, o, r) {
    this.map = e, this.step = n, this.selection = o, this.mirrorOffset = r;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Qn(n.getMap().invert(), n, this.selection);
    }
  }
}
class lr {
  constructor(e, n, o, r, i) {
    this.done = e, this.undone = n, this.prevRanges = o, this.prevTime = r, this.prevComposition = i;
  }
}
const wee = 20;
function xee(t, e, n, o) {
  let r = n.getMeta(yi), i;
  if (r)
    return r.historyState;
  n.getMeta(kee) && (t = new lr(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (s && s.getMeta(yi))
    return s.getMeta(yi).redo ? new lr(t.done.addTransform(n, void 0, o, Tu(e)), t.undone, S2(n.mapping.maps), t.prevTime, t.prevComposition) : new lr(t.done, t.undone.addTransform(n, void 0, o, Tu(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !s && t.prevComposition != a && (t.prevTime < (n.time || 0) - o.newGroupDelay || !Cee(n, t.prevRanges)), c = s ? Sh(t.prevRanges, n.mapping) : S2(n.mapping.maps);
    return new lr(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, o, Tu(e)), Hn.empty, c, n.time, a ?? t.prevComposition);
  } else return (i = n.getMeta("rebased")) ? new lr(t.done.rebased(n, i), t.undone.rebased(n, i), Sh(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new lr(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), Sh(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function Cee(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((o, r) => {
    for (let i = 0; i < e.length; i += 2)
      o <= e[i + 1] && r >= e[i] && (n = !0);
  }), n;
}
function S2(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((o, r, i, s) => e.push(i, s));
  return e;
}
function Sh(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let o = 0; o < t.length; o += 2) {
    let r = e.map(t[o], 1), i = e.map(t[o + 1], -1);
    r <= i && n.push(r, i);
  }
  return n;
}
function See(t, e, n) {
  let o = Tu(e), r = yi.get(e).spec.config, i = (n ? t.undone : t.done).popEvent(e, o);
  if (!i)
    return null;
  let s = i.selection.resolve(i.transform.doc), a = (n ? t.done : t.undone).addTransform(i.transform, e.selection.getBookmark(), r, o), l = new lr(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
  return i.transform.setSelection(s).setMeta(yi, { redo: n, historyState: l });
}
let kh = !1, k2 = null;
function Tu(t) {
  let e = t.plugins;
  if (k2 != e) {
    kh = !1, k2 = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        kh = !0;
        break;
      }
  }
  return kh;
}
const yi = new Ne("history"), kee = new Ne("closeHistory");
function Eee(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new De({
    key: yi,
    state: {
      init() {
        return new lr(Hn.empty, Hn.empty, null, 0, -1);
      },
      apply(e, n, o) {
        return xee(n, o, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let o = n.inputType, r = o == "historyUndo" ? IE : o == "historyRedo" ? RE : null;
          return r ? (n.preventDefault(), r(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function ME(t, e) {
  return (n, o) => {
    let r = yi.getState(n);
    if (!r || (t ? r.undone : r.done).eventCount == 0)
      return !1;
    if (o) {
      let i = See(r, n, t);
      i && o(e ? i.scrollIntoView() : i);
    }
    return !0;
  };
}
const IE = ME(!1, !0), RE = ME(!0, !0), _ee = ke.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => IE(t, e),
      redo: () => ({ state: t, dispatch: e }) => RE(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      Eee(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), Tre = _ee.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      depth: 10,
      button: ({ editor: e, t: n }) => ["undo", "redo"].map((r) => ({
        component: ge,
        componentProps: {
          action: () => {
            r === "undo" && (e == null || e.chain().undo().focus().run()), r === "redo" && (e == null || e.chain().redo().focus().run());
          },
          shortcutKeys: r === "undo" ? ["mod", "Z"] : ["shift", "mod", "Z"],
          disabled: !(e != null && e.isEditable) || !e.can()[r](),
          icon: r === "undo" ? "Undo2" : "Redo2",
          tooltip: n(`editor.${r}.tooltip`)
        }
      }))
    };
  }
}), { isFullscreen: Eh, toggleFullscreen: _h } = vn(), Ore = ke.create({
  name: "fullscreen",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ge,
        componentProps: {
          tooltip: Eh.value ? o("editor.fullscreen.tooltip.exit") : o("editor.fullscreen.tooltip.fullscreen"),
          action: () => e == null ? void 0 : e.chain().setFullscreen().focus().run(),
          icon: Eh.value ? "Minimize" : "Maximize",
          isActive: () => Eh.value
        }
      })
    };
  },
  addCommands() {
    return {
      setFullscreen: () => () => (_h(), !0)
    };
  },
  addKeyboardShortcuts() {
    return {
      F11: () => (_h(), !0),
      "Mod-F11": () => (_h(), !0)
    };
  }
}), Aee = ke.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
      if (((t == null ? void 0 : t.mode) || this.options.mode) === "textSize") {
        const o = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(o);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new De({
        key: new Ne("characterCount"),
        appendTransaction: (e, n, o) => {
          if (t)
            return;
          const r = this.options.limit;
          if (r == null || r === 0) {
            t = !0;
            return;
          }
          const i = this.storage.characters({ node: o.doc });
          if (i > r) {
            const s = i - r, a = 0, l = s;
            console.warn(`[CharacterCount] Initial content exceeded limit of ${r} characters. Content was automatically trimmed.`);
            const c = o.tr.deleteRange(a, l);
            return t = !0, c;
          }
          t = !0;
        },
        filterTransaction: (e, n) => {
          const o = this.options.limit;
          if (!e.docChanged || o === 0 || o === null || o === void 0)
            return !0;
          const r = this.storage.characters({ node: n.doc }), i = this.storage.characters({ node: e.doc });
          if (i <= o || r > o && i > o && i <= r)
            return !0;
          if (r > o && i > o && i > r || !e.getMeta("paste"))
            return !1;
          const a = e.selection.$head.pos, l = i - o, c = a - l, u = a;
          return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > o);
        }
      })
    ];
  }
}), Tee = Ze.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), Oee = Tee.extend({
  content() {
    var e;
    return !!((e = this.editor) != null && e.options.extensions.find((n) => n.name === "columns")) ? "(block|columns)+" : "block+";
  }
});
function Mee(t = {}) {
  return new De({
    view(e) {
      return new Iee(e, t);
    }
  });
}
class Iee {
  constructor(e, n) {
    var o;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (o = n.width) !== null && o !== void 0 ? o : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((r) => {
      let i = (s) => {
        this[r](s);
      };
      return e.dom.addEventListener(r, i), { name: r, handler: i };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, o;
    if (n) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (c) {
          let u = c.getBoundingClientRect(), d = a ? u.bottom : u.top;
          a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), o = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!o) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      o = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let r = this.editorView.dom.offsetParent;
    this.element || (this.element = r.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let i, s;
    if (!r || r == document.body && getComputedStyle(r).position == "static")
      i = -pageXOffset, s = -pageYOffset;
    else {
      let a = r.getBoundingClientRect();
      i = a.left - r.scrollLeft, s = a.top - r.scrollTop;
    }
    this.element.style.left = o.left - i + "px", this.element.style.top = o.top - s + "px", this.element.style.width = o.right - o.left + "px", this.element.style.height = o.bottom - o.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), o = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), r = o && o.type.spec.disableDropCursor, i = typeof r == "function" ? r(this.editorView, n, e) : r;
    if (n && !i) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = Sx(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const Ree = ke.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      Mee(this.options)
    ];
  }
}), $ee = ke.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: o } = this.editor, { anchor: r } = e, i = [];
            if (!n || !o)
              return Te.create(t, []);
            let s = 0;
            this.options.mode === "deepest" && t.descendants((l, c) => {
              if (l.isText)
                return;
              if (!(r >= c && r <= c + l.nodeSize - 1))
                return !1;
              s += 1;
            });
            let a = 0;
            return t.descendants((l, c) => {
              if (l.isText || !(r >= c && r <= c + l.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              i.push(ft.node(c, c + l.nodeSize, {
                class: this.options.className
              }));
            }), Te.create(t, i);
          }
        }
      })
    ];
  }
});
class ut extends fe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let o = e.resolve(n.map(this.head));
    return ut.valid(o) ? new ut(o) : fe.near(o);
  }
  content() {
    return te.empty;
  }
  eq(e) {
    return e instanceof ut && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new ut(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Nv(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !Pee(e) || !Lee(e))
      return !1;
    let o = n.type.spec.allowGapCursor;
    if (o != null)
      return o;
    let r = n.contentMatchAt(e.index()).defaultType;
    return r && r.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, o = !1) {
    e: for (; ; ) {
      if (!o && ut.valid(e))
        return e;
      let r = e.pos, i = null;
      for (let s = e.depth; ; s--) {
        let a = e.node(s);
        if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
          i = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        r += n;
        let l = e.doc.resolve(r);
        if (ut.valid(l))
          return l;
      }
      for (; ; ) {
        let s = n > 0 ? i.firstChild : i.lastChild;
        if (!s) {
          if (i.isAtom && !i.isText && !de.isSelectable(i)) {
            e = e.doc.resolve(r + i.nodeSize * n), o = !1;
            continue e;
          }
          break;
        }
        i = s, r += n;
        let a = e.doc.resolve(r);
        if (ut.valid(a))
          return a;
      }
      return null;
    }
  }
}
ut.prototype.visible = !1;
ut.findFrom = ut.findGapCursorFrom;
fe.jsonID("gapcursor", ut);
class Nv {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Nv(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return ut.valid(n) ? new ut(n) : fe.near(n);
  }
}
function Pee(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), o = t.node(e);
    if (n == 0) {
      if (o.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = o.child(n - 1); ; r = r.lastChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Lee(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), o = t.node(e);
    if (n == o.childCount) {
      if (o.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = o.child(n); ; r = r.firstChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Dee() {
  return new De({
    props: {
      decorations: zee,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && ut.valid(n) ? new ut(n) : null;
      },
      handleClick: Bee,
      handleKeyDown: Nee,
      handleDOMEvents: { beforeinput: Fee }
    }
  });
}
const Nee = zg({
  ArrowLeft: tu("horiz", -1),
  ArrowRight: tu("horiz", 1),
  ArrowUp: tu("vert", -1),
  ArrowDown: tu("vert", 1)
});
function tu(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(o, r, i) {
    let s = o.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
    if (s instanceof ce) {
      if (!i.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = o.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = ut.findGapCursorFrom(a, e, l);
    return c ? (r && r(o.tr.setSelection(new ut(c))), !0) : !1;
  };
}
function Bee(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let o = t.state.doc.resolve(e);
  if (!ut.valid(o))
    return !1;
  let r = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return r && r.inside > -1 && de.isSelectable(t.state.doc.nodeAt(r.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new ut(o))), !0);
}
function Fee(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof ut))
    return !1;
  let { $from: n } = t.state.selection, o = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!o)
    return !1;
  let r = K.empty;
  for (let s = o.length - 1; s >= 0; s--)
    r = K.from(o[s].createAndFill(null, r));
  let i = t.state.tr.replace(n.pos, n.pos, new te(r, 0, 0));
  return i.setSelection(ce.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function zee(t) {
  if (!(t.selection instanceof ut))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Te.create(t.doc, [ft.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const Hee = ke.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      Dee()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = Se(ie(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), Vee = Ze.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Le(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: o }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: r, storedMarks: i } = n;
          if (r.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = o.extensionManager, l = i || r.$to.parentOffset && r.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && s) {
              const d = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), Uee = Ze.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Le(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), jee = Ze.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), Wee = ke.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: o } = e, r = [];
            if (!n)
              return null;
            const i = this.editor.isEmpty;
            return t.descendants((s, a) => {
              const l = o >= a && o <= a + s.nodeSize, c = !s.isLeaf && ff(s);
              if ((l || !this.options.showOnlyCurrent) && c) {
                const u = [this.options.emptyNodeClass];
                i && u.push(this.options.emptyEditorClass);
                const d = ft.node(a, a + s.nodeSize, {
                  class: u.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: s,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                r.push(d);
              }
              return this.options.includeChildren;
            }), Te.create(t, r);
          }
        }
      })
    ];
  }
}), Kee = Ze.create({
  name: "text",
  group: "inline"
});
function E2({ types: t, node: e }) {
  return Array.isArray(t) && t.includes(e.type) || e.type === t;
}
const Gee = ke.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: ["paragraph"]
    };
  },
  addProseMirrorPlugins() {
    const t = new Ne(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => this.options.notAfter.includes(n.name));
    return [
      new De({
        key: t,
        appendTransaction: (n, o, r) => {
          const { doc: i, tr: s, schema: a } = r, l = t.getState(r), c = i.content.size, u = a.nodes[this.options.node];
          if (l)
            return s.insert(c, u.create());
        },
        state: {
          init: (n, o) => {
            const r = o.tr.doc.lastChild;
            return !E2({ node: r, types: e });
          },
          apply: (n, o) => {
            if (!n.docChanged)
              return o;
            const r = n.doc.lastChild;
            return !E2({ node: r, types: e });
          }
        }
      })
    ];
  }
}), qee = ke.create({
  name: "selection",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new De({
        key: new Ne("selection"),
        props: {
          decorations(e) {
            return e.selection.empty || t.isFocused === !0 ? null : Te.create(e.doc, [
              ft.inline(e.selection.from, e.selection.to, {
                class: "selection"
              })
            ]);
          }
        }
      })
    ];
  }
}), nu = new Ne("highlight-paragraph"), Yee = ke.create({
  name: "highlight-paragraph",
  addCommands() {
    return {
      setHighlightParagraph: (t) => ({ editor: e }) => (e.view.dispatch(e.view.state.tr.setMeta(nu, t)), !1),
      clearHighlightParagraph: () => ({ editor: t }) => (t.view.dispatch(t.view.state.tr.setMeta(nu, null)), !1)
    };
  },
  addProseMirrorPlugins() {
    return [
      new De({
        key: nu,
        state: {
          init() {
            return Te.empty;
          },
          apply(t, e) {
            const n = t.getMeta(nu);
            if (n === void 0)
              return e.map(t.mapping, t.doc);
            if (n === null)
              return Te.empty;
            const o = t.doc.nodeAt(n);
            return o ? Te.create(t.doc, [
              ft.node(n, n + o.nodeSize, {
                class: "highlight-paragraph"
              })
            ]) : Te.empty;
          }
        },
        props: {
          decorations(t) {
            return this.getState(t);
          }
        }
      })
    ];
  }
}), Jee = (t) => {
  const e = ["size-small", "size-medium", "size-large"], n = ["SizeS", "SizeM", "SizeL"];
  return e.map((o, r) => ({
    type: `video-${o}`,
    component: ge,
    componentProps: {
      tooltip: `editor.${o.replace("-", ".")}.tooltip`,
      icon: n[r],
      action: () => t.commands.updateVideo({ width: Wu[o] }),
      isActive: () => t.isActive("video", { width: Wu[o] })
    }
  }));
}, Xee = (t) => [
  ...Jee(t),
  {
    type: "remove",
    component: ge,
    componentProps: {
      tooltip: "editor.remove",
      icon: "Trash2",
      action: () => {
        const { state: e, dispatch: n } = t.view;
        zl(e, n);
      }
    }
  }
], Zee = (t, e, { editor: n, extension: o, t: r }) => {
  const { extensions: i = [] } = n.extensionManager, s = {};
  for (const a of Object.keys(t)) {
    const l = t[a];
    if (!l) continue;
    const c = [];
    for (const f of l) {
      if (f === "divider") {
        const g = c[c.length - 1];
        if ((g == null ? void 0 : g.type) === "divider") continue;
        c.push({
          type: "divider",
          component: void 0,
          componentProps: {}
        });
        continue;
      }
      const p = e.find((g) => g.type === f);
      if (p) {
        c.push({
          ...p,
          componentProps: {
            ...p.componentProps,
            tooltip: p.componentProps.tooltip ? r(p.componentProps.tooltip) : void 0
          },
          componentSlots: p.componentSlots
        });
        continue;
      }
      const m = i.find((g) => g.name === f);
      if (m) {
        const { button: g } = m.options, v = g({
          editor: n,
          extension: m,
          t: r
        });
        c.push({
          type: f,
          component: v.component,
          componentProps: v.componentProps,
          componentSlots: v.componentSlots
        });
        continue;
      }
    }
    const u = c[c.length - 1], d = c[0];
    (u == null ? void 0 : u.type) === "divider" && c.pop(), (d == null ? void 0 : d.type) === "divider" && c.shift(), s[a] = c;
  }
  return s;
}, Qee = { class: "flex items-center gap-2 px-2" }, ete = /* @__PURE__ */ I({
  __name: "TextDropdown",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    maxHeight: { default: void 0 },
    icon: { default: void 0 },
    tooltip: { default: "" }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = L(() => [
      {
        name: "paragraph",
        label: n.value("editor.paragraph.tooltip"),
        iconName: "Paragraph",
        isActive: () => e.editor.isActive("paragraph") && !e.editor.isActive("orderedList") && !e.editor.isActive("bulletList") && !e.editor.isActive("taskList"),
        action: () => e.editor.chain().focus().clearNodes().focus().run()
      },
      {
        name: "heading1",
        label: n.value("editor.heading.h1.tooltip"),
        isActive: () => e.editor.isActive("heading", { level: 1 }),
        iconName: "Heading1",
        action: () => e.editor.chain().focus().clearNodes().toggleHeading({ level: 1 }).focus().run()
      },
      {
        name: "heading2",
        label: n.value("editor.heading.h2.tooltip"),
        isActive: () => e.editor.isActive("heading", { level: 2 }),
        iconName: "Heading2",
        action: () => e.editor.chain().focus().clearNodes().toggleHeading({ level: 2 }).focus().run()
      },
      {
        name: "heading3",
        label: n.value("editor.heading.h3.tooltip"),
        isActive: () => e.editor.isActive("heading", { level: 3 }),
        iconName: "Heading3",
        action: () => e.editor.chain().focus().clearNodes().toggleHeading({ level: 3 }).focus().run()
      },
      {
        name: "bulletList",
        label: n.value("editor.bulletlist.tooltip"),
        isActive: () => e.editor.isActive("bulletList"),
        iconName: "List",
        action: () => e.editor.chain().focus().clearNodes().toggleBulletList().focus().run()
      },
      {
        name: "numberedList",
        label: n.value("editor.orderedlist.tooltip"),
        isActive: () => e.editor.isActive("orderedList"),
        iconName: "ListOrdered",
        action: () => e.editor.chain().focus().clearNodes().toggleOrderedList().focus().run()
      },
      {
        name: "taskList",
        label: n.value("editor.tasklist.tooltip"),
        isActive: () => e.editor.isActive("taskList"),
        iconName: "ListTodo",
        action: () => e.editor.chain().focus().clearNodes().toggleTaskList().focus().run()
      },
      {
        name: "blockquote",
        label: n.value("editor.blockquote.tooltip"),
        isActive: () => e.editor.isActive("blockquote"),
        iconName: "TextQuote",
        action: () => e.editor.chain().focus().clearNodes().toggleBlockquote().focus().run()
      },
      {
        name: "codeBlock",
        label: n.value("editor.codeblock.tooltip"),
        isActive: () => e.editor.isActive("codeBlock"),
        iconName: "Code2",
        action: () => e.editor.chain().focus().clearNodes().setCodeBlock().focus().run()
      }
    ]), r = L(() => o.value.filter((i) => i.isActive()).pop() ?? {
      label: n.value("editor.modify")
    });
    return (i, s) => {
      var a;
      return E(), T(Bi, {
        title: (a = r.value) == null ? void 0 : a.label,
        sideOffset: 5
      }, {
        default: C(() => [
          (E(!0), W(me, null, Oe(o.value, (l, c) => {
            var u;
            return E(), T(h(na), {
              key: c,
              onClick: l.action,
              class: "cursor-pointer",
              modelValue: ((u = l.isActive) == null ? void 0 : u.call(l)) || !1
            }, {
              default: C(() => [
                N("div", Qee, [
                  _(h(ye), {
                    name: l.iconName,
                    class: "h3 w-3"
                  }, null, 8, ["name"]),
                  N("span", null, Y(l.label), 1)
                ])
              ]),
              _: 2
            }, 1032, ["onClick", "modelValue"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["title"]);
    };
  }
}), tte = ke.create({
  name: "text-bubble",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: () => ({
        component: ete,
        componentProps: {}
      })
    };
  }
}), Mre = ke.create({
  name: "base-kit",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      bubble: {
        list: HO,
        defaultBubbleList: Xee,
        button: ({ editor: e, extension: n, t: o }) => {
          var a;
          const { list: r = {}, defaultBubbleList: i } = ((a = n.options) == null ? void 0 : a.bubble) ?? {}, s = (i == null ? void 0 : i(e)) ?? [];
          return Zee(r, s, {
            editor: e,
            extension: n,
            t: o
          });
        }
      }
    };
  },
  addExtensions() {
    const { t } = Ge(), e = [];
    return this.options.placeholder !== !1 && e.push(
      Wee.configure({
        placeholder: ({ node: n, pos: o, editor: r }) => {
          var a;
          const i = (a = n == null ? void 0 : n.type) == null ? void 0 : a.name;
          if (i === "heading")
            return `${t.value(`editor.heading.h${n.attrs.level}.tooltip`)}`;
          if (i === "table" || i === "codeBlock" || i === "bulletList" || i === "orderedList")
            return "";
          const s = r.extensionManager.extensions.some(
            (l) => l.name === "slashCommand"
          );
          return o === 0 || !s ? t.value("editor.content") : t.value("editor.slash");
        },
        ...this.options.placeholder
      })
    ), this.options.focus !== !1 && e.push(
      $ee.configure({
        className: "focus",
        ...this.options.focus
      })
    ), this.options.document !== !1 && e.push(Oee.configure()), this.options.text !== !1 && e.push(Kee.configure()), this.options.textBubble !== !1 && e.push(tte.configure()), this.options.gapcursor !== !1 && e.push(Hee.configure()), this.options.dropcursor !== !1 && e.push(
      Ree.configure({
        ...this.options.dropcursor,
        width: 2,
        class: "ProseMirror-dropcursor border-black"
      })
    ), this.options.characterCount !== !1 && e.push(Aee.configure(this.options.characterCount)), this.options.paragraph !== !1 && e.push(jee.configure(this.options.paragraph)), this.options.hardBreak !== !1 && e.push(Vee.configure(this.options.hardBreak)), this.options.listItem !== !1 && e.push(Uee.configure(this.options.listItem)), this.options.textStyle !== !1 && e.push(CQ.configure(this.options.textStyle)), this.options.trailingNode !== !1 && e.push(Gee.configure(this.options.trailingNode)), this.options.selection !== !1 && e.push(qee), this.options.highlightParagraph !== !1 && e.push(Yee), e;
  }
}), $E = on.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), PE = on.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", Le(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), Ire = ke.create({
  name: "subAndSuperScript",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => {
        const r = n.options.subscript, i = n.options.superscript, s = {
          component: ge,
          componentProps: {
            action: () => e.chain().toggleSubscript().focus().run(),
            isActive: () => e.isActive("subscript") || !1,
            disabled: !e.isEditable || !e.can().toggleSubscript(),
            icon: "Subscript",
            tooltip: o("editor.subscript.tooltip")
          }
        }, a = {
          component: ge,
          componentProps: {
            action: () => e.chain().toggleSuperscript().focus().run(),
            isActive: () => e.isActive("superscript") || !1,
            disabled: !e.isEditable || !e.can().toggleSuperscript(),
            icon: "Superscript",
            tooltip: o("editor.superscript.tooltip")
          }
        }, l = [];
        return r !== !1 && l.push(s), i !== !1 && l.push(a), l;
      }
    };
  },
  addExtensions() {
    const t = [];
    return this.options.subscript !== !1 && t.push($E.configure(this.options.subscript)), this.options.superscript !== !1 && t.push(PE.configure(this.options.superscript)), t;
  }
}), nte = { class: "ml-1" }, ote = /* @__PURE__ */ I({
  __name: "ActionMoreButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    maxHeight: { default: void 0 },
    icon: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, n = L(() => {
      const o = e.items.find((i) => i.isActive());
      return o && !o.default ? {
        ...o,
        icon: o.icon ? o.icon : e.icon
      } : {
        title: e.tooltip,
        icon: e.icon,
        isActive: () => !1
      };
    });
    return (o, r) => (E(), T(Bi, {
      icon: o.icon,
      tooltip: o.tooltip,
      disabled: o.disabled
    }, {
      default: C(() => [
        (E(!0), W(me, null, Oe(e.items, (i, s) => (E(), T(h(na), {
          "model-value": n.value.title === i.title,
          onClick: i.action,
          key: s,
          disabled: i.disabled,
          class: "flex gap-3 items-center"
        }, {
          default: C(() => [
            i.icon ? (E(), T(h(ye), {
              key: 0,
              name: i.icon
            }, null, 8, ["name"])) : oe("", !0),
            N("span", nte, Y(i.title), 1),
            i.shortcutKeys ? (E(), T(h(j3), {
              key: 1,
              class: "ml-auto"
            }, {
              default: C(() => [
                ue(Y(h(Ro)(i.shortcutKeys)), 1)
              ]),
              _: 2
            }, 1024)) : oe("", !0)
          ]),
          _: 2
        }, 1032, ["model-value", "onClick", "disabled"]))), 128))
      ]),
      _: 1
    }, 8, ["icon", "tooltip", "disabled"]));
  }
}), Rre = ke.create({
  name: "moreMark",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, extension: n, t: o }) {
        const r = n.options.subscript, i = n.options.superscript, s = {
          action: () => e.chain().toggleSubscript().focus().run(),
          isActive: () => e.isActive("subscript") || !1,
          disabled: !e.isEditable || !e.can().toggleSubscript(),
          icon: "Subscript",
          title: o("editor.subscript.tooltip"),
          shortcutKeys: ["mod", "."]
        }, a = {
          action: () => e.chain().toggleSuperscript().focus().run(),
          isActive: () => e.isActive("superscript") || !1,
          disabled: !e.isEditable || !e.can().toggleSuperscript(),
          icon: "Superscript",
          title: o("editor.superscript.tooltip"),
          shortcutKeys: ["mod", ","]
        }, l = Fe(e, "code"), c = [];
        if (r !== !1 && c.push(s), i !== !1 && c.push(a), l) {
          const u = {
            action: () => e.chain().toggleCode().focus().run(),
            isActive: () => e.isActive("code") || !1,
            disabled: !e.isEditable || !e.can().toggleCode(),
            icon: "Code",
            title: o("editor.code.tooltip"),
            shortcutKeys: ["mod", "E"]
          };
          l && c.push(u);
        }
        return {
          component: ote,
          componentProps: {
            icon: "Type",
            tooltip: o("editor.moremark"),
            disabled: !e.isEditable || c.every((u) => u.disabled),
            items: c
          }
        };
      }
    };
  },
  addExtensions() {
    const t = [];
    return this.options.subscript !== !1 && t.push($E.configure(this.options.subscript)), this.options.superscript !== !1 && t.push(PE.configure(this.options.superscript)), t;
  }
}), $re = ke.create({
  name: "indent",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["paragraph", "heading", "blockquote"],
      minIndent: Io.min,
      maxIndent: Io.max,
      button({ editor: e, t: n }) {
        var i, s;
        const { selection: o } = e.state, r = o.$anchor.parent;
        return [
          {
            component: ge,
            componentProps: {
              action: () => {
                e.chain().indent().focus().run();
              },
              disabled: !(e != null && e.isEditable) || ((i = r == null ? void 0 : r.attrs) == null ? void 0 : i.indent) >= Io.max || !e.can().indent(),
              shortcutKeys: ["Tab"],
              icon: "IndentIncrease",
              tooltip: n("editor.indent.tooltip")
            }
          },
          {
            component: ge,
            componentProps: {
              action: () => {
                e.chain().outdent().focus().run();
              },
              shortcutKeys: ["Shift", "Tab"],
              disabled: !(e != null && e.isEditable) || ((s = r == null ? void 0 : r.attrs) == null ? void 0 : s.indent) <= Io.min || !e.can().outdent(),
              icon: "IndentDecrease",
              tooltip: n("editor.outdent.tooltip")
            }
          }
        ];
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          indent: {
            default: 0,
            parseHTML: (t) => {
              const e = t.getAttribute("data-indent");
              return (e ? parseInt(e, 10) : 0) || 0;
            },
            renderHTML: (t) => t.indent ? { "data-indent": t.indent } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      indent: () => Aw({
        delta: Io.more,
        types: this.options.types
      }),
      outdent: () => Aw({
        delta: Io.less,
        types: this.options.types
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.indent(),
      "Shift-Tab": () => this.editor.commands.outdent()
    };
  }
}), rte = ["paragraph", "heading", "list_item", "todo_item"];
function ite(t, e) {
  const { selection: n, doc: o } = t;
  if (!n || !o || !(n instanceof ce || n instanceof Wt))
    return t;
  const { from: r, to: i } = n, s = [], a = e && e !== lS ? e : null;
  return o.nodesBetween(r, i, (l, c) => {
    const u = l.type;
    return rte.includes(u.name) ? ((l.attrs.lineHeight || null) !== a && s.push({
      node: l,
      pos: c,
      nodeType: u
    }), u.name !== "list_item" && u.name !== "todo_item") : !0;
  }), s.length && s.forEach((l) => {
    const { node: c, pos: u, nodeType: d } = l;
    let { attrs: f } = c;
    f = {
      ...f,
      lineHeight: a
    }, t = t.setNodeMarkup(u, d, f, c.marks);
  }), t;
}
function ste(t) {
  return ({ state: e, dispatch: n }) => {
    const { selection: o } = e;
    let { tr: r } = e;
    return r = r.setSelection(o), r = ite(r, t), r.docChanged ? (n && n(r), !0) : !1;
  };
}
const ate = /* @__PURE__ */ I({
  __name: "LineHeightDropdown",
  props: {
    editor: {},
    icon: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const { t: e } = Ge();
    function n(a) {
      return parseFloat(a.replace("%", "")) / 100;
    }
    const o = L(() => {
      const c = i.editor.extensionManager.extensions.find((u) => u.name === "lineHeight").options.lineHeights.map((u) => ({
        label: n(u),
        value: u
      }));
      return c.unshift({
        label: h(e)("editor.default"),
        value: "default"
      }), c;
    }), r = R("default"), i = t;
    function s(a) {
      a === "default" ? i.editor.chain().unsetLineHeight().focus().run() : i.editor.chain().setLineHeight(a).focus().run(), r.value = a;
    }
    return (a, l) => (E(), T(Bi, {
      icon: a.icon,
      tooltip: a.tooltip,
      disabled: a.disabled
    }, {
      default: C(() => [
        (E(!0), W(me, null, Oe(o.value, (c, u) => (E(), T(h(na), {
          key: u,
          modelValue: c.value === r.value,
          onSelect: (d) => s(c.value)
        }, {
          default: C(() => [
            ue(Y(c.label), 1)
          ]),
          _: 2
        }, 1032, ["modelValue", "onSelect"]))), 128))
      ]),
      _: 1
    }, 8, ["icon", "tooltip", "disabled"]));
  }
}), Pre = ke.create({
  name: "lineHeight",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["paragraph", "heading", "list_item", "todo_item"],
      lineHeights: ["100%", "115%", "150%", "200%", "250%", "300%"],
      defaultHeight: lS,
      button({ editor: e, t: n }) {
        return {
          component: ate,
          componentProps: {
            editor: e,
            disabled: !e.isEditable || !e.can().setLineHeight("400%"),
            icon: "LineHeight",
            tooltip: n("editor.lineheight.tooltip")
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (t) => t.style.lineHeight || this.options.defaultHeight,
            renderHTML: (t) => t.lineHeight === this.options.defaultHeight || !t.lineHeight ? {} : { style: `line-height: ${t.lineHeight}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (t) => ste(t),
      unsetLineHeight: () => ({ commands: t }) => this.options.types.every((e) => t.resetAttributes(e, "lineHeight"))
    };
  }
});
function lte(t) {
  var e;
  const { char: n, allowSpaces: o, allowToIncludeChar: r, allowedPrefixes: i, startOfLine: s, $position: a } = t, l = o && !r, c = QT(n), u = new RegExp(`\\s${c}$`), d = s ? "^" : "", f = r ? "" : c, p = l ? new RegExp(`${d}${c}.*?(?=\\s${f}|$)`, "gm") : new RegExp(`${d}(?:^)?${c}[^\\s${f}]*`, "gm"), m = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
  if (!m)
    return null;
  const g = a.pos - m.length, v = Array.from(m.matchAll(p)).pop();
  if (!v || v.input === void 0 || v.index === void 0)
    return null;
  const y = v.input.slice(Math.max(0, v.index - 1), v.index), w = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(y);
  if (i !== null && !w)
    return null;
  const x = g + v.index;
  let b = x + v[0].length;
  return l && u.test(m.slice(b - 1, b + 1)) && (v[0] += " ", b += 1), x < a.pos && b >= a.pos ? {
    range: {
      from: x,
      to: b
    },
    query: v[0].slice(n.length),
    text: v[0]
  } : null;
}
const cte = new Ne("suggestion");
function ute({ pluginKey: t = cte, editor: e, char: n = "@", allowSpaces: o = !1, allowToIncludeChar: r = !1, allowedPrefixes: i = [" "], startOfLine: s = !1, decorationTag: a = "span", decorationClass: l = "suggestion", command: c = () => null, items: u = () => [], render: d = () => ({}), allow: f = () => !0, findSuggestionMatch: p = lte }) {
  let m;
  const g = d == null ? void 0 : d(), v = new De({
    key: t,
    view() {
      return {
        update: async (y, w) => {
          var x, b, S, k, A, $, O;
          const M = (x = this.key) === null || x === void 0 ? void 0 : x.getState(w), P = (b = this.key) === null || b === void 0 ? void 0 : b.getState(y.state), F = M.active && P.active && M.range.from !== P.range.from, J = !M.active && P.active, Q = M.active && !P.active, G = !J && !Q && M.query !== P.query, V = J || F && G, B = G || F, q = Q || F && G;
          if (!V && !B && !q)
            return;
          const z = q && !V ? M : P, H = y.dom.querySelector(`[data-decoration-id="${z.decorationId}"]`);
          m = {
            editor: e,
            range: z.range,
            query: z.query,
            text: z.text,
            items: [],
            command: (Z) => c({
              editor: e,
              range: z.range,
              props: Z
            }),
            decorationNode: H,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: H ? () => {
              var Z;
              const { decorationId: ne } = (Z = this.key) === null || Z === void 0 ? void 0 : Z.getState(e.state), he = y.dom.querySelector(`[data-decoration-id="${ne}"]`);
              return (he == null ? void 0 : he.getBoundingClientRect()) || null;
            } : null
          }, V && ((S = g == null ? void 0 : g.onBeforeStart) === null || S === void 0 || S.call(g, m)), B && ((k = g == null ? void 0 : g.onBeforeUpdate) === null || k === void 0 || k.call(g, m)), (B || V) && (m.items = await u({
            editor: e,
            query: z.query
          })), q && ((A = g == null ? void 0 : g.onExit) === null || A === void 0 || A.call(g, m)), B && (($ = g == null ? void 0 : g.onUpdate) === null || $ === void 0 || $.call(g, m)), V && ((O = g == null ? void 0 : g.onStart) === null || O === void 0 || O.call(g, m));
        },
        destroy: () => {
          var y;
          m && ((y = g == null ? void 0 : g.onExit) === null || y === void 0 || y.call(g, m));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(y, w, x, b) {
        const { isEditable: S } = e, { composing: k } = e.view, { selection: A } = y, { empty: $, from: O } = A, M = { ...w };
        if (M.composing = k, S && ($ || e.view.composing)) {
          (O < w.range.from || O > w.range.to) && !k && !w.composing && (M.active = !1);
          const P = p({
            char: n,
            allowSpaces: o,
            allowToIncludeChar: r,
            allowedPrefixes: i,
            startOfLine: s,
            $position: A.$from
          }), F = `id_${Math.floor(Math.random() * 4294967295)}`;
          P && f({
            editor: e,
            state: b,
            range: P.range,
            isActive: w.active
          }) ? (M.active = !0, M.decorationId = w.decorationId ? w.decorationId : F, M.range = P.range, M.query = P.query, M.text = P.text) : M.active = !1;
        } else
          M.active = !1;
        return M.active || (M.decorationId = null, M.range = { from: 0, to: 0 }, M.query = null, M.text = null), M;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(y, w) {
        var x;
        const { active: b, range: S } = v.getState(y.state);
        return b && ((x = g == null ? void 0 : g.onKeyDown) === null || x === void 0 ? void 0 : x.call(g, { view: y, event: w, range: S })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(y) {
        const { active: w, range: x, decorationId: b } = v.getState(y);
        return w ? Te.create(y.doc, [
          ft.inline(x.from, x.to, {
            nodeName: a,
            class: l,
            "data-decoration-id": b
          })
        ]) : null;
      }
    }
  });
  return v;
}
const dte = [
  { label: "优酷", value: "youku", icon: "Youku" },
  {
    label: "哔哩哔哩",
    value: "bilibili",
    icon: "BiliBili"
  },
  {
    label: "腾讯视频",
    value: "qqvideo",
    icon: "QQVideo"
  }
], fte = [
  { label: "高德地图", value: "amap", icon: "Gaode" },
  { label: "百度地图", value: "baidu_map", icon: "Baidu" }
], pte = [
  { label: "墨刀", value: "modao", icon: "Modao" },
  { label: "蓝湖", value: "lanhu", icon: "Lanhu" },
  { label: "Figma", value: "figma", icon: "Figma" },
  { label: "Canva", value: "canva", icon: "Canva" },
  { label: "ProcessOn", value: "processon", icon: "Processon" }
], hte = [{ label: "CodePen", value: "codepen", icon: "Codepen" }], mte = [{ label: "金数据", value: "jinshuju", icon: "Jinshuju" }], gte = [], vte = [
  ...dte,
  ...fte,
  ...pte,
  ...hte,
  ...mte,
  ...gte
], qr = {
  youtube: {
    example: "https://www.youtube.com/watch?v=I4sMhHbHYXM",
    src: "https://www.youtube.com/embed/I4sMhHbHYXM",
    srcPrefix: "https://www.youtube.com/embed",
    linkRule: ["www.youtube.com\\/watch\\?v=\\w+"]
  },
  youku: {
    example: "https://v.youku.com/v_show/id_XNDM0NDM4MTcy.html?spm=a2h0c.8166622.PhoneSokuUgc_4.dtitle",
    src: "https://player.youku.com/embed/XNDM0NDM4MTcy",
    srcPrefix: "https://player.youku.com/embed",
    linkRule: ["v.youku.com\\/v_show\\/id_\\w+\\=*"],
    idRule: "id_\\w+\\=*"
  },
  bilibili: {
    example: "https://www.bilibili.com/video/BV1EJ411u7DN",
    src: "https://player.bilibili.com/player.html?bvid=BV1EJ411u7DN",
    srcPrefix: "https://player.bilibili.com/player.html?bvid",
    linkRule: ["www.bilibili.com\\/video\\/\\w+"]
  },
  qqvideo: {
    example: "https://v.qq.com/x/cover/mzc0020006aw1mn/u0033nvzb5v.html",
    src: "https://v.qq.com/txp/iframe/player.html?vid=u0033nvzb5v",
    srcPrefix: "https://v.qq.com/txp/iframe/player.html?vid",
    linkRule: ["v.qq.com\\/x\\/cover\\/\\w+\\/\\w+"]
  },
  amap: {
    example: "https://ditu.amap.com/",
    src: "https://www.amap.com/place/B000A45467",
    srcPrefix: "",
    linkRule: ["\\.amap\\.com"]
  },
  baidu_map: {
    example: "https://j.map.baidu.com/15/fo",
    src: "https://j.map.baidu.com/15/fo",
    srcPrefix: "",
    linkRule: ["map\\.baidu\\.com"]
  },
  modao: {
    example: "https://free.modao.cc/app/2cd26580a6717a147454df7470e7ec464093cba3/embed/v2#screen=sk71k6d1dfxulzx",
    src: "https://free.modao.cc/app/6UkpAxcGE3nPz52GLqhnOZgC7MATBSy/embed/v2",
    srcPrefix: "",
    linkRule: ["https:\\/\\/\\w+.modao.cc\\/app\\/\\w+\\/embed\\/v2"],
    tips: "Modao > More > Share > Embed > COPY"
  },
  lanhu: {
    example: "https://lanhuapp.com/web/#/item/project/stage?pid=uuid",
    src: "https://lanhuapp.com/web/#/item/project/stage?pid=uuid",
    srcPrefix: "",
    linkRule: ["lanhuapp\\.com\\/web\\/#\\/item\\/project\\/stage\\?pid=[\\w-]+"],
    tips: "Lanhu > Project > Share > Copy Link"
  },
  figma: {
    example: "https://www.figma.com/file/aS9uSgPXoNpaPkzbjNcK8v/Demo?node-id=0%3A1",
    src: "https://www.figma.com/file/aS9uSgPXoNpaPkzbjNcK8v/Demo?node-id=0%3A1",
    srcPrefix: "https://www.figma.com/embed?embed_host=share&url",
    linkRule: ["https:\\/\\/www.figma.com\\/file\\/\\w+"]
  },
  canva: {
    example: "https://www.canva.cn/design/DAD61-t29UI/view",
    src: "https://www.canva.cn/design/DAD61-t29UI/view",
    srcPrefix: "",
    linkRule: ["https:\\/\\/www.canva.cn\\/design\\/.+\\/view"]
  },
  processon: {
    example: "https://www.processon.com/embed/5ea99d8607912948b0e6fe78",
    src: "https://www.processon.com/embed/5ea99d8607912948b0e6fe78",
    srcPrefix: "",
    linkRule: ["https:\\/\\/www.processon.com\\/embed\\/\\w+"]
  },
  codepen: {
    example: "https://codepen.io/mekery/embed/YzyrKOJ",
    src: "https://codepen.io/mekery/embed/YzyrKOJ",
    srcPrefix: "",
    linkRule: ["https:\\/\\/codepen.io\\/.+\\/embed\\/\\w+"]
  },
  jinshuju: {
    example: "https://jinshuju.net/f/q9YvVf",
    src: "https://jinshuju.net/f/q9YvVf",
    srcPrefix: "",
    linkRule: ["https:\\/\\/jinshuju.net\\/f\\/\\w+"]
  },
  iframe: {
    example: "https://v.youku.com/v_show/id_XNDM0NDM4MTcy.html",
    src: "https://player.youku.com/embed/XNDM0NDM4MTcy",
    srcPrefix: "",
    linkRule: [".+"]
  }
}, yte = /* @__PURE__ */ new Map([
  ["youtube", wte],
  ["youku", xte],
  ["bilibili", Cte],
  ["qqvideo", Ste],
  ["amap", kte],
  ["baidu_map", Ete],
  ["modao", _te],
  ["lanhu", Ate],
  ["figma", Tte],
  ["canva", Ote],
  ["processon", Mte],
  ["codepen", Ite],
  ["jinshuju", Rte],
  ["iframe", LE]
]), _2 = /* @__PURE__ */ new Map();
function bte(t, e, n) {
  const r = qr[t].linkRule;
  for (const i of r) {
    let s = _2.get(i);
    s || (s = new RegExp(i), _2.set(i, s));
    const a = e.match(s);
    if (a != null && a[0])
      return n.validLink = !0, n.matchedUrl = a[0], n;
  }
  return n;
}
function wte(t, e) {
  let n = qr.youtube, o = e.matchedUrl;
  e.validLink = !0;
  let r = o.split("="), i = r.length;
  if (i > 0) {
    let s = r[i - 1];
    e.src = `${n.srcPrefix}/${s}`, e.validId = !0;
  }
  return e;
}
function xte(t, e) {
  let n = qr.youku, o = e.matchedUrl, r = n.idRule, i = new RegExp(r), s = o.match(i);
  if (s && s.length > 0) {
    let a = s[0].substr(3);
    e.validId = !0, e.src = `${n.srcPrefix}/${a}`;
  } else
    e.validId = !1;
  return e;
}
function Cte(t, e) {
  let n = qr.bilibili, r = e.matchedUrl.split("/"), i = r.length;
  if (i > 0) {
    let s = r[i - 1];
    e.src = `${n.srcPrefix}=${s}`, e.validId = !0;
  }
  return e;
}
function Ste(t, e) {
  let n = qr.qqvideo, r = e.matchedUrl.split("/"), i = r.length;
  if (i > 0) {
    let s = r[i - 1];
    e.src = `${n.srcPrefix}=${s}`, e.validId = !0;
  }
  return e;
}
function kte(t, e) {
  return e.src = t, e.validId = !0, e;
}
function Ete(t, e) {
  return e.src = t, e.validId = !0, e;
}
function _te(t, e) {
  return e.src = e.matchedUrl, e.validId = !0, e.originalLink = e.src, e;
}
function Ate(t, e) {
  const n = t.match(/pid=([\w-]+)/);
  return n && n[1] ? (e.src = `https://lanhuapp.com/web/#/item/project/stage?pid=${n[1]}&type=share_embed`, e.validId = !0) : (e.src = t, e.validId = !0), e.originalLink = t, e;
}
function Tte(t, e) {
  let n = qr.figma;
  return e.src = `${n.srcPrefix}=${encodeURIComponent(e.matchedUrl)}`, e.validId = !0, e.originalLink = e.matchedUrl, e;
}
function Ote(t, e) {
  return e.src = `${e.matchedUrl}?embed`, e.validId = !0, e.originalLink = t, e;
}
function Mte(t, e) {
  return e.src = `${e.matchedUrl}`, e.validId = !0, e.originalLink = t, e;
}
function Ite(t, e) {
  return e.src = `${e.matchedUrl}`, e.validId = !0, e.originalLink = e.src, e;
}
function Rte(t, e) {
  return e.src = `${e.matchedUrl}?background=white&banner=show&embedded=true`, e.validId = !0, e.originalLink = t, e;
}
function LE(t, e) {
  return e.src = `${e.matchedUrl}`, e.validId = !0, e.originalLink = t, e;
}
function $te(t) {
  let e = "", n = qr[t];
  return n && (e = n.example), e;
}
const A2 = (t, e) => {
  if (!t || !e)
    return {
      validLink: !1,
      validId: !1,
      matchedUrl: "",
      originalLink: e || "",
      src: ""
    };
  if (!qr[t])
    return console.warn(`Unknown embed service: ${t}`), {
      validLink: !1,
      validId: !1,
      matchedUrl: "",
      originalLink: e,
      src: ""
    };
  let n = {
    validLink: !1,
    validId: !1,
    matchedUrl: "",
    originalLink: e,
    src: ""
  };
  return n = bte(t, e, n), n.validLink ? (yte.get(t) || LE)(e, n) : n;
};
function Pte(t) {
  const { t: e } = Ge(), n = [
    {
      name: "format",
      title: e.value("editor.slash.format"),
      commands: [
        {
          name: "paragraph",
          label: e.value("editor.paragraph.tooltip"),
          aliases: ["paragraph", "zw"],
          iconName: "Paragraph",
          shouldBeHidden: (r) => !Fe(r, "heading"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setHeading({ level: 1 }).run();
          }
        },
        {
          name: "heading1",
          label: e.value("editor.heading.h1.tooltip"),
          aliases: ["h1", "bt", "bt1"],
          iconName: "Heading1",
          shouldBeHidden: (r) => !Fe(r, "heading"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setHeading({ level: 1 }).run();
          }
        },
        {
          name: "heading2",
          label: e.value("editor.heading.h2.tooltip"),
          aliases: ["h2", "bt", "bt2"],
          iconName: "Heading2",
          shouldBeHidden: (r) => !Fe(r, "heading"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setNode("heading", { level: 2 }).run();
          }
        },
        {
          name: "heading3",
          label: e.value("editor.heading.h3.tooltip"),
          aliases: ["h3", "bt", "bt3", "heading3"],
          iconName: "Heading3",
          shouldBeHidden: (r) => !Fe(r, "heading"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setNode("heading", { level: 3 }).run();
          }
        },
        {
          name: "bulletList",
          label: e.value("editor.bulletlist.tooltip"),
          aliases: ["ul", "yxlb", "bulletList"],
          iconName: "List",
          shouldBeHidden: (r) => !Fe(r, "bulletList"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).toggleBulletList().run();
          }
        },
        {
          name: "numberedList",
          label: e.value("editor.orderedlist.tooltip"),
          aliases: ["ol", "yxlb"],
          iconName: "ListOrdered",
          shouldBeHidden: (r) => !Fe(r, "orderedList"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).toggleOrderedList().run();
          }
        },
        {
          name: "codeBlock",
          label: e.value("editor.codeblock.tooltip"),
          iconName: "Code2",
          aliases: ["codeBlock"],
          description: "Code block with syntax highlighting",
          shouldBeHidden: (r) => !Fe(r, "codeBlock") || r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setCodeBlock().run();
          }
        },
        {
          name: "blockquote",
          label: e.value("editor.blockquote.tooltip"),
          description: "插入引入格式",
          aliases: ["yr"],
          iconName: "TextQuote",
          shouldBeHidden: (r) => !Fe(r, "blockquote"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setBlockquote().run();
          }
        },
        {
          name: "horizontalrule",
          label: e.value("editor.horizontalrule.tooltip"),
          aliases: ["fgx", "horizontalRule"],
          iconName: "Minus",
          shouldBeHidden: (r) => !Fe(r, "horizontalRule"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setHorizontalRule().run();
          }
        },
        {
          name: "link",
          label: e.value("editor.link.tooltip"),
          aliases: ["link", "lianjie", "lj"],
          iconName: "Link",
          shouldBeHidden: (r) => !Fe(r, "link"),
          action: ({ editor: r, range: i }) => {
            r.chain().deleteRange(i).extendMarkRange("link").insertContent({
              type: "text",
              text: "link",
              marks: [
                {
                  type: "link",
                  attrs: {
                    href: "",
                    target: "_blank"
                  }
                }
              ]
            }).setLink({ href: "" }).focus().run();
          }
        }
      ]
    },
    {
      name: "insert",
      title: e.value("editor.slash.insert"),
      commands: [
        {
          name: "image",
          label: e.value("editor.image.tooltip"),
          iconName: "ImageUp",
          description: "Insert a image",
          aliases: ["image", "tp", "tupian"],
          shouldBeHidden: (r) => !Fe(r, "image") || r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setImageUpload().run();
          }
        },
        {
          name: "table",
          label: e.value("editor.table.tooltip"),
          iconName: "Table",
          description: "Insert a table",
          aliases: ["table", "bg", "biaoge", "biao"],
          shouldBeHidden: (r) => !Fe(r, "table") || r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).insertTable({ rows: 3, cols: 3, withHeaderRow: !1 }).run();
          }
        },
        {
          name: "video",
          label: e.value("editor.video.tooltip"),
          iconName: "Video",
          description: "Insert a video",
          aliases: ["video", "sp", "shipin"],
          shouldBeHidden: (r) => !Fe(r, "video") || r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setVideoUpload().run();
          }
        },
        {
          name: "taskList",
          label: e.value("editor.tasklist.tooltip"),
          iconName: "ListTodo",
          description: "Task list with todo items",
          aliases: ["todo"],
          shouldBeHidden: (r) => !Fe(r, "taskList"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).toggleTaskList().run();
          }
        },
        {
          name: "columns",
          label: e.value("editor.columns.tooltip"),
          iconName: "Columns2",
          description: "Add two column content",
          aliases: ["columns", "cols", "2cols"],
          shouldBeHidden: (r) => !Fe(r, "columns") || r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().deleteRange(i).setColumns().focus(r.state.selection.head - 1).run();
          }
        }
      ]
    }
  ];
  if (Fe(t, "iframes")) {
    const r = vte;
    n.push({
      name: "others",
      title: e.value("editor.slash.embed"),
      commands: r.map((i) => ({
        name: i.value,
        label: i.label,
        iconName: i.icon,
        aliases: [i.value, i.label],
        shouldBeHidden: (s) => s.isActive("columns"),
        action: ({ editor: s, range: a }) => {
          s.chain().deleteRange(a).focus().setIframe({
            src: "",
            service: i.value
          }).run();
        }
      }))
    });
  }
  return n;
}
const Lte = {
  key: 0,
  class: "grid grid-cols-1 gap-0.5 min-w-48"
}, Dte = { className: "text-neutral-500 text-[0.65rem] col-[1/-1] mx-2 mt-2 font-semibold tracking-wider select-none uppercase first:mt-0.5" }, Nte = ["onClick"], Bte = ["src"], Fte = {
  key: 1,
  class: "p-3"
}, zte = { class: "text-xs text-gray-800 dark:text-gray-100" }, Hte = /* @__PURE__ */ I({
  __name: "CommandsList",
  props: {
    editor: {},
    items: { default: void 0 },
    command: { type: Function, default: void 0 }
  },
  setup(t, { expose: e }) {
    const n = R(0), o = R(0), r = R(null), { t: i } = Ge(), s = R([]), a = t;
    e({ onKeyDown: l }), le([() => n.value, () => o.value], async () => {
      if (!r.value) return;
      await ze();
      const g = o.value * 1e3 + n.value, v = s.value[g];
      v && v.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      });
    });
    function l({ event: g }) {
      return g.key === "ArrowUp" ? (c(), !0) : g.key === "ArrowDown" ? (u(), !0) : g.key === "Enter" ? (d(), !0) : !1;
    }
    function c() {
      var y;
      if (!a.items.length)
        return !1;
      let g = n.value - 1, v = o.value;
      g < 0 && (v = o.value - 1, g = ((y = a.items[v]) == null ? void 0 : y.commands.length) - 1 || 0), v < 0 && (v = a.items.length - 1, g = a.items[v].commands.length - 1), n.value = g, o.value = v;
    }
    function u() {
      if (!a.items.length)
        return !1;
      const g = a.items[o.value].commands;
      let v = n.value + 1, y = o.value;
      g.length - 1 < v && (v = 0, y = o.value + 1), a.items.length - 1 < y && (y = 0), n.value = v, o.value = y;
    }
    function d() {
      if (!a.items.length || o.value === -1 || n.value === -1)
        return !1;
      f(o.value, n.value);
    }
    function f(g, v) {
      const y = a.items[g].commands[v];
      a.command(y);
    }
    function p(g, v) {
      f(g, v);
    }
    function m(g, v, y) {
      s.value[g * 1e3 + v] = y;
    }
    return (g, v) => {
      var y;
      return E(), W("div", {
        class: "bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800 text-black max-h-[min(80vh,24rem)] overflow-auto flex-wrap mb-8 p-1",
        ref_key: "scrollContainer",
        ref: r
      }, [
        (y = g.items) != null && y.length ? (E(), W("div", Lte, [
          (E(!0), W(me, null, Oe(g.items, (w, x) => (E(), W(me, {
            key: w.title
          }, [
            N("div", Dte, Y(w.title), 1),
            (E(!0), W(me, null, Oe(w.commands, (b, S) => (E(), W("button", {
              class: He(["flex items-center gap-3 px-2 py-1.5 text-sm text-neutral-800 dark:text-neutral-200 text-left w-full rounded-sm outline-none transition-colors", [
                o.value === x && n.value === S ? "bg-accent text-neutral-800 dark:bg-neutral-900 dark:text-neutral-200" : "hover:bg-accent hover:text-neutral-800 dark:hover:bg-neutral-900 dark:hover:text-neutral-200"
              ]]),
              ref_for: !0,
              ref: (k) => m(x, S, k),
              key: S,
              onClick: (k) => p(x, S)
            }, [
              b.iconUrl ? (E(), W("img", {
                key: 0,
                class: "w-6 h-6",
                src: b.iconUrl
              }, null, 8, Bte)) : oe("", !0),
              b.iconName ? (E(), T(h(ye), {
                key: 1,
                name: b.iconName,
                class: "mr-1 text-lg"
              }, null, 8, ["name"])) : oe("", !0),
              ue(" " + Y(b.label), 1)
            ], 10, Nte))), 128))
          ], 64))), 128))
        ])) : (E(), W("div", Fte, [
          N("span", zte, Y(h(i)("editor.slash.empty")), 1)
        ]))
      ], 512);
    };
  }
}), ei = "slashCommand";
let Ke;
const Lre = ke.create({
  name: ei,
  priority: 200,
  onCreate() {
    Ke = Fr("body", {
      interactive: !0,
      trigger: "manual",
      placement: "bottom-start",
      theme: "slash-command",
      maxWidth: "16rem",
      offset: [16, 8],
      popperOptions: {
        strategy: "fixed",
        modifiers: [
          {
            name: "flip",
            enabled: !1
          }
        ]
      }
    });
  },
  addProseMirrorPlugins() {
    return [
      ute({
        editor: this.editor,
        char: "/",
        allowSpaces: !0,
        startOfLine: !0,
        pluginKey: new Ne(ei),
        allow: ({ state: t, range: e }) => {
          var c, u, d;
          const n = t.doc.resolve(e.from), o = n.depth === 1, r = n.parent.type.name === "paragraph", i = ((c = n.parent.textContent) == null ? void 0 : c.charAt(0)) === "/", s = this.editor.isActive("column"), a = (d = n.parent.textContent) == null ? void 0 : d.substring((u = n.parent.textContent) == null ? void 0 : u.indexOf("/")), l = !(a != null && a.endsWith("  "));
          return (o && r && i || s && r && i) && l;
        },
        command: ({ editor: t, range: e, props: n }) => {
          const { view: o } = t;
          n.action({ editor: t, range: e }), o.focus();
        },
        items: ({ query: t, editor: e }) => Pte(this.editor).map((s) => ({
          ...s,
          commands: s.commands.filter((a) => {
            const l = a.label.toLowerCase().trim(), c = t.toLowerCase().trim();
            if (a.aliases) {
              const u = a.aliases.map((p) => p.toLowerCase().trim()), d = l.match(c), f = u.some((p) => p.match(c));
              return d || f;
            }
            return l.match(c);
          }).filter((a) => a.shouldBeHidden ? !a.shouldBeHidden(this.editor) : !0)
        })).filter((s) => s.commands.length > 0).map((s) => ({
          ...s,
          commands: s.commands.map((a) => ({
            ...a,
            isEnabled: !0
          }))
        })),
        render: () => {
          let t, e = null;
          return {
            onStart: (n) => {
              var s;
              t = new sS(Hte, {
                props: n,
                editor: n.editor
              });
              const { view: o } = n.editor, r = o.dom, i = () => {
                if (!n.clientRect)
                  return n.editor.storage[ei].rect;
                const a = n.clientRect();
                if (!a)
                  return n.editor.storage[ei].rect;
                let l = a.y;
                if (a.top + t.element.offsetHeight + 40 > window.innerHeight) {
                  const c = a.top + t.element.offsetHeight - window.innerHeight + 40;
                  l = a.y - c;
                }
                return r.getBoundingClientRect().x, new DOMRect(a.x, l, a.width, a.height);
              };
              e = () => {
                Ke == null || Ke[0].setProps({
                  getReferenceClientRect: i
                });
              }, (s = o.dom.parentElement) == null || s.addEventListener("scroll", e), Ke == null || Ke[0].setProps({
                getReferenceClientRect: i,
                appendTo: () => document.body,
                content: t.element
              }), Ke == null || Ke[0].show();
            },
            onUpdate(n) {
              var s;
              t.updateProps(n);
              const { view: o } = n.editor;
              o.dom;
              const r = () => {
                if (!n.clientRect)
                  return n.editor.storage[ei].rect;
                const a = n.clientRect();
                return a ? new DOMRect(a.x, a.y, a.width, a.height) : n.editor.storage[ei].rect;
              };
              let i = () => {
                Ke == null || Ke[0].setProps({
                  getReferenceClientRect: r
                });
              };
              (s = o.dom.parentElement) == null || s.addEventListener("scroll", i), n.editor.storage[ei].rect = n.clientRect ? r() : {
                width: 0,
                height: 0,
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
              }, Ke == null || Ke[0].setProps({
                getReferenceClientRect: r
              });
            },
            onKeyDown(n) {
              var o;
              return n.event.key === "Escape" ? (Ke == null || Ke[0].hide(), !0) : (Ke != null && Ke[0].state.isShown || Ke == null || Ke[0].show(), (o = t.ref) == null ? void 0 : o.onKeyDown(n));
            },
            onExit(n) {
              var o;
              if (Ke == null || Ke[0].hide(), e) {
                const { view: r } = n.editor;
                (o = r.dom.parentElement) == null || o.removeEventListener("scroll", e);
              }
              t.destroy();
            }
          };
        }
      })
    ];
  },
  addStorage() {
    return {
      rect: {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }
    };
  }
}), Vte = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, Ute = Ze.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", Le(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      LC({
        find: Vte,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, o] = t;
          return { src: n, alt: e, title: o };
        }
      })
    ];
  }
}), jte = ["src", "alt"], Wte = {
  key: 0,
  class: "image-resizer"
}, Kte = ["onMousedown"], Gte = /* @__PURE__ */ I({
  __name: "ImageView",
  props: {
    ...jl,
    selected: {
      type: Boolean,
      required: !0
    }
  },
  setup(t) {
    const e = t, n = {
      TOP_LEFT: "tl",
      TOP_RIGHT: "tr",
      BOTTOM_LEFT: "bl",
      BOTTOM_RIGHT: "br"
    }, o = R({ width: yy, height: yy }), r = R({ width: 0, height: 0 }), i = R(!1), s = R({
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      dir: ""
    }), a = L(() => {
      const { src: b, alt: S, width: k, height: A, flipX: $, flipY: O } = e.node.attrs, M = [];
      $ && M.push("rotateX(180deg)"), O && M.push("rotateY(180deg)");
      const P = M.join(" ");
      return {
        src: b || void 0,
        alt: S || void 0,
        style: {
          width: fm(k) ? `${k}px` : k,
          height: fm(A) ? `${A}px` : A,
          transform: P || "none"
        }
      };
    }), l = L(() => ({
      width: h(a).style.width === "100%" ? "100%" : void 0
    })), c = R(null), u = new ResizeObserver((b) => {
      for (const S of b) {
        const { width: k, height: A } = S.contentRect;
        r.value = { width: k, height: A }, e.updateAttributes({ originWidth: k, originHeight: A });
      }
    });
    function d() {
      const { editor: b, getPos: S } = e;
      b.commands.setNodeSelection(S());
    }
    const f = Yu(() => {
      const { editor: b } = e;
      o.value.width = parseInt(getComputedStyle(b.view.dom).width, 10);
    }, by);
    function p(b, S) {
      b.preventDefault(), b.stopPropagation();
      const { width: k, height: A } = h(r), $ = k / A;
      let O = Number(e.node.attrs.width) || k, M = Number(e.node.attrs.height) || Math.round(O / $);
      const P = h(o).width;
      O = Math.min(O > P ? P : O, P), M = Math.round(O / $), Object.assign(s.value, { x: b.clientX, y: b.clientY, w: O, h: M, dir: S }), i.value = !0, v();
    }
    const m = Yu((b) => {
      if (!h(i)) return;
      const { x: S, y: k, w: A, dir: $ } = h(s), O = (b.clientX - S) * (/l/.test($) ? -1 : 1), M = kF(A + O, NO, h(o).width);
      e.updateAttributes({ width: M });
    }, by);
    function g(b) {
      b.preventDefault(), b.stopPropagation(), h(i) && (i.value = !1, Object.assign(s.value, { x: 0, y: 0, w: 0, h: 0, dir: "" }), y(), d());
    }
    function v() {
      document.addEventListener("mousemove", m, !0), document.addEventListener("mouseup", g, !0);
    }
    function y() {
      document.removeEventListener("mousemove", m, !0), document.removeEventListener("mouseup", g, !0);
    }
    const w = new ResizeObserver(f), x = L(() => {
      const { textAlign: b } = e.node.attrs;
      return {
        left: "margin-right: auto;",
        right: "margin-left: auto;",
        center: "margin-left: auto; margin-right: auto;"
      }[b] || "";
    });
    return be(() => {
      c.value && u.observe(c.value), w.observe(e.editor.view.dom);
    }), mo(() => {
      y(), u.disconnect(), w.disconnect();
    }), (b, S) => (E(), T(h(Ul), { class: "node-image" }, {
      default: C(() => [
        N("div", {
          class: "image-view",
          style: pt([a.value.style, x.value])
        }, [
          N("div", {
            draggable: "true",
            "data-drag-handle": "",
            class: He([{
              "image-view__body--focused": t.selected,
              "image-view__body--resizing": i.value
            }, "image-view__body"]),
            style: pt(l.value)
          }, [
            N("img", {
              src: a.value.src,
              alt: a.value.alt,
              ref_key: "imageRef",
              ref: c,
              class: "image-view__body__image block",
              onClick: d
            }, null, 8, jte),
            b.editor.view.editable ? Vn((E(), W("div", Wte, [
              (E(!0), W(me, null, Oe(Object.values(n), (k) => (E(), W("span", {
                key: k,
                class: He([`image-resizer__handler--${k}`, "image-resizer__handler"]),
                onMousedown: (A) => p(A, k)
              }, null, 42, Kte))), 128))
            ], 512)), [
              [no, t.selected || i.value]
            ]) : oe("", !0)
          ], 6)
        ], 4)
      ]),
      _: 1
    }));
  }
}), qte = /* @__PURE__ */ W3(Gte, [["__scopeId", "data-v-6b19b371"]]), Dre = Ute.extend({
  group: "block",
  defining: !0,
  isolating: !0,
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      flipX: {
        default: !1
      },
      flipY: {
        default: !1
      },
      originWidth: {
        default: null
      },
      originHeight: {
        default: null
      },
      width: {
        default: "100%",
        parseHTML: (e) => {
          const n = e.style.width || e.getAttribute("width") || null;
          return n && n.endsWith("%") ? n : n == null ? null : parseInt(n, 10);
        },
        renderHTML: (e) => ({
          width: e.width
        })
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this)
    };
  },
  addNodeView() {
    return Wl(qte);
  },
  addCommands() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      updateImage: (e) => ({ commands: n, editor: o }) => n.updateAttributes(this.name, e)
    };
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { textAlign: n, flipX: o, flipY: r } = t.attrs, a = `${{
      left: "margin-right: auto;",
      right: "margin-left: auto;",
      center: "margin-left: auto; margin-right: auto;"
    }[n] || ""} ${o || r ? `transform: rotateX(${o ? "180" : "0"}deg) rotateY(${r ? "180" : "0"}deg);` : ""}`;
    return [
      "img",
      Le(
        {
          height: "auto",
          style: a
        },
        this.options.HTMLAttributes,
        e
      )
    ];
  },
  parseHTML() {
    return [
      {
        tag: "img[src]"
      }
    ];
  }
});
function Yte(t) {
  return t = t.replace("https://youtu.be/", "https://www.youtube.com/watch?v=").replace("watch?v=", "embed/"), t = t.replace("https://vimeo.com/", "https://player.vimeo.com/video/"), /^https?:\/\/www.bilibili.com\/video\/.*/i.test(t) && (t = t.replace(/\?.*$/i, "").replace("https://www.bilibili.com/video/", "https://player.bilibili.com/player.html?bvid=")), t.includes("drive.google.com") && (t = t.replace("/view", "/preview")), t;
}
const Nre = Ze.create({
  name: "video",
  group: "block",
  atom: !0,
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null,
        renderHTML: ({ src: t }) => ({
          src: t ? Yte(t) : null
        })
      },
      width: {
        default: this.options.width,
        renderHTML: ({ width: t }) => ({
          width: fu(t)
        })
      },
      frameborder: {
        default: this.options.frameborder ? 1 : 0,
        parseHTML: () => this.options.frameborder ? 1 : 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-video] iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { width: e = "100%" } = t ?? {}, n = {
      ...t,
      width: "100%",
      height: "100%"
    }, o = `position: relative;overflow: hidden;display: flex;flex: 1;max-width: ${e};`, r = `flex: 1;padding-bottom: ${9 / 16 * 100}%;`, a = ["div", { style: o }, ["div", { style: r }], ["iframe", n]];
    return ["div", {
      ...this.options.HTMLAttributes,
      "data-video": ""
    }, a];
  },
  addCommands() {
    return {
      setVideo: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      }),
      updateVideo: (t) => ({ commands: e }) => e.updateAttributes(this.name, t)
    };
  },
  addOptions() {
    return {
      divider: !1,
      spacer: !1,
      allowFullscreen: !0,
      upload: void 0,
      frameborder: !1,
      width: Wu["size-medium"],
      HTMLAttributes: {
        class: "iframe-wrapper",
        style: "display: flex;justify-content: center;"
      }
    };
  }
});
var pg, hg;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  pg = (e) => t.get(e), hg = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  pg = (o) => {
    for (let r = 0; r < t.length; r += 2)
      if (t[r] == o) return t[r + 1];
  }, hg = (o, r) => (n == 10 && (n = 0), t[n++] = o, t[n++] = r);
}
var dt = class {
  constructor(t, e, n, o) {
    this.width = t, this.height = e, this.map = n, this.problems = o;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t) continue;
      const o = e % this.width, r = e / this.width | 0;
      let i = o + 1, s = r + 1;
      for (let a = 1; i < this.width && this.map[e + a] == n; a++)
        i++;
      for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
        s++;
      return { left: o, top: r, right: i, bottom: s };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: o, right: r, top: i, bottom: s } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? o == 0 : r == this.width) ? null : this.map[i * this.width + (n < 0 ? o - 1 : r)] : (n < 0 ? i == 0 : s == this.height) ? null : this.map[o + this.width * (n < 0 ? i - 1 : s)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: o,
      top: r,
      bottom: i
    } = this.findCell(t), {
      left: s,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(r, l),
      right: Math.max(o, a),
      bottom: Math.max(i, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let o = t.top; o < t.bottom; o++)
      for (let r = t.left; r < t.right; r++) {
        const i = o * this.width + r, s = this.map[i];
        n[s] || (n[s] = !0, !(r == t.left && r && this.map[i - 1] == s || o == t.top && o && this.map[i - this.width] == s) && e.push(s));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let o = 0, r = 0; ; o++) {
      const i = r + n.child(o).nodeSize;
      if (o == t) {
        let s = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; s < a && this.map[s] < r; ) s++;
        return s == a ? i - 1 : this.map[s];
      }
      r = i;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return pg(t) || hg(t, Jte(t));
  }
};
function Jte(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = Xte(t), n = t.childCount, o = [];
  let r = 0, i = null;
  const s = [];
  for (let c = 0, u = e * n; c < u; c++) o[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let m = 0; ; m++) {
      for (; r < o.length && o[r] != 0; ) r++;
      if (m == d.childCount) break;
      const g = d.child(m), { colspan: v, rowspan: y, colwidth: w } = g.attrs;
      for (let x = 0; x < y; x++) {
        if (x + c >= n) {
          (i || (i = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: y - x
          });
          break;
        }
        const b = r + x * e;
        for (let S = 0; S < v; S++) {
          o[b + S] == 0 ? o[b + S] = u : (i || (i = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: v - S
          });
          const k = w && w[S];
          if (k) {
            const A = (b + S) % e * 2, $ = s[A];
            $ == null || $ != k && s[A + 1] == 1 ? (s[A] = k, s[A + 1] = 1) : $ == k && s[A + 1]++;
          }
        }
      }
      r += v, u += g.nodeSize;
    }
    const f = (c + 1) * e;
    let p = 0;
    for (; r < f; ) o[r++] == 0 && p++;
    p && (i || (i = [])).push({ type: "missing", row: c, n: p }), u++;
  }
  (e === 0 || n === 0) && (i || (i = [])).push({ type: "zero_sized" });
  const a = new dt(e, n, o, i);
  let l = !1;
  for (let c = 0; !l && c < s.length; c += 2)
    s[c] != null && s[c + 1] < n && (l = !0);
  return l && Zte(a, s, t), a;
}
function Xte(t) {
  let e = -1, n = !1;
  for (let o = 0; o < t.childCount; o++) {
    const r = t.child(o);
    let i = 0;
    if (n)
      for (let s = 0; s < o; s++) {
        const a = t.child(s);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          s + c.attrs.rowspan > o && (i += c.attrs.colspan);
        }
      }
    for (let s = 0; s < r.childCount; s++) {
      const a = r.child(s);
      i += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = i : e != i && (e = Math.max(e, i));
  }
  return e;
}
function Zte(t, e, n) {
  t.problems || (t.problems = []);
  const o = {};
  for (let r = 0; r < t.map.length; r++) {
    const i = t.map[r];
    if (o[i]) continue;
    o[i] = !0;
    const s = n.nodeAt(i);
    if (!s)
      throw new RangeError(`No cell with offset ${i} found`);
    let a = null;
    const l = s.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (r + c) % t.width, d = e[u * 2];
      d != null && (!l.colwidth || l.colwidth[c] != d) && ((a || (a = Qte(l)))[c] = d);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: i,
      colwidth: a
    });
  }
}
function Qte(t) {
  if (t.colwidth) return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++) e.push(0);
  return e;
}
function Dt(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const o = t.nodes[n], r = o.spec.tableRole;
      r && (e[r] = o);
    }
  }
  return e;
}
var pr = new Ne("selectingCells");
function aa(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function ene(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell") return t.node(e);
  }
  return null;
}
function Yn(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row") return !0;
  return !1;
}
function np(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = aa(e.$head) || tne(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function tne(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const o = e.type.spec.tableRole;
    if (o == "cell" || o == "header_cell") return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const o = e.type.spec.tableRole;
    if (o == "cell" || o == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function mg(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function nne(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Bv(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function DE(t, e, n) {
  const o = t.node(-1), r = dt.get(o), i = t.start(-1), s = r.nextCell(t.pos - i, e, n);
  return s == null ? null : t.node(0).resolve(i + s);
}
function Ti(t, e, n = 1) {
  const o = { ...t, colspan: t.colspan - n };
  return o.colwidth && (o.colwidth = o.colwidth.slice(), o.colwidth.splice(e, n), o.colwidth.some((r) => r > 0) || (o.colwidth = null)), o;
}
function NE(t, e, n = 1) {
  const o = { ...t, colspan: t.colspan + n };
  if (o.colwidth) {
    o.colwidth = o.colwidth.slice();
    for (let r = 0; r < n; r++) o.colwidth.splice(e, 0, 0);
  }
  return o;
}
function one(t, e, n) {
  const o = Dt(e.type.schema).header_cell;
  for (let r = 0; r < t.height; r++)
    if (e.nodeAt(t.map[n + r * t.width]).type != o)
      return !1;
  return !0;
}
var Xe = class Ao extends fe {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const o = e.node(-1), r = dt.get(o), i = e.start(-1), s = r.rectBetween(
      e.pos - i,
      n.pos - i
    ), a = e.node(0), l = r.cellsInRect(s).filter((u) => u != n.pos - i);
    l.unshift(n.pos - i);
    const c = l.map((u) => {
      const d = o.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const f = i + u + 1;
      return new Og(
        a.resolve(f),
        a.resolve(f + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const o = e.resolve(n.map(this.$anchorCell.pos)), r = e.resolve(n.map(this.$headCell.pos));
    if (mg(o) && mg(r) && Bv(o, r)) {
      const i = this.$anchorCell.node(-1) != o.node(-1);
      return i && this.isRowSelection() ? Ao.rowSelection(o, r) : i && this.isColSelection() ? Ao.colSelection(o, r) : new Ao(o, r);
    }
    return ce.between(o, r);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = dt.get(e), o = this.$anchorCell.start(-1), r = n.rectBetween(
      this.$anchorCell.pos - o,
      this.$headCell.pos - o
    ), i = {}, s = [];
    for (let l = r.top; l < r.bottom; l++) {
      const c = [];
      for (let u = l * n.width + r.left, d = r.left; d < r.right; d++, u++) {
        const f = n.map[u];
        if (i[f]) continue;
        i[f] = !0;
        const p = n.findCell(f);
        let m = e.nodeAt(f);
        if (!m)
          throw RangeError(`No cell with offset ${f} found`);
        const g = r.left - p.left, v = p.right - r.right;
        if (g > 0 || v > 0) {
          let y = m.attrs;
          if (g > 0 && (y = Ti(y, 0, g)), v > 0 && (y = Ti(
            y,
            y.colspan - v,
            v
          )), p.left < r.left) {
            if (m = m.type.createAndFill(y), !m)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(y)}`
              );
          } else
            m = m.type.create(y, m.content);
        }
        if (p.top < r.top || p.bottom > r.bottom) {
          const y = {
            ...m.attrs,
            rowspan: Math.min(p.bottom, r.bottom) - Math.max(p.top, r.top)
          };
          p.top < r.top ? m = m.type.createAndFill(y) : m = m.type.create(y, m.content);
        }
        c.push(m);
      }
      s.push(e.child(l).copy(K.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : s;
    return new te(K.from(a), 1, 1);
  }
  replace(e, n = te.empty) {
    const o = e.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      const { $from: a, $to: l } = r[s], c = e.mapping.slice(o);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        s ? te.empty : n
      );
    }
    const i = fe.findFrom(
      e.doc.resolve(e.mapping.slice(o).map(this.to)),
      -1
    );
    i && e.setSelection(i);
  }
  replaceWith(e, n) {
    this.replace(e, new te(K.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), o = dt.get(n), r = this.$anchorCell.start(-1), i = o.cellsInRect(
      o.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      )
    );
    for (let s = 0; s < i.length; s++)
      e(n.nodeAt(i[s]), r + i[s]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0) return !1;
    const o = e + this.$anchorCell.nodeAfter.attrs.rowspan, r = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(o, r) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const o = e.node(-1), r = dt.get(o), i = e.start(-1), s = r.findCell(e.pos - i), a = r.findCell(n.pos - i), l = e.node(0);
    return s.top <= a.top ? (s.top > 0 && (e = l.resolve(i + r.map[s.left])), a.bottom < r.height && (n = l.resolve(
      i + r.map[r.width * (r.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(i + r.map[a.left])), s.bottom < r.height && (e = l.resolve(
      i + r.map[r.width * (r.height - 1) + s.right - 1]
    ))), new Ao(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = dt.get(e), o = this.$anchorCell.start(-1), r = n.colCount(this.$anchorCell.pos - o), i = n.colCount(this.$headCell.pos - o);
    if (Math.min(r, i) > 0) return !1;
    const s = r + this.$anchorCell.nodeAfter.attrs.colspan, a = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(e) {
    return e instanceof Ao && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const o = e.node(-1), r = dt.get(o), i = e.start(-1), s = r.findCell(e.pos - i), a = r.findCell(n.pos - i), l = e.node(0);
    return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
      i + r.map[s.top * r.width]
    )), a.right < r.width && (n = l.resolve(
      i + r.map[r.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(i + r.map[a.top * r.width])), s.right < r.width && (e = l.resolve(
      i + r.map[r.width * (s.top + 1) - 1]
    ))), new Ao(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Ao(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, o = n) {
    return new Ao(e.resolve(n), e.resolve(o));
  }
  getBookmark() {
    return new rne(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Xe.prototype.visible = !1;
fe.jsonID("cell", Xe);
var rne = class BE {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new BE(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), o = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && o.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && o.index() < o.parent.childCount && Bv(n, o) ? new Xe(n, o) : fe.near(o, 1);
  }
};
function ine(t) {
  if (!(t.selection instanceof Xe)) return null;
  const e = [];
  return t.selection.forEachCell((n, o) => {
    e.push(
      ft.node(o, o + n.nodeSize, { class: "selectedCell" })
    );
  }), Te.create(t.doc, e);
}
function sne({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
  let n = t.pos, o = e.pos, r = t.depth;
  for (; r >= 0 && !(t.after(r + 1) < t.end(r)); r--, n++)
    ;
  for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, o--)
    ;
  return n == o && /row|table/.test(t.node(r).type.spec.tableRole);
}
function ane({ $from: t, $to: e }) {
  let n, o;
  for (let r = t.depth; r > 0; r--) {
    const i = t.node(r);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      n = i;
      break;
    }
  }
  for (let r = e.depth; r > 0; r--) {
    const i = e.node(r);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      o = i;
      break;
    }
  }
  return n !== o && e.parentOffset === 0;
}
function lne(t, e, n) {
  const o = (e || t).selection, r = (e || t).doc;
  let i, s;
  if (o instanceof de && (s = o.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell")
      i = Xe.create(r, o.from);
    else if (s == "row") {
      const a = r.resolve(o.from + 1);
      i = Xe.rowSelection(a, a);
    } else if (!n) {
      const a = dt.get(o.node), l = o.from + 1, c = l + a.map[a.width * a.height - 1];
      i = Xe.create(r, l + 1, c);
    }
  } else o instanceof ce && sne(o) ? i = ce.create(r, o.from) : o instanceof ce && ane(o) && (i = ce.create(r, o.$from.start(), o.$from.end()));
  return i && (e || (e = t.tr)).setSelection(i), e;
}
var cne = new Ne("fix-tables");
function FE(t, e, n, o) {
  const r = t.childCount, i = e.childCount;
  e: for (let s = 0, a = 0; s < i; s++) {
    const l = e.child(s);
    for (let c = a, u = Math.min(r, s + 3); c < u; c++)
      if (t.child(c) == l) {
        a = c + 1, n += l.nodeSize;
        continue e;
      }
    o(l, n), a < r && t.child(a).sameMarkup(l) ? FE(t.child(a), l, n + 1, o) : l.nodesBetween(0, l.content.size, o, n + 1), n += l.nodeSize;
  }
}
function zE(t, e) {
  let n;
  const o = (r, i) => {
    r.type.spec.tableRole == "table" && (n = une(t, r, i, n));
  };
  return e ? e.doc != t.doc && FE(e.doc, t.doc, 0, o) : t.doc.descendants(o), n;
}
function une(t, e, n, o) {
  const r = dt.get(e);
  if (!r.problems) return o;
  o || (o = t.tr);
  const i = [];
  for (let l = 0; l < r.height; l++) i.push(0);
  for (let l = 0; l < r.problems.length; l++) {
    const c = r.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++) i[c.row + f] += c.n;
      o.setNodeMarkup(
        o.mapping.map(n + 1 + c.pos),
        null,
        Ti(d, d.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      i[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      o.setNodeMarkup(o.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      o.setNodeMarkup(o.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = o.mapping.map(n);
      o.delete(u, u + e.nodeSize);
    }
  }
  let s, a;
  for (let l = 0; l < i.length; l++)
    i[l] && (s == null && (s = l), a = l);
  for (let l = 0, c = n + 1; l < r.height; l++) {
    const u = e.child(l), d = c + u.nodeSize, f = i[l];
    if (f > 0) {
      let p = "cell";
      u.firstChild && (p = u.firstChild.type.spec.tableRole);
      const m = [];
      for (let v = 0; v < f; v++) {
        const y = Dt(t.schema)[p].createAndFill();
        y && m.push(y);
      }
      const g = (l == 0 || s == l - 1) && a == l ? c + 1 : d - 1;
      o.insert(o.mapping.map(g), m);
    }
    c = d;
  }
  return o.setMeta(cne, { fixTables: !0 });
}
function bo(t) {
  const e = t.selection, n = np(t), o = n.node(-1), r = n.start(-1), i = dt.get(o);
  return { ...e instanceof Xe ? i.rectBetween(
    e.$anchorCell.pos - r,
    e.$headCell.pos - r
  ) : i.findCell(n.pos - r), tableStart: r, map: i, table: o };
}
function HE(t, { map: e, tableStart: n, table: o }, r) {
  let i = r > 0 ? -1 : 0;
  one(e, o, r + i) && (i = r == 0 || r == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const a = s * e.width + r;
    if (r > 0 && r < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = o.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        NE(c.attrs, r - e.colCount(l))
      ), s += c.attrs.rowspan - 1;
    } else {
      const l = i == null ? Dt(o.type.schema).cell : o.nodeAt(e.map[a + i]).type, c = e.positionAt(s, r, o);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function dne(t, e) {
  if (!Yn(t)) return !1;
  if (e) {
    const n = bo(t);
    e(HE(t.tr, n, n.left));
  }
  return !0;
}
function fne(t, e) {
  if (!Yn(t)) return !1;
  if (e) {
    const n = bo(t);
    e(HE(t.tr, n, n.right));
  }
  return !0;
}
function pne(t, { map: e, table: n, tableStart: o }, r) {
  const i = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const a = s * e.width + r, l = e.map[a], c = n.nodeAt(l), u = c.attrs;
    if (r > 0 && e.map[a - 1] == l || r < e.width - 1 && e.map[a + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(i).map(o + l),
        null,
        Ti(u, r - e.colCount(l))
      );
    else {
      const d = t.mapping.slice(i).map(o + l);
      t.delete(d, d + c.nodeSize);
    }
    s += u.rowspan;
  }
}
function hne(t, e) {
  if (!Yn(t)) return !1;
  if (e) {
    const n = bo(t), o = t.tr;
    if (n.left == 0 && n.right == n.map.width) return !1;
    for (let r = n.right - 1; pne(o, n, r), r != n.left; r--) {
      const i = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc;
      if (!i)
        throw RangeError("No table found");
      n.table = i, n.map = dt.get(i);
    }
    e(o);
  }
  return !0;
}
function mne(t, e, n) {
  var o;
  const r = Dt(e.type.schema).header_cell;
  for (let i = 0; i < t.width; i++)
    if (((o = e.nodeAt(t.map[i + n * t.width])) == null ? void 0 : o.type) != r)
      return !1;
  return !0;
}
function VE(t, { map: e, tableStart: n, table: o }, r) {
  var i;
  let s = n;
  for (let c = 0; c < r; c++) s += o.child(c).nodeSize;
  const a = [];
  let l = r > 0 ? -1 : 0;
  mne(e, o, r + l) && (l = r == 0 || r == e.height ? null : 0);
  for (let c = 0, u = e.width * r; c < e.width; c++, u++)
    if (r > 0 && r < e.height && e.map[u] == e.map[u - e.width]) {
      const d = e.map[u], f = o.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const d = l == null ? Dt(o.type.schema).cell : (i = o.nodeAt(e.map[u + l * e.width])) == null ? void 0 : i.type, f = d == null ? void 0 : d.createAndFill();
      f && a.push(f);
    }
  return t.insert(s, Dt(o.type.schema).row.create(null, a)), t;
}
function gne(t, e) {
  if (!Yn(t)) return !1;
  if (e) {
    const n = bo(t);
    e(VE(t.tr, n, n.top));
  }
  return !0;
}
function vne(t, e) {
  if (!Yn(t)) return !1;
  if (e) {
    const n = bo(t);
    e(VE(t.tr, n, n.bottom));
  }
  return !0;
}
function yne(t, { map: e, table: n, tableStart: o }, r) {
  let i = 0;
  for (let c = 0; c < r; c++) i += n.child(c).nodeSize;
  const s = i + n.child(r).nodeSize, a = t.mapping.maps.length;
  t.delete(i + o, s + o);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = r * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!l.has(d)) {
      if (l.add(d), r > 0 && d == e.map[u - e.width]) {
        const f = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(d + o), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (r < e.height && d == e.map[u + e.width]) {
        const f = n.nodeAt(d), p = f.attrs, m = f.type.create(
          { ...p, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), g = e.positionAt(r + 1, c, n);
        t.insert(t.mapping.slice(a).map(o + g), m), c += p.colspan - 1;
      }
    }
  }
}
function bne(t, e) {
  if (!Yn(t)) return !1;
  if (e) {
    const n = bo(t), o = t.tr;
    if (n.top == 0 && n.bottom == n.map.height) return !1;
    for (let r = n.bottom - 1; yne(o, n, r), r != n.top; r--) {
      const i = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc;
      if (!i)
        throw RangeError("No table found");
      n.table = i, n.map = dt.get(n.table);
    }
    e(o);
  }
  return !0;
}
function T2(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function wne({ width: t, height: e, map: n }, o) {
  let r = o.top * t + o.left, i = r, s = (o.bottom - 1) * t + o.left, a = r + (o.right - o.left - 1);
  for (let l = o.top; l < o.bottom; l++) {
    if (o.left > 0 && n[i] == n[i - 1] || o.right < t && n[a] == n[a + 1])
      return !0;
    i += t, a += t;
  }
  for (let l = o.left; l < o.right; l++) {
    if (o.top > 0 && n[r] == n[r - t] || o.bottom < e && n[s] == n[s + t])
      return !0;
    r++, s++;
  }
  return !1;
}
function O2(t, e) {
  const n = t.selection;
  if (!(n instanceof Xe) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const o = bo(t), { map: r } = o;
  if (wne(r, o)) return !1;
  if (e) {
    const i = t.tr, s = {};
    let a = K.empty, l, c;
    for (let u = o.top; u < o.bottom; u++)
      for (let d = o.left; d < o.right; d++) {
        const f = r.map[u * r.width + d], p = o.table.nodeAt(f);
        if (!(s[f] || !p))
          if (s[f] = !0, l == null)
            l = f, c = p;
          else {
            T2(p) || (a = a.append(p.content));
            const m = i.mapping.map(f + o.tableStart);
            i.delete(m, m + p.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (i.setNodeMarkup(l + o.tableStart, null, {
      ...NE(
        c.attrs,
        c.attrs.colspan,
        o.right - o.left - c.attrs.colspan
      ),
      rowspan: o.bottom - o.top
    }), a.size) {
      const u = l + 1 + c.content.size, d = T2(c) ? l + 1 : u;
      i.replaceWith(d + o.tableStart, u + o.tableStart, a);
    }
    i.setSelection(
      new Xe(i.doc.resolve(l + o.tableStart))
    ), e(i);
  }
  return !0;
}
function M2(t, e) {
  const n = Dt(t.schema);
  return xne(({ node: o }) => n[o.type.spec.tableRole])(t, e);
}
function xne(t) {
  return (e, n) => {
    var o;
    const r = e.selection;
    let i, s;
    if (r instanceof Xe) {
      if (r.$anchorCell.pos != r.$headCell.pos) return !1;
      i = r.$anchorCell.nodeAfter, s = r.$anchorCell.pos;
    } else {
      if (i = ene(r.$from), !i) return !1;
      s = (o = aa(r.$from)) == null ? void 0 : o.pos;
    }
    if (i == null || s == null || i.attrs.colspan == 1 && i.attrs.rowspan == 1)
      return !1;
    if (n) {
      let a = i.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const u = bo(e), d = e.tr;
      for (let p = 0; p < u.right - u.left; p++)
        l.push(
          c ? {
            ...a,
            colwidth: c && c[p] ? [c[p]] : null
          } : a
        );
      let f;
      for (let p = u.top; p < u.bottom; p++) {
        let m = u.map.positionAt(p, u.left, u.table);
        p == u.top && (m += i.nodeSize);
        for (let g = u.left, v = 0; g < u.right; g++, v++)
          g == u.left && p == u.top || d.insert(
            f = d.mapping.map(m + u.tableStart, 1),
            t({ node: i, row: p, col: g }).createAndFill(l[v])
          );
      }
      d.setNodeMarkup(
        s,
        t({ node: i, row: u.top, col: u.left }),
        l[0]
      ), r instanceof Xe && d.setSelection(
        new Xe(
          d.doc.resolve(r.$anchorCell.pos),
          f ? d.doc.resolve(f) : void 0
        )
      ), n(d);
    }
    return !0;
  };
}
function Cne(t, e) {
  return function(n, o) {
    if (!Yn(n)) return !1;
    const r = np(n);
    if (r.nodeAfter.attrs[t] === e) return !1;
    if (o) {
      const i = n.tr;
      n.selection instanceof Xe ? n.selection.forEachCell((s, a) => {
        s.attrs[t] !== e && i.setNodeMarkup(a, null, {
          ...s.attrs,
          [t]: e
        });
      }) : i.setNodeMarkup(r.pos, null, {
        ...r.nodeAfter.attrs,
        [t]: e
      }), o(i);
    }
    return !0;
  };
}
function Sne(t) {
  return function(e, n) {
    if (!Yn(e)) return !1;
    if (n) {
      const o = Dt(e.schema), r = bo(e), i = e.tr, s = r.map.cellsInRect(
        t == "column" ? {
          left: r.left,
          top: 0,
          right: r.right,
          bottom: r.map.height
        } : t == "row" ? {
          left: 0,
          top: r.top,
          right: r.map.width,
          bottom: r.bottom
        } : r
      ), a = s.map((l) => r.table.nodeAt(l));
      for (let l = 0; l < s.length; l++)
        a[l].type == o.header_cell && i.setNodeMarkup(
          r.tableStart + s[l],
          o.cell,
          a[l].attrs
        );
      if (i.steps.length == 0)
        for (let l = 0; l < s.length; l++)
          i.setNodeMarkup(
            r.tableStart + s[l],
            o.header_cell,
            a[l].attrs
          );
      n(i);
    }
    return !0;
  };
}
function I2(t, e, n) {
  const o = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let r = 0; r < o.length; r++) {
    const i = e.table.nodeAt(o[r]);
    if (i && i.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function Dl(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? Sne(t) : function(n, o) {
    if (!Yn(n)) return !1;
    if (o) {
      const r = Dt(n.schema), i = bo(n), s = n.tr, a = I2("row", i, r), l = I2(
        "column",
        i,
        r
      ), u = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: i.map.height
      } : t == "row" ? {
        left: u,
        top: 0,
        right: i.map.width,
        bottom: 1
      } : i, f = t == "column" ? l ? r.cell : r.header_cell : t == "row" ? a ? r.cell : r.header_cell : r.cell;
      i.map.cellsInRect(d).forEach((p) => {
        const m = p + i.tableStart, g = s.doc.nodeAt(m);
        g && s.setNodeMarkup(m, f, g.attrs);
      }), o(s);
    }
    return !0;
  };
}
Dl("row", {
  useDeprecatedLogic: !0
});
Dl("column", {
  useDeprecatedLogic: !0
});
var kne = Dl("cell", {
  useDeprecatedLogic: !0
});
function Ene(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n) return t.pos - n.nodeSize;
    for (let o = t.index(-1) - 1, r = t.before(); o >= 0; o--) {
      const i = t.node(-1).child(o), s = i.lastChild;
      if (s)
        return r - 1 - s.nodeSize;
      r -= i.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let o = t.indexAfter(-1), r = t.after(); o < n.childCount; o++) {
      const i = n.child(o);
      if (i.childCount) return r + 1;
      r += i.nodeSize;
    }
  }
  return null;
}
function R2(t) {
  return function(e, n) {
    if (!Yn(e)) return !1;
    const o = Ene(np(e), t);
    if (o == null) return !1;
    if (n) {
      const r = e.doc.resolve(o);
      n(
        e.tr.setSelection(ce.between(r, nne(r))).scrollIntoView()
      );
    }
    return !0;
  };
}
function _ne(t, e) {
  const n = t.selection.$anchor;
  for (let o = n.depth; o > 0; o--)
    if (n.node(o).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(o), n.after(o)).scrollIntoView()
      ), !0;
  return !1;
}
function ou(t, e) {
  const n = t.selection;
  if (!(n instanceof Xe)) return !1;
  if (e) {
    const o = t.tr, r = Dt(t.schema).cell.createAndFill().content;
    n.forEachCell((i, s) => {
      i.content.eq(r) || o.replace(
        o.mapping.map(s + 1),
        o.mapping.map(s + i.nodeSize - 1),
        new te(r, 0, 0)
      );
    }), o.docChanged && e(o);
  }
  return !0;
}
function Ane(t) {
  if (!t.size) return null;
  let { content: e, openStart: n, openEnd: o } = t;
  for (; e.childCount == 1 && (n > 0 && o > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, o--, e = e.child(0).content;
  const r = e.child(0), i = r.type.spec.tableRole, s = r.type.schema, a = [];
  if (i == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, o - 1);
      (u || d) && (c = gg(
        Dt(s).row,
        new te(c, u, d)
      ).content), a.push(c);
    }
  else if (i == "cell" || i == "header_cell")
    a.push(
      n || o ? gg(
        Dt(s).row,
        new te(e, n, o)
      ).content : e
    );
  else
    return null;
  return Tne(s, a);
}
function Tne(t, e) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (let s = i.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = i.child(s).attrs;
      for (let c = r; c < r + a; c++)
        n[c] = (n[c] || 0) + l;
    }
  }
  let o = 0;
  for (let r = 0; r < n.length; r++) o = Math.max(o, n[r]);
  for (let r = 0; r < n.length; r++)
    if (r >= e.length && e.push(K.empty), n[r] < o) {
      const i = Dt(t).cell.createAndFill(), s = [];
      for (let a = n[r]; a < o; a++)
        s.push(i);
      e[r] = e[r].append(K.from(s));
    }
  return { height: e.length, width: o, rows: e };
}
function gg(t, e) {
  const n = t.createAndFill();
  return new Tg(n).replace(0, n.content.size, e).doc;
}
function One({ width: t, height: e, rows: n }, o, r) {
  if (t != o) {
    const i = [], s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let u = i[a] || 0, d = 0; u < o; d++) {
        let f = l.child(d % l.childCount);
        u + f.attrs.colspan > o && (f = f.type.createChecked(
          Ti(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - o
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let p = 1; p < f.attrs.rowspan; p++)
          i[a + p] = (i[a + p] || 0) + f.attrs.colspan;
      }
      s.push(K.from(c));
    }
    n = s, t = o;
  }
  if (e != r) {
    const i = [];
    for (let s = 0, a = 0; s < r; s++, a++) {
      const l = [], c = n[a % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        s + d.attrs.rowspan > r && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, r - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      i.push(K.from(l));
    }
    n = i, e = r;
  }
  return { width: t, height: e, rows: n };
}
function Mne(t, e, n, o, r, i, s) {
  const a = t.doc.type.schema, l = Dt(a);
  let c, u;
  if (r > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const p = n.child(d);
      f += p.nodeSize;
      const m = [];
      let g;
      p.lastChild == null || p.lastChild.type == l.cell ? g = c || (c = l.cell.createAndFill()) : g = u || (u = l.header_cell.createAndFill());
      for (let v = e.width; v < r; v++) m.push(g);
      t.insert(t.mapping.slice(s).map(f - 1 + o), m);
    }
  if (i > e.height) {
    const d = [];
    for (let m = 0, g = (e.height - 1) * e.width; m < Math.max(e.width, r); m++) {
      const v = m >= e.width ? !1 : n.nodeAt(e.map[g + m]).type == l.header_cell;
      d.push(
        v ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, K.from(d)), p = [];
    for (let m = e.height; m < i; m++) p.push(f);
    t.insert(t.mapping.slice(s).map(o + n.nodeSize - 2), p);
  }
  return !!(c || u);
}
function $2(t, e, n, o, r, i, s, a) {
  if (s == 0 || s == e.height) return !1;
  let l = !1;
  for (let c = r; c < i; c++) {
    const u = s * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      l = !0;
      const f = n.nodeAt(d), { top: p, left: m } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(a).map(d + o), null, {
        ...f.attrs,
        rowspan: s - p
      }), t.insert(
        t.mapping.slice(a).map(e.positionAt(s, m, n)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: p + f.attrs.rowspan - s
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function P2(t, e, n, o, r, i, s, a) {
  if (s == 0 || s == e.width) return !1;
  let l = !1;
  for (let c = r; c < i; c++) {
    const u = c * e.width + s, d = e.map[u];
    if (e.map[u - 1] == d) {
      l = !0;
      const f = n.nodeAt(d), p = e.colCount(d), m = t.mapping.slice(a).map(d + o);
      t.setNodeMarkup(
        m,
        null,
        Ti(
          f.attrs,
          s - p,
          f.attrs.colspan - (s - p)
        )
      ), t.insert(
        m + f.nodeSize,
        f.type.createAndFill(
          Ti(f.attrs, 0, s - p)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function L2(t, e, n, o, r) {
  let i = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!i)
    throw new Error("No table found");
  let s = dt.get(i);
  const { top: a, left: l } = o, c = l + r.width, u = a + r.height, d = t.tr;
  let f = 0;
  function p() {
    if (i = n ? d.doc.nodeAt(n - 1) : d.doc, !i)
      throw new Error("No table found");
    s = dt.get(i), f = d.mapping.maps.length;
  }
  Mne(d, s, i, n, c, u, f) && p(), $2(d, s, i, n, l, c, a, f) && p(), $2(d, s, i, n, l, c, u, f) && p(), P2(d, s, i, n, a, u, l, f) && p(), P2(d, s, i, n, a, u, c, f) && p();
  for (let m = a; m < u; m++) {
    const g = s.positionAt(m, l, i), v = s.positionAt(m, c, i);
    d.replace(
      d.mapping.slice(f).map(g + n),
      d.mapping.slice(f).map(v + n),
      new te(r.rows[m - a], 0, 0)
    );
  }
  p(), d.setSelection(
    new Xe(
      d.doc.resolve(n + s.positionAt(a, l, i)),
      d.doc.resolve(n + s.positionAt(u - 1, c - 1, i))
    )
  ), e(d);
}
var Ine = zg({
  ArrowLeft: ru("horiz", -1),
  ArrowRight: ru("horiz", 1),
  ArrowUp: ru("vert", -1),
  ArrowDown: ru("vert", 1),
  "Shift-ArrowLeft": iu("horiz", -1),
  "Shift-ArrowRight": iu("horiz", 1),
  "Shift-ArrowUp": iu("vert", -1),
  "Shift-ArrowDown": iu("vert", 1),
  Backspace: ou,
  "Mod-Backspace": ou,
  Delete: ou,
  "Mod-Delete": ou
});
function Ou(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function ru(t, e) {
  return (n, o, r) => {
    if (!r) return !1;
    const i = n.selection;
    if (i instanceof Xe)
      return Ou(
        n,
        o,
        fe.near(i.$headCell, e)
      );
    if (t != "horiz" && !i.empty) return !1;
    const s = UE(r, t, e);
    if (s == null) return !1;
    if (t == "horiz")
      return Ou(
        n,
        o,
        fe.near(n.doc.resolve(i.head + e), e)
      );
    {
      const a = n.doc.resolve(s), l = DE(a, t, e);
      let c;
      return l ? c = fe.near(l, 1) : e < 0 ? c = fe.near(n.doc.resolve(a.before(-1)), -1) : c = fe.near(n.doc.resolve(a.after(-1)), 1), Ou(n, o, c);
    }
  };
}
function iu(t, e) {
  return (n, o, r) => {
    if (!r) return !1;
    const i = n.selection;
    let s;
    if (i instanceof Xe)
      s = i;
    else {
      const l = UE(r, t, e);
      if (l == null) return !1;
      s = new Xe(n.doc.resolve(l));
    }
    const a = DE(s.$headCell, t, e);
    return a ? Ou(
      n,
      o,
      new Xe(s.$anchorCell, a)
    ) : !1;
  };
}
function Rne(t, e) {
  const n = t.state.doc, o = aa(n.resolve(e));
  return o ? (t.dispatch(t.state.tr.setSelection(new Xe(o))), !0) : !1;
}
function $ne(t, e, n) {
  if (!Yn(t.state)) return !1;
  let o = Ane(n);
  const r = t.state.selection;
  if (r instanceof Xe) {
    o || (o = {
      width: 1,
      height: 1,
      rows: [
        K.from(
          gg(Dt(t.state.schema).cell, n)
        )
      ]
    });
    const i = r.$anchorCell.node(-1), s = r.$anchorCell.start(-1), a = dt.get(i).rectBetween(
      r.$anchorCell.pos - s,
      r.$headCell.pos - s
    );
    return o = One(o, a.right - a.left, a.bottom - a.top), L2(t.state, t.dispatch, s, a, o), !0;
  } else if (o) {
    const i = np(t.state), s = i.start(-1);
    return L2(
      t.state,
      t.dispatch,
      s,
      dt.get(i.node(-1)).findCell(i.pos - s),
      o
    ), !0;
  } else
    return !1;
}
function Pne(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey) return;
  const o = D2(t, e.target);
  let r;
  if (e.shiftKey && t.state.selection instanceof Xe)
    i(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && o && (r = aa(t.state.selection.$anchor)) != null && ((n = Ah(t, e)) == null ? void 0 : n.pos) != r.pos)
    i(r, e), e.preventDefault();
  else if (!o)
    return;
  function i(l, c) {
    let u = Ah(t, c);
    const d = pr.getState(t.state) == null;
    if (!u || !Bv(l, u))
      if (d) u = l;
      else return;
    const f = new Xe(l, u);
    if (d || !t.state.selection.eq(f)) {
      const p = t.state.tr.setSelection(f);
      d && p.setMeta(pr, l.pos), t.dispatch(p);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", a), pr.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(pr, -1));
  }
  function a(l) {
    const c = l, u = pr.getState(t.state);
    let d;
    if (u != null)
      d = t.state.doc.resolve(u);
    else if (D2(t, c.target) != o && (d = Ah(t, e), !d))
      return s();
    d && i(d, c);
  }
  t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", a);
}
function UE(t, e, n) {
  if (!(t.state.selection instanceof ce)) return null;
  const { $head: o } = t.state.selection;
  for (let r = o.depth - 1; r >= 0; r--) {
    const i = o.node(r);
    if ((n < 0 ? o.index(r) : o.indexAfter(r)) != (n < 0 ? 0 : i.childCount)) return null;
    if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
      const a = o.before(r), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function D2(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Ah(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? aa(t.state.doc.resolve(n.pos)) : null;
}
var Lne = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), vg(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, vg(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function vg(t, e, n, o, r, i) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u) {
    for (let d = 0, f = 0; d < u.childCount; d++) {
      const { colspan: p, colwidth: m } = u.child(d).attrs;
      for (let g = 0; g < p; g++, f++) {
        const v = r == f ? i : m && m[g], y = v ? v + "px" : "";
        if (a += v || o, v || (l = !1), c)
          c.style.width != y && (c.style.width = y), c = c.nextSibling;
        else {
          const w = document.createElement("col");
          w.style.width = y, e.appendChild(w);
        }
      }
    }
    for (; c; ) {
      const d = c.nextSibling;
      (s = c.parentNode) == null || s.removeChild(c), c = d;
    }
    l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }
}
var dn = new Ne(
  "tableColumnResizing"
);
function Dne({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: o = Lne,
  lastColumnResizable: r = !0
} = {}) {
  const i = new De({
    key: dn,
    state: {
      init(s, a) {
        var l, c;
        const u = (c = (l = i.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, d = Dt(a.schema).table.name;
        return o && u && (u[d] = (f, p) => new o(f, n, p)), new Nne(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const a = dn.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          Bne(s, a, t, r);
        },
        mouseleave: (s) => {
          Fne(s);
        },
        mousedown: (s, a) => {
          zne(s, a, e, n);
        }
      },
      decorations: (s) => {
        const a = dn.getState(s);
        if (a && a.activeHandle > -1)
          return Wne(s, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return i;
}
var Nne = class Mu {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, o = e.getMeta(dn);
    if (o && o.setHandle != null)
      return new Mu(o.setHandle, !1);
    if (o && o.setDragging !== void 0)
      return new Mu(n.activeHandle, o.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let r = e.mapping.map(n.activeHandle, -1);
      return mg(e.doc.resolve(r)) || (r = -1), new Mu(r, n.dragging);
    }
    return n;
  }
};
function Bne(t, e, n, o) {
  if (!t.editable) return;
  const r = dn.getState(t.state);
  if (r && !r.dragging) {
    const i = Vne(e.target);
    let s = -1;
    if (i) {
      const { left: a, right: l } = i.getBoundingClientRect();
      e.clientX - a <= n ? s = N2(t, e, "left", n) : l - e.clientX <= n && (s = N2(t, e, "right", n));
    }
    if (s != r.activeHandle) {
      if (!o && s !== -1) {
        const a = t.state.doc.resolve(s), l = a.node(-1), c = dt.get(l), u = a.start(-1);
        if (c.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      jE(t, s);
    }
  }
}
function Fne(t) {
  if (!t.editable) return;
  const e = dn.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && jE(t, -1);
}
function zne(t, e, n, o) {
  var r;
  if (!t.editable) return !1;
  const i = (r = t.dom.ownerDocument.defaultView) != null ? r : window, s = dn.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging)
    return !1;
  const a = t.state.doc.nodeAt(s.activeHandle), l = Hne(t, s.activeHandle, a.attrs);
  t.dispatch(
    t.state.tr.setMeta(dn, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(d) {
    i.removeEventListener("mouseup", c), i.removeEventListener("mousemove", u);
    const f = dn.getState(t.state);
    f != null && f.dragging && (Une(
      t,
      f.activeHandle,
      B2(f.dragging, d, n)
    ), t.dispatch(
      t.state.tr.setMeta(dn, { setDragging: null })
    ));
  }
  function u(d) {
    if (!d.which) return c(d);
    const f = dn.getState(t.state);
    if (f && f.dragging) {
      const p = B2(f.dragging, d, n);
      F2(
        t,
        f.activeHandle,
        p,
        o
      );
    }
  }
  return F2(
    t,
    s.activeHandle,
    l,
    o
  ), i.addEventListener("mouseup", c), i.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function Hne(t, e, { colspan: n, colwidth: o }) {
  const r = o && o[o.length - 1];
  if (r) return r;
  const i = t.domAtPos(e);
  let a = i.node.childNodes[i.offset].offsetWidth, l = n;
  if (o)
    for (let c = 0; c < n; c++)
      o[c] && (a -= o[c], l--);
  return a / l;
}
function Vne(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function N2(t, e, n, o) {
  const r = n == "right" ? -o : o, i = t.posAtCoords({
    left: e.clientX + r,
    top: e.clientY
  });
  if (!i) return -1;
  const { pos: s } = i, a = aa(t.state.doc.resolve(s));
  if (!a) return -1;
  if (n == "right") return a.pos;
  const l = dt.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function B2(t, e, n) {
  const o = e.clientX - t.startX;
  return Math.max(n, t.startWidth + o);
}
function jE(t, e) {
  t.dispatch(
    t.state.tr.setMeta(dn, { setHandle: e })
  );
}
function Une(t, e, n) {
  const o = t.state.doc.resolve(e), r = o.node(-1), i = dt.get(r), s = o.start(-1), a = i.colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < i.height; c++) {
    const u = c * i.width + a;
    if (c && i.map[u] == i.map[u - i.width]) continue;
    const d = i.map[u], f = r.nodeAt(d).attrs, p = f.colspan == 1 ? 0 : a - i.colCount(d);
    if (f.colwidth && f.colwidth[p] == n) continue;
    const m = f.colwidth ? f.colwidth.slice() : jne(f.colspan);
    m[p] = n, l.setNodeMarkup(s + d, null, { ...f, colwidth: m });
  }
  l.docChanged && t.dispatch(l);
}
function F2(t, e, n, o) {
  const r = t.state.doc.resolve(e), i = r.node(-1), s = r.start(-1), a = dt.get(i).colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(r.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && vg(
    i,
    l.firstChild,
    l,
    o,
    a,
    n
  );
}
function jne(t) {
  return Array(t).fill(0);
}
function Wne(t, e) {
  var n;
  const o = [], r = t.doc.resolve(e), i = r.node(-1);
  if (!i)
    return Te.empty;
  const s = dt.get(i), a = r.start(-1), l = s.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < s.height; c++) {
    const u = l + c * s.width;
    if ((l == s.width - 1 || s.map[u] != s.map[u + 1]) && (c == 0 || s.map[u] != s.map[u - s.width])) {
      const d = s.map[u], f = a + d + i.nodeAt(d).nodeSize - 1, p = document.createElement("div");
      p.className = "column-resize-handle", (n = dn.getState(t)) != null && n.dragging && o.push(
        ft.node(
          a + d,
          a + d + i.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), o.push(ft.widget(f, p));
    }
  }
  return Te.create(t.doc, o);
}
function Kne({
  allowTableNodeSelection: t = !1
} = {}) {
  return new De({
    key: pr,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const o = e.getMeta(pr);
        if (o != null) return o == -1 ? null : o;
        if (n == null || !e.docChanged) return n;
        const { deleted: r, pos: i } = e.mapping.mapResult(n);
        return r ? null : i;
      }
    },
    props: {
      decorations: ine,
      handleDOMEvents: {
        mousedown: Pne
      },
      createSelectionBetween(e) {
        return pr.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: Rne,
      handleKeyDown: Ine,
      handlePaste: $ne
    },
    appendTransaction(e, n, o) {
      return lne(
        o,
        zE(o, n),
        t
      );
    }
  });
}
const Gne = (t, e, n) => {
  if (!t.doc)
    return t;
  const o = t.doc.nodeAt(e);
  if (!o || n === o.attrs.backgroundColor)
    return t;
  const r = {
    ...o.attrs,
    backgroundColor: n
  };
  return t.setNodeMarkup(e, o.type, r, o.marks);
}, qne = (t, e, n) => {
  const { doc: o, selection: r } = t;
  return !o || !r || !(r instanceof Xe) || r.forEachCell((i, s) => {
    t = Gne(t, s, n);
  }), t;
}, z2 = (t, e) => ({ tr: n, state: o, dispatch: r }) => {
  const { selection: i } = o;
  return n = n.setSelection(i), n = qne(n, e, t), n.docChanged ? (r == null || r(n), !0) : !1;
}, Yne = ke.create({
  name: "tableCellBackground",
  addOptions() {
    return {
      types: ["tableCell"],
      HTMLAttributes: {}
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            parseHTML: (t) => t.style.backgroundColor || "",
            renderHTML: (t) => !t.backgroundColor || t.backgroundColor === "" ? {} : {
              style: `background-color: ${t.backgroundColor}`
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTableCellBackground: (t) => z2(t, this.options),
      unsetTableCellBackground: () => z2("", this.options)
    };
  }
}), Jne = Ze.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", Le(this.options.HTMLAttributes, t), 0];
  }
}), Xne = Ze.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", Le(this.options.HTMLAttributes, t), 0];
  }
}), Zne = Ze.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", Le(this.options.HTMLAttributes, t), 0];
  }
});
function yg(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function H2(t, e, n, o, r, i) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u !== null)
    for (let d = 0, f = 0; d < u.childCount; d += 1) {
      const { colspan: p, colwidth: m } = u.child(d).attrs;
      for (let g = 0; g < p; g += 1, f += 1) {
        const v = r === f ? i : m && m[g], y = v ? `${v}px` : "";
        if (a += v || o, v || (l = !1), c) {
          if (c.style.width !== y) {
            const [w, x] = yg(o, v);
            c.style.setProperty(w, x);
          }
          c = c.nextSibling;
        } else {
          const w = document.createElement("col"), [x, b] = yg(o, v);
          w.style.setProperty(x, b), e.appendChild(w);
        }
      }
    }
  for (; c; ) {
    const d = c.nextSibling;
    (s = c.parentNode) === null || s === void 0 || s.removeChild(c), c = d;
  }
  l ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
}
class Qne {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), H2(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, H2(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function eoe(t, e, n, o) {
  let r = 0, i = !0;
  const s = [], a = t.firstChild;
  if (!a)
    return {};
  for (let d = 0, f = 0; d < a.childCount; d += 1) {
    const { colspan: p, colwidth: m } = a.child(d).attrs;
    for (let g = 0; g < p; g += 1, f += 1) {
      const v = n === f ? o : m && m[g];
      r += v || e, v || (i = !1);
      const [y, w] = yg(e, v);
      s.push([
        "col",
        { style: `${y}: ${w}` }
      ]);
    }
  }
  const l = i ? `${r}px` : "", c = i ? "" : `${r}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: c };
}
function V2(t, e) {
  return t.createAndFill();
}
function toe(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const o = t.nodes[n];
    o.spec.tableRole && (e[o.spec.tableRole] = o);
  }), t.cached.tableNodeTypes = e, e;
}
function noe(t, e, n, o, r) {
  const i = toe(t), s = [], a = [];
  for (let c = 0; c < n; c += 1) {
    const u = V2(i.cell);
    if (u && a.push(u), o) {
      const d = V2(i.header_cell);
      d && s.push(d);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(i.row.createChecked(null, o && c === 0 ? s : a));
  return i.table.createChecked(null, l);
}
function ooe(t) {
  return t instanceof Xe;
}
const su = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!ooe(e))
    return !1;
  let n = 0;
  const o = OC(e.ranges[0].$from, (i) => i.type.name === "table");
  return o == null || o.node.descendants((i) => {
    if (i.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, roe = Ze.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: Qne,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: o, tableMinWidth: r } = eoe(t, this.options.cellMinWidth);
    return [
      "table",
      Le(this.options.HTMLAttributes, e, {
        style: o ? `width: ${o}` : `min-width: ${r}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: o, dispatch: r, editor: i }) => {
        const s = noe(i.schema, t, e, n);
        if (r) {
          const a = o.selection.from + 1;
          o.replaceSelectionWith(s).scrollIntoView().setSelection(ce.near(o.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => dne(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => fne(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => hne(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => gne(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => vne(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => bne(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => _ne(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => O2(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => M2(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => Dl("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => Dl("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => kne(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => O2(t, e) ? !0 : M2(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: o }) => Cne(t, e)(n, o),
      goToNextCell: () => ({ state: t, dispatch: e }) => R2(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => R2(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && zE(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const o = Xe.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(o);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: su,
      "Mod-Backspace": su,
      Delete: su,
      "Mod-Delete": su
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        Dne({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      Kne({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: Se(ie(t, "tableRole", e))
    };
  }
}), ioe = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, soe = /CrOS/, aoe = /android|ipad|playbook|silk/i;
function U2(t = {}) {
  let e = t.ua || typeof navigator < "u" && navigator.userAgent;
  return e && typeof e == "object" && e.headers && typeof e.headers["user-agent"] == "string" && (e = e.headers["user-agent"]), typeof e != "string" ? !1 : !!(ioe.test(e) && !soe.test(e) || t.tablet && aoe.test(e) || t.tablet && t.featureDetect && navigator && navigator.maxTouchPoints > 1 && e.includes("Macintosh") && e.includes("Safari"));
}
const loe = ["disabled"], coe = {
  "content-class": "table-grid-size-editor",
  "content-style": "padding:0"
}, uoe = { class: "flex flex-col flex-wrap gap-1 justify-between" }, doe = ["onMouseover", "onMousedown"], foe = { class: "text-center text-sm text-zinc-600 mt-2" }, poe = /* @__PURE__ */ I({
  __name: "CreateTablePopover",
  props: {
    disabled: {
      default: !1
    }
  },
  emits: ["create-table"],
  setup(t, { emit: e }) {
    const n = e, o = R(!1), r = R(!0), i = hn({
      rows: U2() ? Ec : kc,
      cols: U2() ? Ec : kc
    }), s = hn({
      rows: _c,
      cols: _c
    });
    function a(u, d) {
      u === i.rows && (i.rows = Math.min(u + 1, Ec)), d === i.cols && (i.cols = Math.min(d + 1, Ec)), s.rows = u, s.cols = d;
    }
    function l(u, d) {
      n("create-table", { rows: u, cols: d, withHeaderRow: h(r) }), c();
    }
    function c() {
      o.value = !1, r.value = !1, i.rows = kc, i.cols = kc, s.rows = _c, s.cols = _c;
    }
    return (u, d) => (E(), T(h(Vr), null, {
      default: C(() => [
        _(h(jr), { "as-child": "" }, {
          default: C(() => [
            N("button", {
              disabled: t.disabled,
              class: "m-0 p-0"
            }, [
              D(u.$slots, "trigger")
            ], 8, loe)
          ]),
          _: 3
        }),
        _(h(Ur), {
          class: "w-full",
          align: "start",
          side: "bottom"
        }, {
          default: C(() => [
            N("div", coe, [
              N("div", uoe, [
                (E(!0), W(me, null, Oe(i.rows, (f) => (E(), W("div", {
                  key: "r" + f,
                  class: "flex gap-1"
                }, [
                  (E(!0), W(me, null, Oe(i.cols, (p) => (E(), W("div", {
                    key: "c" + p,
                    class: He([[
                      p <= s.cols && f <= s.rows && "bg-foreground border-border",
                      "cursor-pointer"
                    ], "pa-1"]),
                    onMouseover: (m) => a(f, p),
                    onMousedown: (m) => l(f, p)
                  }, d[0] || (d[0] = [
                    N("div", { class: "w-4 h-4 p-1 border box-border" }, null, -1)
                  ]), 42, doe))), 128))
                ]))), 128))
              ]),
              N("div", foe, Y(s.rows) + " x " + Y(s.cols), 1)
            ])
          ]),
          _: 1
        })
      ]),
      _: 3
    }));
  }
}), hoe = { style: { display: "flex" } }, moe = /* @__PURE__ */ I({
  __name: "TableActionButton",
  props: {
    editor: {},
    icon: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    function n(o) {
      e.disabled || e.editor.chain().focus().insertTable({ ...o, withHeaderRow: !1 }).run();
    }
    return (o, r) => (E(), T(poe, {
      onCreateTable: n,
      disabled: o.disabled
    }, {
      trigger: C(() => [
        N("div", hoe, [
          _(ge, {
            icon: o.icon,
            tooltip: o.tooltip,
            disabled: o.disabled,
            color: o.color,
            action: o.action,
            "is-active": o.isActive
          }, null, 8, ["icon", "tooltip", "disabled", "color", "action", "is-active"])
        ])
      ]),
      _: 1
    }, 8, ["disabled"]));
  }
}), Fre = roe.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      resizable: !0,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1,
      button: ({ editor: e, t: n }) => ({
        component: moe,
        componentProps: {
          disabled: !e.isEditable || e.isActive("table") || !1,
          icon: "Table",
          tooltip: n("editor.table.tooltip")
        }
      })
    };
  },
  addExtensions() {
    return [
      Xne.configure(this.options.tableRow),
      Jne.configure(this.options.tableHeader),
      Zne.configure(this.options.tableCell),
      Yne.configure(this.options.tableCellBackground)
    ];
  }
}), goe = /* @__PURE__ */ I({
  __name: "AIButton",
  props: {
    editor: {},
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    customClass: { default: "" },
    loading: { type: Boolean, default: !1 },
    tooltipOptions: { default: void 0 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, n = vn(), { toast: o } = oa();
    function r() {
      var s, a, l;
      const i = (a = (s = e.editor.extensionManager.extensions.find((c) => c.name === "AI")) == null ? void 0 : s.options) == null ? void 0 : a.completions;
      if (typeof i != "function") {
        o({
          title: "AI completions method is not set or is not a valid function",
          variant: "destructive"
        });
        return;
      }
      if (i.constructor.name !== "AsyncFunction") {
        o({
          title: "AI completions method must be an asynchronous function",
          variant: "destructive"
        });
        return;
      }
      n.state.AIMenu = !0, (l = e.editor) == null || l.commands.focus();
    }
    return (i, s) => (E(), T(ge, {
      action: r,
      title: "AI",
      disabled: i.disabled,
      icon: i.icon,
      tooltip: i.tooltip
    }, null, 8, ["disabled", "icon", "tooltip"]));
  }
}), zre = Ze.create({
  name: "AI",
  group: "block",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: ({ editor: e, t: n }) => ({
        component: goe,
        componentProps: {
          icon: "Sparkles",
          tooltip: n("editor.AI.ask")
        }
      })
    };
  }
}), Hre = ke.create({
  name: "painter",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ge,
        componentProps: {
          action: () => {
            e.commands.setPainter(e == null ? void 0 : e.state.selection.$head.marks());
          },
          icon: "PaintRoller",
          tooltip: o("editor.format")
        }
      })
    };
  },
  addCommands() {
    return {
      setPainter: (t) => ({
        view: {
          dispatch: e,
          state: { tr: n },
          dom: o
        }
      }) => {
        const s = `url("data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="#000" d="M9 22v-6H4V7q0-1.65 1.175-2.825T8 3h12v13h-5v6zM6 10h12V5h-1v4h-2V5h-1v2h-2V5H8q-.825 0-1.412.588T6 7zm0 4h12v-2H6zm0 0v-2z"/></svg>')}"), auto`;
        return o.style.cursor = s, e(n.setMeta("painterAction", { type: "start", marks: t })), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new De({
        key: new Ne("format-painter"),
        state: {
          init: () => [],
          apply: (t, e) => {
            const n = t.getMeta("painterAction");
            return n && n.type === "start" ? e = n.marks : n && n.type === "end" && (e = []), e;
          }
        },
        props: {
          handleDOMEvents: {
            mousedown(t, e) {
              const n = this.getState(t.state);
              if (!n || n.length == 0)
                return t.dom.style.cursor = "", !1;
              const o = () => {
                document.removeEventListener("mouseup", o);
                let {
                  dispatch: r,
                  state: { tr: i, selection: s },
                  dom: a
                } = t;
                a.style.cursor = "", i = i.removeMark(s.from, s.to);
                for (let l of n)
                  l.type.name != "link" && (i = i.addMark(s.from, s.to, l));
                r(i.setMeta("painterAction", { type: "end" }));
              };
              return document.addEventListener("mouseup", o), !0;
            }
          }
        }
      })
    ];
  }
});
function voe(t, e) {
  const n = atob(t.split(",")[1]), o = new Array(n.length);
  for (let i = 0; i < n.length; i++)
    o[i] = n.charCodeAt(i);
  const r = new Uint8Array(o);
  return new Blob([r], { type: e });
}
function yoe(t, e) {
  return new File([t], e, { type: t.type });
}
const Vre = ke.create({
  name: "importWord",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: void 0,
      convert: void 0,
      limit: 1024 * 1024 * 10,
      //10MB
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ge,
        componentProps: {
          action: () => {
            var r;
            return (r = e.commands) == null ? void 0 : r.toggleImportWord();
          },
          disabled: !e.can().setHorizontalRule(),
          icon: "Word",
          tooltip: o("editor.importWord.tooltip")
        }
      })
    };
  },
  addCommands() {
    return {
      toggleImportWord: () => ({ chain: t, editor: e }) => {
        const { toast: n } = oa(), { t: o } = Ge();
        async function r(l) {
          var p;
          const u = new DOMParser().parseFromString(l, "text/html"), d = u.querySelectorAll("img");
          if (!d.length)
            return u.body.innerHTML;
          if (Fe(e, "image")) {
            const m = (p = e.extensionManager.extensions.find(
              (g) => g.name === "importWord"
            )) == null ? void 0 : p.options;
            if (m && typeof m.upload == "function") {
              const g = [];
              for (let y of d) {
                const w = y.getAttribute("src"), x = voe(w, "image/jpeg"), b = yoe(x, "image.jpeg");
                g.push(b);
              }
              const v = await m.upload(g);
              for (let y = 0; y < d.length; y++) {
                const w = d[y];
                w.setAttribute("src", v[y].src);
                const x = w.parentElement;
                (x == null ? void 0 : x.tagName) === "P" && (x.insertAdjacentElement("beforebegin", w), !x.hasChildNodes() && x.textContent === "" && x.remove());
              }
              return u.body.innerHTML;
            } else
              return console.warn("Image Upload method found, skip image conversion"), u.body.innerHTML;
          } else
            return console.error("Image extension not found, unable to convert image"), u.body.innerHTML;
        }
        async function i(l) {
          const c = await r(l);
          e.chain().setContent(c.toString(), !0).run(), n({
            title: o.value("editor.importWord.success")
          });
        }
        const { open: s, onChange: a } = cz({
          accept: ".docx",
          reset: !0,
          multiple: !1
        });
        return s(), a(async (l) => {
          const [c] = Array.from(l ?? []);
          if (c) {
            if (c.size > this.options.limit) {
              n({
                title: o.value("editor.importWord.fileTooLarge"),
                variant: "destructive"
              });
              return;
            }
            if (this.options.convert) {
              const u = await this.options.convert(c);
              i(u);
            } else {
              const u = new FormData(), d = JSON.stringify({
                collaboration_features: {
                  comments: !0,
                  user_id: "e3",
                  track_changes: !0
                },
                formatting: {
                  resets: "none",
                  defaults: "inline",
                  styles: "inline",
                  comments: "basic"
                }
              });
              u.append("config", d), u.append("file", c), fetch("https://docx-converter.cke-cs.com/v2/convert/docx-html", {
                method: "POST",
                body: u
              }).then((f) => f.json()).then(async (f) => {
                i(f.html);
              }).catch((f) => {
                n({
                  title: o.value("editor.importWord.error"),
                  variant: "destructive"
                }), console.error("Error:", f);
              });
            }
          }
        }), !1;
      }
    };
  }
}), Gd = /* @__PURE__ */ I({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = L(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (E(), T(h(NW), j({
      class: h(ve)("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", e.class)
    }, n.value), {
      default: C(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), gs = new Ne("upload-image"), boe = () => new De({
  key: gs,
  state: {
    init() {
      return Te.empty;
    },
    apply(t, e) {
      e = e.map(t.mapping, t.doc);
      const n = t.getMeta(gs);
      return n != null && n.add ? n.add.forEach(({ id: o, pos: r, src: i }) => {
        const s = woe(i), a = ft.widget(r, s, { id: o });
        e = e.add(t.doc, [a]);
      }) : n != null && n.remove && n.remove.forEach((o) => {
        e = e.remove(e.find(void 0, void 0, (r) => r.id === o));
      }), e;
    }
  },
  props: {
    decorations(t) {
      return this.getState(t);
    }
  }
});
function woe(t) {
  const e = document.createElement("div"), n = document.createElement("img");
  return n.setAttribute("class", "opacity-50"), n.src = t, n.onload = () => {
    e.setAttribute("class", "img-placeholder");
  }, e.appendChild(n), e;
}
function xoe(t, e) {
  var r;
  const o = gs.getState(t).find(void 0, void 0, (i) => i.id === e);
  return o.length ? (r = o[0]) == null ? void 0 : r.from : null;
}
const WE = ({ validateFn: t, onUpload: e }) => (n, o, r) => {
  n.forEach((i) => {
    if (t && !t(i)) return;
    const s = Date.now().toString(), a = o.state.tr;
    a.selection.empty || a.deleteSelection();
    const l = URL.createObjectURL(i);
    a.setMeta(gs, {
      add: [{ id: s, pos: r, src: l }]
    }), o.dispatch(a), e(i).then(
      (c) => {
        var g;
        const { schema: u } = o.state, d = xoe(o.state, s);
        if (d === null) return;
        const f = typeof c == "object" ? l : c, p = (g = u.nodes.image) == null ? void 0 : g.create({ src: f });
        if (!p) return;
        const m = o.state.tr.replaceWith(d, d, p).setMeta(gs, { remove: [s] });
        o.dispatch(m);
      },
      () => {
        const c = o.state.tr.delete(r, r).setMeta(gs, { remove: [s] });
        o.dispatch(c);
      }
    );
  });
}, Coe = (t, e, n) => {
  var r;
  const o = Array.from(((r = e.clipboardData) == null ? void 0 : r.files) || []);
  if (o.length) {
    e.preventDefault();
    const i = t.state.selection.from;
    return n(o, t, i + 1), !0;
  }
  return !1;
}, Soe = (t, e, n, o) => {
  var i;
  const r = Array.from(((i = e.dataTransfer) == null ? void 0 : i.files) || []);
  if (!n && r.length) {
    e.preventDefault();
    const s = t.posAtCoords({
      left: e.clientX,
      top: e.clientY
    });
    if (s)
      return o(r, t, s.pos + 1), !0;
  }
  return !1;
}, koe = { class: "flex items-center w-full p-3 my-3 hover:bg-accent border border-border text-muted-foreground cursor-pointer rounded-sm transition-all" }, Eoe = { class: "flex justify-between items-center w-full" }, _oe = { class: "flex justify-center items-center gap-3" }, Aoe = { class: "text-sm" }, Toe = { class: "flex items-center gap-2" }, Ooe = /* @__PURE__ */ I({
  __name: "ImageUploader",
  props: {
    ...jl
  },
  setup(t) {
    const e = t, n = R(""), o = R(), { t: r } = Ge();
    function i(c) {
      var m, g;
      const u = (m = c == null ? void 0 : c.target) == null ? void 0 : m.files;
      if (!e.editor || e.editor.isDestroyed || u.length === 0) return;
      const d = u[0], f = (g = e.editor.extensionManager.extensions.find(
        (v) => v.name === "imageUpload"
      )) == null ? void 0 : g.options;
      WE({
        validateFn: (v) => !0,
        onUpload: f.upload
      })([d], e.editor.view, e.getPos());
    }
    function s() {
      e.editor.chain().setImage({ src: n.value }).deleteRange({ from: e.getPos(), to: e.getPos() }).focus().run();
    }
    function a() {
      e.deleteNode();
    }
    function l() {
      var c;
      (c = o.value) == null || c.click();
    }
    return (c, u) => (E(), T(h(Ul), {
      class: "p-0 m-0",
      "data-drag-handle": ""
    }, {
      default: C(() => [
        _(h(Vr), { defaultOpen: "" }, {
          default: C(() => [
            _(h(jr), { "as-child": "" }, {
              default: C(() => [
                N("div", koe, [
                  N("div", Eoe, [
                    N("div", _oe, [
                      _(h(ye), {
                        name: "ImageUp",
                        class: "w-6 h-6"
                      }),
                      N("span", Aoe, Y(h(r)("editor.image.dialog.title")), 1)
                    ]),
                    _(h(ye), {
                      name: "Trash2",
                      class: "hover:text-foreground",
                      onClick: mt(a, ["stop"])
                    })
                  ])
                ])
              ]),
              _: 1
            }),
            _(h(Ur), {
              trapFocus: "",
              class: "w-full",
              onOpenAutoFocus: (d) => d.preventDefault()
            }, {
              default: C(() => [
                _(h(mv), {
                  "default-value": "upload",
                  class: "w-[400px]",
                  activationMode: "manual"
                }, {
                  default: C(() => [
                    _(h(gv), { class: "grid w-full grid-cols-2" }, {
                      default: C(() => [
                        _(h($l), { value: "upload" }, {
                          default: C(() => [
                            ue(Y(h(r)("editor.image.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        _(h($l), { value: "link" }, {
                          default: C(() => [
                            ue(Y(h(r)("editor.image.dialog.tab.url")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    _(h(Gd), { value: "upload" }, {
                      default: C(() => [
                        _(h(Rt), {
                          class: "w-full mt-1",
                          size: "sm",
                          onClick: l
                        }, {
                          default: C(() => [
                            ue(Y(h(r)("editor.image.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        N("input", {
                          type: "file",
                          accept: "image/*",
                          ref_key: "fileInput",
                          ref: o,
                          multiple: "",
                          style: { display: "none" },
                          onChange: i
                        }, null, 544)
                      ]),
                      _: 1
                    }),
                    _(h(Gd), { value: "link" }, {
                      default: C(() => [
                        N("form", {
                          onSubmit: mt(s, ["prevent"])
                        }, [
                          N("div", Toe, [
                            _(h(Mr), {
                              type: "url",
                              autofocus: "",
                              required: "",
                              modelValue: n.value,
                              "onUpdate:modelValue": u[0] || (u[0] = (d) => n.value = d),
                              placeholder: h(r)("editor.image.dialog.placeholder")
                            }, null, 8, ["modelValue", "placeholder"]),
                            _(h(Rt), { type: "submit" }, {
                              default: C(() => [
                                ue(Y(h(r)("editor.image.dialog.button.apply")), 1)
                              ]),
                              _: 1
                            })
                          ])
                        ], 32)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["onOpenAutoFocus"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), Moe = {
  acceptMimes: ["image/jpeg", "image/gif", "image/png", "image/jpg"],
  maxSize: 1024 * 1024 * 5
  // 5MB
}, Ioe = (t) => `${(t / 1024 / 1024).toFixed(2)}MB`, Ure = Ze.create({
  name: "imageUpload",
  isolating: !0,
  defining: !0,
  group: "block",
  draggable: !1,
  selectable: !0,
  inline: !1,
  onCreate() {
    if (typeof this.options.upload != "function")
      throw new Error("Image upload function should be a function");
  },
  parseHTML() {
    return [{ tag: `div[data-type="${this.name}"]` }];
  },
  renderHTML() {
    return ["div", { "data-type": this.name }];
  },
  addCommands() {
    return {
      setImageUpload: () => ({ commands: t }) => t.insertContent(`<div data-type="${this.name}"></div>`)
    };
  },
  addNodeView() {
    return Wl(Ooe);
  },
  addOptions() {
    var t;
    return {
      ...Moe,
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: () => Promise.reject("Image Upload Function"),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ge,
        componentProps: {
          action: () => e == null ? void 0 : e.chain().setImageUpload().run(),
          disabled: !(e != null && e.isEditable) || !e.can().setImage({}),
          icon: "ImageUp",
          tooltip: o("editor.image.tooltip")
        }
      })
    };
  },
  addProseMirrorPlugins() {
    const { toast: t } = oa(), { t: e } = Ge(), o = WE({
      validateFn: (r) => this.options.acceptMimes.includes(r.type) ? r.size > this.options.maxSize ? (t({
        description: `${e.value("editor.imageUpload.fileSizeTooBig")} ${Ioe(this.options.maxSize)}.`,
        duration: 2e3
      }), !1) : !0 : (t({ description: e.value("editor.imageUpload.fileTypeNotSupported"), duration: 2e3 }), !1),
      onUpload: this.options.upload
    });
    return [
      new De({
        props: {
          handlePaste: (r, i) => !i.clipboardData || Array.from(i.clipboardData.items || []).some((a) => a.type === "text/html") ? !1 : Coe(r, i, o),
          handleDrop: (r, i, s, a) => (!(i instanceof DragEvent) || !i.dataTransfer || Soe(r, i, a, o), !1)
        }
      }),
      boe()
    ];
  }
}), Roe = { class: "flex items-center w-full p-3 my-3 hover:bg-accent border border-border text-muted-foreground cursor-pointer rounded-sm transition-all" }, $oe = {
  key: 0,
  class: "flex justify-center items-center gap-3 text-s"
}, Poe = {
  key: 1,
  class: "flex justify-between items-center w-full"
}, Loe = { class: "flex justify-center items-center gap-3" }, Doe = { class: "text-sm" }, Noe = { class: "flex items-center gap-2" }, Boe = /* @__PURE__ */ I({
  __name: "VideoUploader",
  props: {
    ...jl
  },
  setup(t) {
    const e = t, n = R(""), o = R(!1), r = R(), { t: i } = Ge();
    function s(u) {
      var m, g;
      o.value = !0;
      const d = (m = u == null ? void 0 : u.target) == null ? void 0 : m.files;
      if (!e.editor || e.editor.isDestroyed || d.length === 0) return;
      const f = d[0], p = (g = e.editor.extensionManager.extensions.find(
        (v) => v.name === "videoUpload"
      )) == null ? void 0 : g.options;
      p == null || p.upload([f]).then((v) => {
        e.editor.chain().setVideo({ src: v[0].src, width: "100%" }).deleteRange({ from: e.getPos(), to: e.getPos() }).run(), o.value = !1;
      });
    }
    function a() {
      e.editor.chain().setVideo({
        src: n.value,
        width: "100%"
      }).deleteRange({ from: e.getPos(), to: e.getPos() }).run();
    }
    function l() {
      e.deleteNode();
    }
    function c() {
      var u;
      (u = r.value) == null || u.click();
    }
    return (u, d) => (E(), T(h(Ul), {
      as: "div",
      "data-drag-handle": ""
    }, {
      default: C(() => [
        _(h(Vr), { defaultOpen: "" }, {
          default: C(() => [
            _(h(jr), { "as-child": "" }, {
              default: C(() => [
                N("div", Roe, [
                  o.value ? (E(), W("div", $oe, [
                    _(h(ye), {
                      class: "animate-spin w-6 h-6",
                      name: "LoaderCircle"
                    }),
                    N("span", null, Y(h(i)("editor.video.dialog.uploading")) + "...", 1)
                  ])) : (E(), W("div", Poe, [
                    N("div", Loe, [
                      _(h(ye), {
                        name: "Video",
                        class: "w-6 h-6"
                      }),
                      N("span", Doe, Y(h(i)("editor.video.dialog.title")), 1)
                    ]),
                    _(h(ye), {
                      name: "Trash2",
                      class: "hover:text-foreground",
                      onClick: mt(l, ["stop"])
                    })
                  ]))
                ])
              ]),
              _: 1
            }),
            _(h(Ur), {
              trapFocus: "",
              class: "w-full",
              onOpenAutoFocus: (f) => f.preventDefault()
            }, {
              default: C(() => [
                _(h(mv), {
                  "default-value": "upload",
                  class: "w-[400px]",
                  activationMode: "manual"
                }, {
                  default: C(() => [
                    _(h(gv), { class: "grid w-full grid-cols-2" }, {
                      default: C(() => [
                        _(h($l), { value: "upload" }, {
                          default: C(() => [
                            ue(Y(h(i)("editor.video.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        _(h($l), { value: "link" }, {
                          default: C(() => [
                            ue(Y(h(i)("editor.video.dialog.link")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    _(h(Gd), { value: "upload" }, {
                      default: C(() => [
                        _(h(Rt), {
                          class: "w-full mt-1",
                          size: "sm",
                          onClick: c
                        }, {
                          default: C(() => [
                            ue(Y(h(i)("editor.video.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        N("input", {
                          type: "file",
                          accept: "video/*",
                          ref_key: "fileInput",
                          ref: r,
                          multiple: "",
                          style: { display: "none" },
                          onChange: s
                        }, null, 544)
                      ]),
                      _: 1
                    }),
                    _(h(Gd), { value: "link" }, {
                      default: C(() => [
                        N("form", {
                          onSubmit: mt(a, ["prevent"])
                        }, [
                          N("div", Noe, [
                            _(h(Mr), {
                              type: "url",
                              autofocus: "",
                              required: "",
                              modelValue: n.value,
                              "onUpdate:modelValue": d[0] || (d[0] = (f) => n.value = f),
                              placeholder: h(i)("editor.video.dialog.placeholder")
                            }, null, 8, ["modelValue", "placeholder"]),
                            _(h(Rt), { type: "submit" }, {
                              default: C(() => [
                                ue(Y(h(i)("editor.video.dialog.button.apply")), 1)
                              ]),
                              _: 1
                            })
                          ])
                        ], 32)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["onOpenAutoFocus"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), jre = Ze.create({
  name: "videoUpload",
  isolating: !0,
  defining: !0,
  group: "block",
  draggable: !0,
  selectable: !0,
  inline: !1,
  parseHTML() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderHTML() {
    return ["div", { "data-type": this.name }];
  },
  addCommands() {
    return {
      setVideoUpload: () => ({ commands: t }) => t.insertContent(`<div data-type="${this.name}"></div>`)
    };
  },
  addNodeView() {
    return Wl(Boe);
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: void 0,
      button: ({ editor: e, t: n }) => ({
        component: ge,
        componentProps: {
          action: () => e.chain().setVideoUpload().run(),
          isActive: () => e.isActive("video") || !1,
          disabled: !e.isEditable || !e.can().setVideo({}),
          icon: "Video",
          tooltip: n("editor.video.tooltip")
        }
      })
    };
  }
}), Foe = ke.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily,
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
}), zoe = ["data-font"], Hoe = /* @__PURE__ */ I({
  __name: "FontFamilyMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    shortcutKeys: { default: void 0 },
    maxHeight: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, { t: n } = Ge(), o = L(() => {
      const s = e.editor.extensionManager.extensions.find((l) => l.name === "fontFamily").options;
      return {
        [n.value("editor.fontFamily.default")]: n.value("editor.fontFamily.default"),
        ...s.fontFamilyMap
      };
    }), r = L(() => Yg(e.editor.state, "textStyle").fontFamily || n.value("editor.fontFamily.default"));
    function i(s) {
      var a, l;
      s === r.value ? (a = e.editor) == null || a.chain().unsetFontFamily().focus().run() : (l = e.editor) == null || l.chain().setFontFamily(s).focus().run();
    }
    return (s, a) => (E(), T(Bi, {
      disabled: s.disabled,
      tooltip: s.tooltip,
      title: r.value,
      btn_class: "min-w-24 max-w-32"
    }, {
      default: C(() => [
        (E(!0), W(me, null, Oe(o.value, (l, c) => (E(), W(me, { key: c }, [
          _(h(na), {
            "model-value": r.value === l,
            onClick: (u) => i(l)
          }, {
            default: C(() => [
              N("span", {
                class: "ml-1 h-full",
                "data-font": l,
                style: pt({ fontFamily: l ?? void 0 })
              }, Y(l), 13, zoe)
            ]),
            _: 2
          }, 1032, ["model-value", "onClick"]),
          l === h(n)("editor.fontFamily.default") ? (E(), T(h(vv), { key: 0 })) : oe("", !0)
        ], 64))), 128))
      ]),
      _: 1
    }, 8, ["disabled", "tooltip", "title"]));
  }
}), Wre = Foe.extend({
  name: "fontFamily",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["textStyle"],
      fontFamilyMap: UO,
      button({ editor: e, extension: n, t: o }) {
        return {
          component: Hoe,
          componentProps: {
            editor: e,
            disabled: !(e != null && e.isEditable) || !e.can().setFontFamily(""),
            tooltip: o("editor.fontFamily.tooltip")
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily.replace(/['"]/g, ""),
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
}), Th = vn(), Kre = ke.create({
  name: "preview",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ t: e }) => ({
        component: ge,
        componentProps: {
          icon: "Eye",
          action: () => {
            Th.togglePreview();
          },
          tooltip: e("editor.preview.tooltip"),
          isActive: () => Th.state.showPreview
        }
      })
    };
  },
  addCommands() {
    return {
      togglePreview: () => ({ editor: t }) => (Th.togglePreview(), !0)
    };
  }
}), j2 = vn(), Voe = (t, e, n) => RegExp(e ? t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : t, n ? "gu" : "gui");
function Uoe(t, e, n, o) {
  const r = [], i = [];
  let s = [], a = 0;
  if (!e)
    return {
      decorationsToReturn: Te.empty,
      results: []
    };
  t == null || t.descendants((l, c) => {
    l.isText ? s[a] ? s[a] = {
      text: s[a].text + l.text,
      pos: s[a].pos
    } : s[a] = {
      text: `${l.text}`,
      pos: c
    } : a += 1;
  }), s = s.filter(Boolean);
  for (const l of s) {
    const { text: c, pos: u } = l, d = Array.from(c.matchAll(e)).filter(([f]) => f.trim());
    for (const f of d) {
      if (f[0] === "") break;
      f.index !== void 0 && i.push({
        from: u + f.index,
        to: u + f.index + f[0].length
      });
    }
  }
  for (let l = 0; l < i.length; l += 1) {
    const c = i[l], u = l === o ? `${n} ${n}-current` : n, d = ft.inline(c.from, c.to, {
      class: u
    });
    r.push(d);
  }
  return {
    decorationsToReturn: Te.create(t, r),
    results: i
  };
}
const joe = (t, e, { state: n, dispatch: o }) => {
  if (!e[0]) return;
  const { from: i, to: s } = e[0];
  o && o(n.tr.insertText(t, i, s));
}, Woe = (t, e, n, o) => {
  const r = e + 1;
  if (!o[r]) return null;
  const { from: i, to: s } = o[e], a = s - i - t.length + n, { from: l, to: c } = o[r];
  return o[r] = {
    to: c - a,
    from: l - a
  }, [a, o];
}, Koe = (t, e, { tr: n, dispatch: o }) => {
  let r = 0, i = e.slice();
  if (i.length) {
    for (let s = 0; s < i.length; s += 1) {
      const { from: a, to: l } = i[s];
      n.insertText(t, a, l);
      const c = Woe(t, s, r, i);
      c && (r = c[0], i = c[1]);
    }
    o && o(n);
  }
}, Goe = new Ne("findAndReplacePlugin"), Gre = ke.create({
  name: "findAndReplace",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      searchResultClass: "echo-editor-search-result",
      disableRegex: !0,
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ge,
        componentProps: {
          icon: "DocSearch",
          tooltip: o("editor.findAndReplace.tooltip"),
          shortcutKeys: ["mod", "F"],
          action: () => {
            j2.toggleFindAndReplace();
          },
          isActive: () => j2.state.findAndReplace
        }
      })
    };
  },
  addStorage() {
    return {
      searchTerm: "",
      replaceTerm: "",
      results: [],
      lastSearchTerm: "",
      caseSensitive: !1,
      lastCaseSensitive: !1,
      resultIndex: 0,
      lastResultIndex: 0
    };
  },
  addCommands() {
    return {
      setSearchTerm: (t) => ({ editor: e }) => (e.storage.findAndReplace.searchTerm = t, !1),
      setReplaceTerm: (t) => ({ editor: e }) => (e.storage.findAndReplace.replaceTerm = t, !1),
      setCaseSensitive: (t) => ({ editor: e }) => (e.storage.findAndReplace.caseSensitive = t, !1),
      resetIndex: () => ({ editor: t }) => (t.storage.findAndReplace.resultIndex = 0, !1),
      nextSearchResult: () => ({ editor: t }) => {
        const { results: e, resultIndex: n } = t.storage.findAndReplace, o = n + 1;
        return e[o] ? t.storage.findAndReplace.resultIndex = o : t.storage.findAndReplace.resultIndex = 0, !1;
      },
      previousSearchResult: () => ({ editor: t }) => {
        const { results: e, resultIndex: n } = t.storage.findAndReplace, o = n - 1;
        return e[o] ? t.storage.findAndReplace.resultIndex = o : t.storage.findAndReplace.resultIndex = e.length - 1, !1;
      },
      replace: () => ({ editor: t, state: e, dispatch: n }) => {
        const { replaceTerm: o, results: r } = t.storage.findAndReplace;
        return joe(o, r, { state: e, dispatch: n }), !1;
      },
      replaceAll: () => ({ editor: t, tr: e, dispatch: n }) => {
        const { replaceTerm: o, results: r } = t.storage.findAndReplace;
        return Koe(o, r, { tr: e, dispatch: n }), !1;
      }
    };
  },
  addProseMirrorPlugins() {
    const t = this.editor, { searchResultClass: e, disableRegex: n } = this.options, o = (s) => t.storage.findAndReplace.lastSearchTerm = s, r = (s) => t.storage.findAndReplace.lastCaseSensitive = s, i = (s) => t.storage.findAndReplace.lastResultIndex = s;
    return [
      new De({
        key: Goe,
        state: {
          init: () => Te.empty,
          apply({ doc: s, docChanged: a }, l) {
            const { searchTerm: c, lastSearchTerm: u, caseSensitive: d, lastCaseSensitive: f, resultIndex: p, lastResultIndex: m } = t.storage.findAndReplace;
            if (!a && u === c && f === d && m === p)
              return l;
            if (o(c), r(d), i(p), !c)
              return t.storage.findAndReplace.results = [], Te.empty;
            const { decorationsToReturn: g, results: v } = Uoe(
              s,
              Voe(c, n, d),
              e,
              p
            );
            return t.storage.findAndReplace.results = v, g;
          }
        },
        props: {
          decorations(s) {
            return this.getState(s);
          }
        }
      })
    ];
  }
}), { togglePrinter: qoe, state: Yoe } = vn(), qre = ke.create({
  name: "printer",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ge,
        componentProps: {
          tooltip: o("editor.printer.tooltip"),
          action: () => qoe(),
          icon: "Printer",
          shortcutKeys: ["mod", "P"],
          isActive: () => Yoe.printer
        }
      })
    };
  }
}), Joe = {
  key: 0,
  class: "flex flex-row relative items-center"
}, Xoe = { class: "flex gap-2 absolute right-1 w-36" }, Zoe = ["src"], Qoe = /* @__PURE__ */ I({
  __name: "IframeNodeView",
  props: {
    ...jl
  },
  setup(t) {
    const e = t, n = R(""), o = L({
      get: () => e.node.attrs.src,
      set: (s) => {
        n.value = s, e.updateAttributes({ src: s });
      }
    });
    function r() {
      let s = A2(e.node.attrs.service, n.value);
      s.validLink && s.validId ? o.value = s.src : console.log("暂不支持");
    }
    function i() {
      const s = $te(e.node.attrs.service);
      if (s) {
        let a = A2(e.node.attrs.service, s);
        o.value = a.src;
      }
    }
    return be(() => {
      n.value = e.node.attrs.src;
    }), (s, a) => (E(), T(h(Ul), { as: "section" }, {
      default: C(() => [
        o.value ? oe("", !0) : (E(), W("div", Joe, [
          _(h(Mr), {
            "model-value": n.value,
            "onUpdate:modelValue": a[0] || (a[0] = (l) => n.value = l),
            type: "url",
            class: "h-12 pr-40",
            autofocus: "",
            placeholder: "输入链接"
          }, null, 8, ["model-value"]),
          N("div", Xoe, [
            _(h(Rt), {
              onClick: i,
              variant: "outline"
            }, {
              default: C(() => a[1] || (a[1] = [
                ue("示例")
              ])),
              _: 1
            }),
            _(h(Rt), {
              type: "primary",
              onClick: r
            }, {
              default: C(() => a[2] || (a[2] = [
                ue("确认")
              ])),
              _: 1
            })
          ])
        ])),
        o.value ? (E(), W("iframe", {
          key: 1,
          src: o.value,
          frameborder: "0",
          allowfullscreen: "true"
        }, null, 8, Zoe)) : oe("", !0)
      ]),
      _: 1
    }));
  }
}), Yre = Ze.create({
  name: "iframes",
  group: "block",
  atom: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      allowFullscreen: !0,
      HTMLAttributes: {
        class: "iframe-wrapper"
      }
    };
  },
  addAttributes() {
    return {
      src: {
        default: null
      },
      service: {
        default: null
      },
      frameborder: {
        default: 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", this.options.HTMLAttributes, ["iframe", t]];
  },
  addNodeView() {
    return Wl(Qoe);
  },
  addCommands() {
    return {
      setIframe: (t) => ({ tr: e, dispatch: n }) => {
        const { selection: o } = e, r = this.type.create(t);
        return n && e.replaceRangeWith(o.from, o.to, r), !0;
      }
    };
  }
});
ZX();
const Jre = {
  install(t) {
    t.component("echo-editor", XX);
  }
};
export {
  zre as AI,
  ge as ActionButton,
  Mre as BaseKit,
  Ere as Blockquote,
  ure as Bold,
  xre as BulletList,
  Cre as Clear,
  hre as Code,
  mre as CodeBlock,
  bre as Color,
  cre as Columns,
  XX as EchoEditor,
  Jre as EchoEditorPlugin,
  Gre as FindAndReplace,
  Wre as FontFamily,
  yre as FontSize,
  Hre as FormatPainter,
  Ore as Fullscreen,
  gre as Heading,
  wre as Highlight,
  Tre as History,
  Are as HorizontalRule,
  Yre as Iframe,
  Dre as Image,
  Ure as ImageUpload,
  Vre as ImportWord,
  $re as Indent,
  dre as Italic,
  Pre as LineHeight,
  _re as Link,
  Rre as MoreMark,
  Sre as OrderedList,
  Kre as Preview,
  qre as Printer,
  Lre as SlashCommand,
  pre as Strike,
  Ire as SubAndSuperScript,
  Fre as Table,
  kre as TaskList,
  vre as TextAlign,
  fre as Underline,
  Nre as Video,
  jre as VideoUpload,
  Jre as default,
  AF as en,
  ab as locale,
  ire as useEditor,
  _F as zhHans
};
